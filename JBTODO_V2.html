<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î¨ºÎ¶¨ÏóîÏßÑ TODO Í¥ÄÎ¶¨Ïûê</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .input-section {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            text-align: center;
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        #todoInput {
            padding: 15px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            width: 400px;
            margin-right: 10px;
            outline: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        #addBtn, .control-btn {
            padding: 15px 30px;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 0 5px;
        }
        
        #addBtn {
            background: #ff6b6b;
        }
        
        #addBtn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }
        
        .control-btn.complete-btn {
            background: #51cf66;
        }
        
        .control-btn.complete-btn:hover {
            background: #40c057;
            transform: translateY(-2px);
        }
        
        .control-btn.delete-btn {
            background: #ff6b6b;
        }
        
        .control-btn.delete-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }
        
        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .game-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: rgba(255,255,255,0.1);
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .control-info {
            margin: 10px 0;
            font-size: 18px;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .falling-block {
            position: absolute;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .falling-block:hover {
            transform: scale(1.05);
        }
        
        .falling-block.completed {
            background: linear-gradient(45deg, #51cf66, #69db7c);
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .block-actions {
            position: absolute;
            display: none;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 8px;
            gap: 8px;
            z-index: 9999;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        
        .block-actions.show {
            display: flex;
        }
        
        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            min-width: 60px;
            text-align: center;
            z-index: 10000;
            position: relative;
        }
        
        .complete-btn {
            background: #51cf66;
        }
        
        .complete-btn:hover {
            background: #40c057;
            transform: scale(1.05);
        }
        
        .delete-btn {
            background: #ff6b6b;
        }
        
        .delete-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        /* Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ Ïä§ÌÉÄÏùº Ï∂îÍ∞Ä */
        .resize-handle {
            position: absolute;
            background: #ff0000;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            z-index: 10001;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .resize-handle:hover {
            background: #ff3333;
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(0,0,0,0.5);
        }
        
        .resize-handle.nw-resize { cursor: nw-resize; }
        .resize-handle.n-resize { cursor: n-resize; }
        .resize-handle.ne-resize { cursor: ne-resize; }
        .resize-handle.e-resize { cursor: e-resize; }
        .resize-handle.se-resize { cursor: se-resize; }
        .resize-handle.s-resize { cursor: s-resize; }
        .resize-handle.sw-resize { cursor: sw-resize; }
        .resize-handle.w-resize { cursor: w-resize; }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <input type="text" id="todoInput" placeholder="Ìï†ÏùºÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî... (ÏµúÎåÄ 100Ïûê)" maxlength="100">
            <button id="addBtn">Î∏îÎü≠ Ï∂îÍ∞Ä</button>
            <button id="completeBtn" class="control-btn complete-btn">‚úÖ ÏôÑÎ£å</button>
            <button id="deleteBtn" class="control-btn delete-btn">üóëÔ∏è ÏÇ≠Ï†ú</button>
        </div>
        
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
        </div>
        

    </div>

    <script>
        // Matter.js Î™®Îìà
        const { Engine, Render, Bodies, World, Mouse, MouseConstraint, Body, Events } = Matter;
        
        // Í≤åÏûÑ ÏÉÅÌÉú
        let engine, render, world;
        let currentBlock = null;
        let isBlockFalling = false;
        let todos = [];
        let totalCount = 0;
        let completedCount = 0;
        let hoveredBlock = null;
        let selectedBlock = null;
        let particles = [];
        let walls = []; // Î≤ΩÎì§ÏùÑ Ï∂îÏ†ÅÌïòÍ∏∞ ÏúÑÌïú Î∞∞Ïó¥
        let resizeHandles = []; // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§Îì§
        let isResizing = false; // Î¶¨ÏÇ¨Ïù¥Ï¶à Ï§ëÏù∏ÏßÄ Ïó¨Î∂Ä
        let resizeData = null; // Î¶¨ÏÇ¨Ïù¥Ï¶à Îç∞Ïù¥ÌÑ∞
        
                 // Í≤åÏûÑ ÏÑ§Ï†ï (ÎèôÏ†Å ÌÅ¨Í∏∞)
        let CANVAS_WIDTH = 800;
        let CANVAS_HEIGHT = 600;
        const MIN_BLOCK_WIDTH = 80;
        const MIN_BLOCK_HEIGHT = 40;
        const LINE_HEIGHT = 20;
        
                 // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò (Ï†ÑÏ≤¥ ÌôîÎ©¥)
        function updateCanvasSize() {
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            
            const canvas = document.getElementById('gameCanvas');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            if (render) {
                render.canvas.width = CANVAS_WIDTH;
                render.canvas.height = CANVAS_HEIGHT;
                render.options.width = CANVAS_WIDTH;
                render.options.height = CANVAS_HEIGHT;
                render.canvas.style.width = CANVAS_WIDTH + 'px';
                render.canvas.style.height = CANVAS_HEIGHT + 'px';
            }
        }
        
        // Î≤Ω ÏÉùÏÑ± Ìï®Ïàò
        function createWalls() {
            // Í∏∞Ï°¥ Î≤ΩÎì§ Ï†úÍ±∞
            if (walls.length > 0) {
                World.remove(world, walls);
                walls = [];
            }
            
            const wallThickness = 20;
            walls = [
                // Î∞îÎã• Î≤Ω (ÌôîÎ©¥ ÏïÑÎûò)
                Bodies.rectangle(CANVAS_WIDTH/2, CANVAS_HEIGHT + wallThickness/2, CANVAS_WIDTH + wallThickness*2, wallThickness, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // ÏôºÏ™Ω Î≤Ω (ÌôîÎ©¥ ÏôºÏ™Ω Í≤ΩÍ≥ÑÏóê ÎßûÏ∂§)
                Bodies.rectangle(-wallThickness/2, CANVAS_HEIGHT/2, wallThickness, CANVAS_HEIGHT + wallThickness*2, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // Ïò§Î•∏Ï™Ω Î≤Ω (ÎèôÏ†Å ÎÑàÎπÑÏóê ÎßûÏ∂§)
                Bodies.rectangle(CANVAS_WIDTH - wallThickness/2, CANVAS_HEIGHT/2, wallThickness, CANVAS_HEIGHT + wallThickness*2, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // ÏúÑÏ™Ω Î≤Ω (ÌôîÎ©¥ ÏúÑÏ™Ω Í≤ΩÍ≥ÑÏóê ÎßûÏ∂§)
                Bodies.rectangle(CANVAS_WIDTH/2, -wallThickness/2, CANVAS_WIDTH + wallThickness*2, wallThickness, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                })
            ];
            
            World.add(world, walls);
        }

        // Í≤åÏûÑ Ï¥àÍ∏∞Ìôî
        function initGame() {
            // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Î®ºÏ†Ä ÏÑ§Ï†ï
            updateCanvasSize();
            
            // ÏóîÏßÑ ÏÉùÏÑ±
            engine = Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0.4;
            
            // Î†åÎçîÎü¨ ÏÉùÏÑ±
            render = Render.create({
                canvas: document.getElementById('gameCanvas'),
                engine: engine,
                options: {
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                    wireframes: false,
                    background: 'transparent',
                    showVelocity: false,
                    showAngleIndicator: false,
                    showDebug: false
                }
            });
            
            // Î≤Ω ÏÉùÏÑ±
            createWalls();
            
            // ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏ Ï†úÏñ¥ Ï∂îÍ∞Ä (Í≤ΩÍ≥Ñ Ï†úÌïú)
            const mouse = Mouse.create(render.canvas);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.6, // ÏïΩÍ∞Ñ Î∂ÄÎìúÎüΩÍ≤å Ï°∞Ï†ï
                    render: { visible: false },
                    length: 0, // ÎßàÏö∞Ïä§ÏôÄ Î∏îÎü≠ ÏÇ¨Ïù¥ Í±∞Î¶¨ Ï†úÌïú
                    damping: 0.9 // Í∞êÏá† Ï∂îÍ∞ÄÎ°ú ÏïàÏ†ïÏÑ± Ìñ•ÏÉÅ
                }
            });
            World.add(world, mouseConstraint);
            
            // Î†åÎçîÎßÅ ÏãúÏûë
            Render.run(render);
            Engine.run(engine);
            
            // Ï∂©Îèå Í∞êÏßÄ
            Events.on(engine, 'collisionStart', handleCollision);
        }
        
                 // ÌÖçÏä§Ìä∏Î•º Ï§ÑÎ∞îÍøàÌïòÎäî Ìï®Ïàò (20ÏûêÎ¶¨ Í∏∞Ï§Ä)
        function wrapText(text, maxCharsPerLine = 20) {
            const lines = [];
            for (let i = 0; i < text.length; i += maxCharsPerLine) {
                lines.push(text.substring(i, i + maxCharsPerLine));
            }
            return lines;
        }
        
        // Î∏îÎü≠ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ Ìï®Ïàò (Ïª¥Ìå©Ìä∏Ìïú ÏÇ¨Ïù¥Ï¶à)
        function calculateBlockSize(text) {
            const lines = wrapText(text);
            
            // Ïã§Ï†ú ÌÖçÏä§Ìä∏ Í∏∏Ïù¥Î•º Îçî Ï†ïÌôïÌïòÍ≤å Ï∏°Ï†ï
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 12px Arial';
            
            // Í∞ÄÏû• Í∏¥ Ï§ÑÏùò Ïã§Ï†ú ÌîΩÏÖÄ ÎÑàÎπÑ Í≥ÑÏÇ∞
            let maxTextWidth = 0;
            lines.forEach(line => {
                const textWidth = ctx.measureText(line).width;
                maxTextWidth = Math.max(maxTextWidth, textWidth);
            });
            
            // Ïª¥Ìå©Ìä∏Ìïú ÏÇ¨Ïù¥Ï¶à Í≥ÑÏÇ∞ (ÌÖçÏä§Ìä∏ ÎÑàÎπÑ + ÏµúÏÜå Ìå®Îî©)
            const width = Math.max(MIN_BLOCK_WIDTH, maxTextWidth + 20); // Ìå®Îî© 20pxÎ°ú Ï§ÑÏûÑ
            const height = Math.max(MIN_BLOCK_HEIGHT, lines.length * LINE_HEIGHT + 15); // ÏÉÅÌïò Ìå®Îî© 15pxÎ°ú Ï§ÑÏûÑ
            
            return { width, height, lines };
        }
        
                 // ÏÉà Î∏îÎü≠ ÏÉùÏÑ±
        function createTodoBlock(text) {
            // ÎûúÎç§Ìïú x ÏúÑÏπò (Î∏îÎü≠ ÌÅ¨Í∏∞Î•º Í≥†Î†§Ìïú ÏïàÏ†Ñ Î≤îÏúÑ)
            const margin = 100; // Î≤ΩÏóêÏÑú Îñ®Ïñ¥ÏßÑ Í±∞Î¶¨
            const x = margin + Math.random() * (CANVAS_WIDTH - margin * 2);
            const y = 30; // ÏúÑÏ™Ω Î≤Ω(y=-12.5) Î∞îÎ°ú ÏïÑÎûòÏóêÏÑú ÏÉùÏÑ±
            
            // Î∏îÎü≠ ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            const { width, height, lines } = calculateBlockSize(text);
            
            // ÏÉâÏÉÅ ÎûúÎç§ ÏÉùÏÑ±
            const colors = [
                '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', 
                '#ffd93d', '#ff9ff3', '#54a0ff', '#5f27cd'
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const block = Bodies.rectangle(x, y, width, height, {
                render: {
                    fillStyle: color,
                    strokeStyle: '#fff',
                    lineWidth: 3
                },
                chamfer: { radius: 15 }, // Îë•Í∑º Î™®ÏÑúÎ¶¨
                density: 0.002, // 2Î∞∞ Î¨¥Í≤åÍ∞ê (Í∏∞Î≥∏Í∞í 0.001Ïùò 2Î∞∞)
                frictionAir: 0.005, // Í≥µÍ∏∞ Ï†ÄÌï≠ Í∞êÏÜåÎ°ú Îçî Î¨¥Í≤ÅÍ≤å
                restitution: 0.2, // ÌÉÑÏÑ± Í∞êÏÜåÎ°ú Îçî Î¨µÏßÅÌïòÍ≤å
                friction: 0.9 // ÎßàÏ∞∞ Ï¶ùÍ∞ÄÎ°ú Îçî ÏïàÏ†ïÏ†ÅÏúºÎ°ú
            });
            
            // Î∏îÎü≠Ïóê ÌÖçÏä§Ìä∏ Ï†ïÎ≥¥ Ï†ÄÏû•
            block.todoText = text;
            block.textLines = lines;
            block.blockWidth = width;
            block.blockHeight = height;
            block.isCompleted = false;
            block.isSelected = false;
            block.originalColor = color;
            block.id = Date.now() + Math.random();
            
            World.add(world, block);
            todos.push(block);
            currentBlock = block;
            isBlockFalling = true;
            
            updateStats();
            return block;
        }
        
                 // Î∏îÎü≠ ÏôÑÎ£å Ï≤òÎ¶¨ (ÌöåÏÉâ + Ï∑®ÏÜåÏÑ†, ÏÇ≠Ï†úÌïòÏßÄ ÏïäÏùå)
        function completeBlock(block) {
            if (block && !block.isCompleted) {
                block.isCompleted = true;
                block.render.fillStyle = '#888888'; // ÌöåÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
                block.originalColor = '#888888';
                completedCount++;
                
                // ÏôÑÎ£å Ï∂ïÌïò ÌååÌã∞ÌÅ¥ Ìö®Í≥º (2Î∞∞ + Ïù¥Î™®Ìã∞ÏΩò)
                const completeEmojis = ['‚ú®', 'üéâ', '‚úÖ', 'üëè', 'üéä', 'üåü', 'üí´', 'üéà'];
                createParticles(block.position.x, block.position.y, '#51cf66', 40); // 2Î∞∞ ÌååÌã∞ÌÅ¥
                createEmojiParticles(block.position.x, block.position.y, completeEmojis, 20); // Ïù¥Î™®Ìã∞ÏΩò ÌååÌã∞ÌÅ¥
                
                updateStats();
            }
        }
        
                 // ÌååÌã∞ÌÅ¥ ÏãúÏä§ÌÖú (3Î∞∞ ÌôïÏû•Îêú Ìè≠Î∞ú Î≤îÏúÑ)
        function createParticles(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 30, // 3Î∞∞ ÌôïÏû•
                    vy: (Math.random() - 0.5) * 30 - 15, // 3Î∞∞ ÌôïÏû•
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.01,
                    type: 'circle'
                });
            }
        }
        
        // Ïù¥Î™®Ìã∞ÏΩò ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± (3Î∞∞ ÌôïÏû•Îêú Ìè≠Î∞ú Î≤îÏúÑ)
        function createEmojiParticles(x, y, emojis, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 24, // 3Î∞∞ ÌôïÏû•
                    vy: (Math.random() - 0.5) * 24 - 9, // 3Î∞∞ ÌôïÏû•
                    size: Math.random() * 10 + 15,
                    emoji: emojis[Math.floor(Math.random() * emojis.length)],
                    life: 1.0,
                    decay: Math.random() * 0.015 + 0.008,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    type: 'emoji'
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3; // Ï§ëÎ†•
                p.vx *= 0.98; // Í≥µÍ∏∞ Ï†ÄÌï≠
                p.life -= p.decay;
                
                // Ïù¥Î™®Ìã∞ÏΩò ÌååÌã∞ÌÅ¥ ÌöåÏ†Ñ
                if (p.type === 'emoji') {
                    p.rotation += p.rotationSpeed;
                }
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ ÏÉùÏÑ± Ìï®Ïàò (ÌöåÏ†Ñ Í≥†Î†§)
        function createResizeHandles(block) {
            removeResizeHandles(); // Í∏∞Ï°¥ Ìï∏Îì§ Ï†úÍ±∞
            
            if (!block || !block.isSelected) return;
            
            const pos = block.position;
            const width = block.blockWidth || MIN_BLOCK_WIDTH;
            const height = block.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = block.angle; // Î∏îÎü≠Ïùò ÌöåÏ†Ñ Í∞ÅÎèÑ
            
            // Î∏îÎü≠ Ï§ëÏã¨ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ìïú ÏÉÅÎåÄ ÏúÑÏπòÎì§ (ÌöåÏ†Ñ Ï†Ñ)
            const relativePositions = [
                { type: 'nw', x: -width/2, y: -height/2 },
                { type: 'n', x: 0, y: -height/2 },
                { type: 'ne', x: width/2, y: -height/2 },
                { type: 'e', x: width/2, y: 0 },
                { type: 'se', x: width/2, y: height/2 },
                { type: 's', x: 0, y: height/2 },
                { type: 'sw', x: -width/2, y: height/2 },
                { type: 'w', x: -width/2, y: 0 }
            ];
            
            // ÌöåÏ†Ñ Î≥ÄÌôòÏùÑ Ï†ÅÏö©Ìïú Ï†àÎåÄ ÏúÑÏπòÎì§
            const rotatedHandles = relativePositions.map(relPos => {
                const rotatedX = relPos.x * Math.cos(angle) - relPos.y * Math.sin(angle);
                const rotatedY = relPos.x * Math.sin(angle) + relPos.y * Math.cos(angle);
                
                return {
                    type: relPos.type,
                    x: pos.x + rotatedX,
                    y: pos.y + rotatedY
                };
            });
            
            rotatedHandles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = `resize-handle ${handle.type}-resize`;
                handleElement.style.left = (handle.x - 6) + 'px';
                handleElement.style.top = (handle.y - 6) + 'px';
                handleElement.dataset.type = handle.type;
                
                // Ìï∏Îì§ ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏
                handleElement.addEventListener('mousedown', startResize);
                
                document.body.appendChild(handleElement);
                resizeHandles.push(handleElement);
            });
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ Ï†úÍ±∞
        function removeResizeHandles() {
            resizeHandles.forEach(handle => {
                if (handle.parentNode) {
                    handle.parentNode.removeChild(handle);
                }
            });
            resizeHandles = [];
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ (ÌöåÏ†Ñ Í≥†Î†§)
        function updateResizeHandles() {
            if (!selectedBlock || resizeHandles.length === 0) return;
            
            const pos = selectedBlock.position;
            const width = selectedBlock.blockWidth || MIN_BLOCK_WIDTH;
            const height = selectedBlock.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = selectedBlock.angle; // Î∏îÎü≠Ïùò ÌöåÏ†Ñ Í∞ÅÎèÑ
            
            // Î∏îÎü≠ Ï§ëÏã¨ÏùÑ Í∏∞Ï§ÄÏúºÎ°ú Ìïú ÏÉÅÎåÄ ÏúÑÏπòÎì§ (ÌöåÏ†Ñ Ï†Ñ)
            const relativePositions = [
                { x: -width/2, y: -height/2 }, // nw
                { x: 0, y: -height/2 },         // n
                { x: width/2, y: -height/2 },   // ne
                { x: width/2, y: 0 },           // e
                { x: width/2, y: height/2 },    // se
                { x: 0, y: height/2 },          // s
                { x: -width/2, y: height/2 },   // sw
                { x: -width/2, y: 0 }           // w
            ];
            
            // ÌöåÏ†Ñ Î≥ÄÌôòÏùÑ Ï†ÅÏö©Ìïú Ï†àÎåÄ ÏúÑÏπòÎì§
            const rotatedPositions = relativePositions.map(relPos => {
                const rotatedX = relPos.x * Math.cos(angle) - relPos.y * Math.sin(angle);
                const rotatedY = relPos.x * Math.sin(angle) + relPos.y * Math.cos(angle);
                
                return {
                    x: pos.x + rotatedX,
                    y: pos.y + rotatedY
                };
            });
            
            resizeHandles.forEach((handle, index) => {
                if (rotatedPositions[index]) {
                    handle.style.left = (rotatedPositions[index].x - 6) + 'px';
                    handle.style.top = (rotatedPositions[index].y - 6) + 'px';
                }
            });
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à ÏãúÏûë
        function startResize(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!selectedBlock) return;
            
            isResizing = true;
            const handleType = e.target.dataset.type;
            
            resizeData = {
                block: selectedBlock,
                handleType: handleType,
                startX: e.clientX,
                startY: e.clientY,
                startWidth: selectedBlock.blockWidth || MIN_BLOCK_WIDTH,
                startHeight: selectedBlock.blockHeight || MIN_BLOCK_HEIGHT,
                startPosX: selectedBlock.position.x,
                startPosY: selectedBlock.position.y,
                startAngle: selectedBlock.angle
            };
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', endResize);
            
            // Î¨ºÎ¶¨ÏóîÏßÑ ÏùºÏãú Ï†ïÏßÄ (Î¶¨ÏÇ¨Ïù¥Ï¶à Ï§ë ÏïàÏ†ïÏÑ±ÏùÑ ÏúÑÌï¥)
            Body.setStatic(selectedBlock, true);
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à Ïã§Ìñâ (ÌöåÏ†Ñ Í≥†Î†§)
        function doResize(e) {
            if (!isResizing || !resizeData) return;
            
            const deltaX = e.clientX - resizeData.startX;
            const deltaY = e.clientY - resizeData.startY;
            const angle = resizeData.block.angle;
            
            // ÎßàÏö∞Ïä§ Ïù¥ÎèôÎüâÏùÑ Î∏îÎü≠Ïùò Î°úÏª¨ Ï¢åÌëúÍ≥ÑÎ°ú Î≥ÄÌôò
            const localDeltaX = deltaX * Math.cos(-angle) - deltaY * Math.sin(-angle);
            const localDeltaY = deltaX * Math.sin(-angle) + deltaY * Math.cos(-angle);
            
            let newWidth = resizeData.startWidth;
            let newHeight = resizeData.startHeight;
            let localPosOffsetX = 0;
            let localPosOffsetY = 0;
            
            // Ìï∏Îì§ ÌÉÄÏûÖÏóê Îî∞Î•∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï (Î°úÏª¨ Ï¢åÌëúÍ≥Ñ Í∏∞Ï§Ä)
            switch (resizeData.handleType) {
                case 'nw':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'n':
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'ne':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'e':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    localPosOffsetX = localDeltaX / 2;
                    break;
                case 'se':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 's':
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'sw':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'w':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    localPosOffsetX = localDeltaX / 2;
                    break;
            }
            
            // Î°úÏª¨ Ï¢åÌëúÍ≥ÑÏùò ÏúÑÏπò Ïò§ÌîÑÏÖãÏùÑ Í∏ÄÎ°úÎ≤å Ï¢åÌëúÍ≥ÑÎ°ú Î≥ÄÌôò
            const globalPosOffsetX = localPosOffsetX * Math.cos(angle) - localPosOffsetY * Math.sin(angle);
            const globalPosOffsetY = localPosOffsetX * Math.sin(angle) + localPosOffsetY * Math.cos(angle);
            
            const newPosX = resizeData.startPosX + globalPosOffsetX;
            const newPosY = resizeData.startPosY + globalPosOffsetY;
            
            // Î∏îÎü≠ ÌÅ¨Í∏∞ÏôÄ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            Body.scale(resizeData.block, newWidth / resizeData.block.blockWidth, newHeight / resizeData.block.blockHeight);
            Body.setPosition(resizeData.block, { x: newPosX, y: newPosY });
            
            // Î∏îÎü≠ ÏÜçÏÑ± ÏóÖÎç∞Ïù¥Ìä∏
            resizeData.block.blockWidth = newWidth;
            resizeData.block.blockHeight = newHeight;
            
            // Ìï∏Îì§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            updateResizeHandles();
        }
        
        // Î¶¨ÏÇ¨Ïù¥Ï¶à Ï¢ÖÎ£å
        function endResize() {
            if (isResizing && resizeData) {
                // Î¨ºÎ¶¨ÏóîÏßÑ Ïû¨Í∞ú
                Body.setStatic(resizeData.block, false);
                
                isResizing = false;
                resizeData = null;
                
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', endResize);
            }
        }
        
        // Î∏îÎü≠ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ Î∞è Î≥µÍµ¨ Ìï®Ïàò
        function checkAndFixBlockBounds() {
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                let needsRepositioning = false;
                let newX = pos.x;
                let newY = pos.y;
                
                // Ï¢åÏö∞ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (Î≤Ω ÎëêÍªò Í≥†Î†§)
                const wallThickness = 20;
                if (pos.x - blockWidth/2 < wallThickness) {
                    newX = blockWidth/2 + wallThickness + 5;
                    needsRepositioning = true;
                } else if (pos.x + blockWidth/2 > CANVAS_WIDTH - wallThickness) {
                    newX = CANVAS_WIDTH - wallThickness - blockWidth/2 - 5;
                    needsRepositioning = true;
                }
                
                // ÏÉÅÌïò Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨ (ÏúÑÏ™ΩÎßå, ÏïÑÎûòÏ™ΩÏùÄ Î∞îÎã• Î≤ΩÏù¥ Ï≤òÎ¶¨)
                if (pos.y - blockHeight/2 < wallThickness) {
                    newY = blockHeight/2 + wallThickness + 5;
                    needsRepositioning = true;
                }
                
                // Î∏îÎü≠Ïù¥ ÌôîÎ©¥ ÏïÑÎûòÎ°ú ÎÑàÎ¨¥ ÎßéÏù¥ ÎÇòÍ∞îÏùÑ ÎïåÎèÑ Ï≤¥ÌÅ¨
                if (pos.y > CANVAS_HEIGHT + 100) {
                    newY = CANVAS_HEIGHT - blockHeight/2 - 5;
                    needsRepositioning = true;
                }
                
                // ÏúÑÏπò Ï°∞Ï†ïÏù¥ ÌïÑÏöîÌïú Í≤ΩÏö∞
                if (needsRepositioning) {
                    Body.setPosition(block, { x: newX, y: newY });
                    // ÏÜçÎèÑÎèÑ Ï¥àÍ∏∞ÌôîÌï¥ÏÑú ÏïàÏ†ïÌôî
                    Body.setVelocity(block, { x: 0, y: 0 });
                    Body.setAngularVelocity(block, 0);
                }
            });
        }
        
        function renderParticles() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                
                if (p.type === 'emoji') {
                    // Ïù¥Î™®Ìã∞ÏΩò ÌååÌã∞ÌÅ¥ Î†åÎçîÎßÅ
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.font = `${p.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.emoji, 0, 0);
                } else {
                    // ÏõêÌòï ÌååÌã∞ÌÅ¥ Î†åÎçîÎßÅ
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }
        
                 // Î∏îÎü≠ ÏÇ≠Ï†ú Ï≤òÎ¶¨ (ÌååÌã∞ÌÅ¥ Ìö®Í≥ºÏôÄ Ìï®Íªò)
        function deleteBlock(block) {
            if (block) {
                // ÏÑ†ÌÉùÎêú Î∏îÎü≠Ïù¥ ÏÇ≠Ï†úÎêòÎäî Í≤ΩÏö∞ Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ Ï†úÍ±∞
                if (selectedBlock && selectedBlock.id === block.id) {
                    removeResizeHandles();
                    selectedBlock = null;
                }
                
                // ÏÇ≠Ï†ú Ìè≠Î∞ú ÌååÌã∞ÌÅ¥ Ìö®Í≥º
                const deleteEmojis = ['üí•', 'üî•', 'üí®', 'üíÄ', '‚ö°', 'üå™Ô∏è', 'üí£', 'üöÄ'];
                createParticles(block.position.x, block.position.y, block.originalColor || block.render.fillStyle, 30);
                createEmojiParticles(block.position.x, block.position.y, deleteEmojis, 15);
                
                // Î∏îÎü≠ Ï†úÍ±∞
                World.remove(world, block);
                todos = todos.filter(todo => todo.id !== block.id);
                updateStats();
            }
        }
        
        // Ï∂©Îèå Ï≤òÎ¶¨
        function handleCollision(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;
                
                // ÌòÑÏû¨ Îñ®Ïñ¥ÏßÄÎäî Î∏îÎü≠Ïù¥ Îã§Î•∏ Î∏îÎü≠Ïù¥ÎÇò Î∞îÎã•Ïóê ÎãøÏúºÎ©¥ Ï°∞Ïûë Î∂àÍ∞Ä
                if ((bodyA === currentBlock || bodyB === currentBlock) && isBlockFalling) {
                    setTimeout(() => {
                        isBlockFalling = false;
                        currentBlock = null;
                    }, 100);
                }
            });
        }
        
        // ÌÇ§Î≥¥Îìú ÏûÖÎ†• Ï≤òÎ¶¨
        document.addEventListener('keydown', (e) => {
            if (!currentBlock || !isBlockFalling) return;
            
            const force = 0.01;
            const torque = 0.1;
            
            switch(e.key) {
                case 'ArrowLeft':
                    Body.applyForce(currentBlock, currentBlock.position, { x: -force, y: 0 });
                    break;
                case 'ArrowRight':
                    Body.applyForce(currentBlock, currentBlock.position, { x: force, y: 0 });
                    break;
                case 'ArrowDown':
                    Body.applyForce(currentBlock, currentBlock.position, { x: 0, y: force * 2 });
                    break;
                case ' ':
                    e.preventDefault();
                    Body.setAngularVelocity(currentBlock, torque);
                    break;

            }
        });
        
                 // ÎßàÏö∞Ïä§ ÏõÄÏßÅÏûÑ Í∞êÏßÄ (Ìò∏Î≤Ñ Ìö®Í≥º)
        document.getElementById('gameCanvas').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Ìò∏Î≤ÑÎêú Î∏îÎü≠ Ï∞æÍ∏∞
            let foundBlock = null;
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                if (x >= pos.x - blockWidth/2 && x <= pos.x + blockWidth/2 &&
                    y >= pos.y - blockHeight/2 && y <= pos.y + blockHeight/2) {
                    foundBlock = block;
                }
            });
            
                         if (foundBlock !== hoveredBlock) {
                hoveredBlock = foundBlock;
                updateButtonStates();
            }
        });
        
                 // ÎßàÏö∞Ïä§Í∞Ä Ï∫îÎ≤ÑÏä§Î•º Î≤óÏñ¥ÎÇ† Îïå Ìò∏Î≤Ñ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        document.getElementById('gameCanvas').addEventListener('mouseleave', () => {
            hoveredBlock = null;
            updateButtonStates();
        });
        
        // ÎßàÏö∞Ïä§ ÌÅ¥Î¶≠ÏúºÎ°ú Î∏îÎü≠ ÏÑ†ÌÉù
        document.getElementById('gameCanvas').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ÌÅ¥Î¶≠Îêú Î∏îÎü≠ Ï∞æÍ∏∞
            let clickedBlock = null;
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                if (x >= pos.x - blockWidth/2 && x <= pos.x + blockWidth/2 &&
                    y >= pos.y - blockHeight/2 && y <= pos.y + blockHeight/2) {
                    clickedBlock = block;
                }
            });
            
            // Ïù¥Ï†Ñ ÏÑ†ÌÉù Ìï¥Ï†ú
            if (selectedBlock) {
                selectedBlock.isSelected = false;
                selectedBlock.render.fillStyle = selectedBlock.originalColor;
                selectedBlock.render.strokeStyle = '#fff'; // ÏõêÎûò ÌÖåÎëêÎ¶¨Î°ú Î≥µÏõê
                selectedBlock.render.lineWidth = 3; // ÏõêÎûò ÎëêÍªòÎ°ú Î≥µÏõê
                removeResizeHandles(); // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ Ï†úÍ±∞
            }
            
            // ÏÉàÎ°úÏö¥ Î∏îÎü≠ ÏÑ†ÌÉù
            if (clickedBlock) {
                selectedBlock = clickedBlock;
                selectedBlock.isSelected = true;
                selectedBlock.render.strokeStyle = '#ff0000'; // Îπ®Í∞ÑÏÉâ ÌÖåÎëêÎ¶¨
                selectedBlock.render.lineWidth = 6; // ÍµµÏùÄ ÌÖåÎëêÎ¶¨
                createResizeHandles(selectedBlock); // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ ÏÉùÏÑ±
            } else {
                selectedBlock = null;
                removeResizeHandles(); // ÏÑ†ÌÉù Ìï¥Ï†ú Ïãú Ìï∏Îì§ Ï†úÍ±∞
            }
            
            updateButtonStates();
        });
        
        
        
        // Ìï†Ïùº Ï∂îÍ∞Ä
        function addTodo() {
            const input = document.getElementById('todoInput');
            const text = input.value.trim();
            
            if (text && !isBlockFalling) {
                createTodoBlock(text);
                input.value = '';
                totalCount++;
                updateStats();
            }
        }
        
        // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
        function updateStats() {
            document.getElementById('totalTodos').textContent = totalCount;
            document.getElementById('completedTodos').textContent = completedCount;
            document.getElementById('activeTodos').textContent = todos.filter(t => !t.isCompleted).length;
        }
        
                 // Î∏îÎü≠ ÌÖçÏä§Ìä∏ Î†åÎçîÎßÅ
        function renderBlockText() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            todos.forEach(block => {
                if (block.render.visible !== false) {
                    const pos = block.position;
                    const angle = block.angle;
                    
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(angle);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ÏôÑÎ£åÎêú Î∏îÎü≠ÏùÄ Ï∑®ÏÜåÏÑ† Ï∂îÍ∞Ä
                    if (block.isCompleted) {
                        ctx.fillStyle = '#333333'; // ÏôÑÎ£åÎêú Î∏îÎü≠ÏùÄ Ïñ¥ÎëêÏö¥ Í∏ÄÏûê
                    }
                    
                    // Î©ÄÌã∞ÎùºÏù∏ ÌÖçÏä§Ìä∏ Î†åÎçîÎßÅ
                    if (block.textLines && block.textLines.length > 1) {
                        const totalHeight = (block.textLines.length - 1) * LINE_HEIGHT;
                        const startY = -totalHeight / 2;
                        
                        block.textLines.forEach((line, index) => {
                            const y = startY + (index * LINE_HEIGHT);
                            ctx.fillText(line, 0, y);
                            
                            // ÏôÑÎ£åÎêú Î∏îÎü≠ÏùÄ Ï∑®ÏÜåÏÑ† Í∑∏Î¶¨Í∏∞
                            if (block.isCompleted) {
                                ctx.strokeStyle = '#333333';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(-ctx.measureText(line).width / 2, y);
                                ctx.lineTo(ctx.measureText(line).width / 2, y);
                                ctx.stroke();
                            }
                        });
                    } else {
                        ctx.fillText(block.todoText, 0, 0);
                        
                        // ÏôÑÎ£åÎêú Î∏îÎü≠ÏùÄ Ï∑®ÏÜåÏÑ† Í∑∏Î¶¨Í∏∞
                        if (block.isCompleted) {
                            ctx.strokeStyle = '#333333';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-ctx.measureText(block.todoText).width / 2, 0);
                            ctx.lineTo(ctx.measureText(block.todoText).width / 2, 0);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
            });
        }
        
                 // Î†åÎçîÎßÅ Î£®ÌîÑ
        function gameLoop() {
            updateParticles();
            checkAndFixBlockBounds(); // Îß§ ÌîÑÎ†àÏûÑÎßàÎã§ Î∏îÎü≠ Í≤ΩÍ≥Ñ Ï≤¥ÌÅ¨
            updateResizeHandles(); // Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏
            renderBlockText();
            renderParticles();
            requestAnimationFrame(gameLoop);
        }
        
                 // Î≤ÑÌäº ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        function updateButtonStates() {
            const completeBtn = document.getElementById('completeBtn');
            const deleteBtn = document.getElementById('deleteBtn');
            
            if (selectedBlock) {
                completeBtn.disabled = false;
                deleteBtn.disabled = false;
            } else {
                completeBtn.disabled = true;
                deleteBtn.disabled = true;
            }
            
            // Î≤ÑÌäº ÌÖçÏä§Ìä∏Îäî Ìï≠ÏÉÅ Í≥†Ï†ï
            completeBtn.textContent = '‚úÖ ÏôÑÎ£å';
            deleteBtn.textContent = 'üóëÔ∏è ÏÇ≠Ï†ú';
        }
        
        // Î≤ÑÌäº ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
        function completeSelectedBlock() {
            if (selectedBlock) {
                completeBlock(selectedBlock);
                selectedBlock = null;
                updateButtonStates();
            }
        }
        
        function deleteSelectedBlock() {
            if (selectedBlock) {
                deleteBlock(selectedBlock);
                selectedBlock = null;
                updateButtonStates();
            }
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.getElementById('addBtn').addEventListener('click', addTodo);
        document.getElementById('completeBtn').addEventListener('click', completeSelectedBlock);
        document.getElementById('deleteBtn').addEventListener('click', deleteSelectedBlock);
        document.getElementById('todoInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') addTodo();
        });
        
        // Î∏åÎùºÏö∞Ï†Ä ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Í∞êÏßÄ
        function handleResize() {
            updateCanvasSize();
            createWalls();
            // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú Î¶¨ÏÇ¨Ïù¥Ï¶à Ìï∏Îì§ ÏúÑÏπòÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            if (selectedBlock) {
                createResizeHandles(selectedBlock);
            }
        }
        
        // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
        window.addEventListener('resize', handleResize);
        window.addEventListener('load', handleResize);
        
        // Í≤åÏûÑ ÏãúÏûë
        initGame();
        gameLoop();
        updateStats();
        updateButtonStates();
    </script>
</body>
</html>
