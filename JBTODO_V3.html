<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë¬¼ë¦¬ì—”ì§„ TODO ê´€ë¦¬ì</title>
    <script src="matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .input-section {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            text-align: center;
            background: rgba(0,0,0,0.3);
            padding: 15px 20px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        #todoInput {
            padding: 15px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            width: 400px;
            margin-right: 10px;
            outline: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        #addBtn, .control-btn {
            padding: 15px 30px;
            font-size: 16px;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 0 5px;
        }
        
        #addBtn {
            background: #ff6b6b;
        }
        
        #addBtn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }
        
        .control-btn.complete-btn {
            background: #51cf66;
        }
        
        .control-btn.complete-btn:hover {
            background: #40c057;
            transform: translateY(-2px);
        }
        
        .control-btn.delete-btn {
            background: #ff6b6b;
        }
        
        .control-btn.delete-btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
        }
        
        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .control-btn.save-btn {
            background: #4ecdc4;
        }
        
        .control-btn.save-btn:hover {
            background: #26a69a;
            transform: translateY(-2px);
        }
        
        .control-btn.load-btn {
            background: #54a0ff;
        }
        
        .control-btn.load-btn:hover {
            background: #2f80ed;
            transform: translateY(-2px);
        }
        
        .control-btn.export-btn {
            background: #ffd93d;
            color: #333;
        }
        
        .control-btn.export-btn:hover {
            background: #ffcd02;
            transform: translateY(-2px);
        }
        
        .control-btn.import-btn {
            background: #a55eea;
        }
        
        .control-btn.import-btn:hover {
            background: #8b5ded;
            transform: translateY(-2px);
        }
        
        /* ì•„ì´ì½˜ë§Œ ìˆëŠ” ë²„íŠ¼ë“¤ì˜ íŠ¹ë³„í•œ ìŠ¤íƒ€ì¼ */
        .control-btn.delete-btn,
        .control-btn.save-btn,
        .control-btn.load-btn,
        .control-btn.export-btn,
        .control-btn.import-btn {
            padding: 15px 15px;
            min-width: 50px;
            font-size: 18px;
        }
        
        .game-area {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: rgba(255,255,255,0.1);
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .control-info {
            margin: 10px 0;
            font-size: 18px;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }
        
        .stat-item {
            text-align: center;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .falling-block {
            position: absolute;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .falling-block:hover {
            transform: scale(1.05);
        }
        
        .falling-block.completed {
            background: linear-gradient(45deg, #51cf66, #69db7c);
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .block-actions {
            position: absolute;
            display: none;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 8px;
            gap: 8px;
            z-index: 9999;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        
        .block-actions.show {
            display: flex;
        }
        
        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            min-width: 60px;
            text-align: center;
            z-index: 10000;
            position: relative;
        }
        
        .complete-btn {
            background: #51cf66;
        }
        
        .complete-btn:hover {
            background: #40c057;
            transform: scale(1.05);
        }
        
        .delete-btn {
            background: #ff6b6b;
        }
        
        .delete-btn:hover {
            background: #ff5252;
            transform: scale(1.05);
        }
        
        /* ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìŠ¤íƒ€ì¼ ì¶”ê°€ */
        .resize-handle {
            position: absolute;
            background: #ff0000;
            border: 2px solid #fff;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            z-index: 10001;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .resize-handle:hover {
            background: #ff3333;
            transform: scale(1.2);
            box-shadow: 0 3px 12px rgba(0,0,0,0.5);
        }
        
        .resize-handle.nw-resize { cursor: nw-resize; }
        .resize-handle.n-resize { cursor: n-resize; }
        .resize-handle.ne-resize { cursor: ne-resize; }
        .resize-handle.e-resize { cursor: e-resize; }
        .resize-handle.se-resize { cursor: se-resize; }
        .resize-handle.s-resize { cursor: s-resize; }
        .resize-handle.sw-resize { cursor: sw-resize; }
        .resize-handle.w-resize { cursor: w-resize; }
        
        /* ë¸”ëŸ­ ìœ„ ì•¡ì…˜ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .block-action-btn {
            position: absolute;
            padding: 8px 12px;
            border: none;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            color: white;
            z-index: 10002;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(5px);
        }
        
        .complete-action-btn {
            background: #51cf66;
        }
        
        .complete-action-btn:hover {
            background: #40c057;
            transform: scale(1.1);
        }
        
        .delete-action-btn {
            background: #ff6b6b;
        }
        
        .delete-action-btn:hover {
            background: #ff5252;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="input-section">
            <input type="text" id="todoInput" placeholder="í• ì¼ì„ ì…ë ¥í•˜ì„¸ìš”... (ìµœëŒ€ 100ì)" maxlength="100">
            <button id="addBtn">ì¶”ê°€</button>
            <button id="completeBtn" class="control-btn complete-btn">ì™„ë£Œ</button>
            <button id="deleteBtn" class="control-btn delete-btn">ğŸ—‘ï¸</button>
            <button id="saveBtn" class="control-btn save-btn">ğŸ’¾</button>
            <button id="loadBtn" class="control-btn load-btn">ğŸ“‚</button>
            <button id="exportBtn" class="control-btn export-btn">ğŸ“¤</button>
            <button id="importBtn" class="control-btn import-btn">ğŸ“¥</button>
            <input type="file" id="fileInput" accept=".json" style="display: none;">
        </div>
        
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
        </div>
        

    </div>

    <script>
        // Matter.js ëª¨ë“ˆ
        const { Engine, Render, Bodies, World, Mouse, MouseConstraint, Body, Events } = Matter;
        
        // ê²Œì„ ìƒíƒœ
        let engine, render, world;
        let currentBlock = null;
        let isBlockFalling = false;
        let todos = [];
        let totalCount = 0;
        let completedCount = 0;
        let hoveredBlock = null;
        let selectedBlock = null;
        let particles = [];
        let walls = []; // ë²½ë“¤ì„ ì¶”ì í•˜ê¸° ìœ„í•œ ë°°ì—´
        let resizeHandles = []; // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ë“¤
        let isResizing = false; // ë¦¬ì‚¬ì´ì¦ˆ ì¤‘ì¸ì§€ ì—¬ë¶€
        let resizeData = null; // ë¦¬ì‚¬ì´ì¦ˆ ë°ì´í„°
        let blockButtons = []; // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ë“¤
        
                 // ê²Œì„ ì„¤ì • (ë™ì  í¬ê¸°)
        let CANVAS_WIDTH = 800;
        let CANVAS_HEIGHT = 600;
        const MIN_BLOCK_WIDTH = 80;
        const MIN_BLOCK_HEIGHT = 40;
        const LINE_HEIGHT = 24;
        
                 // ìº”ë²„ìŠ¤ í¬ê¸° ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì „ì²´ í™”ë©´)
        function updateCanvasSize() {
            CANVAS_WIDTH = window.innerWidth;
            CANVAS_HEIGHT = window.innerHeight;
            
            const canvas = document.getElementById('gameCanvas');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            if (render) {
                render.canvas.width = CANVAS_WIDTH;
                render.canvas.height = CANVAS_HEIGHT;
                render.options.width = CANVAS_WIDTH;
                render.options.height = CANVAS_HEIGHT;
                render.canvas.style.width = CANVAS_WIDTH + 'px';
                render.canvas.style.height = CANVAS_HEIGHT + 'px';
            }
        }
        
        // ë²½ ìƒì„± í•¨ìˆ˜
        function createWalls() {
            // ê¸°ì¡´ ë²½ë“¤ ì œê±°
            if (walls.length > 0) {
                World.remove(world, walls);
                walls = [];
            }
            
            const wallThickness = 20;
            walls = [
                // ë°”ë‹¥ ë²½ (í™”ë©´ ì•„ë˜)
                Bodies.rectangle(CANVAS_WIDTH/2, CANVAS_HEIGHT + wallThickness/2, CANVAS_WIDTH + wallThickness*2, wallThickness, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // ì™¼ìª½ ë²½ (í™”ë©´ ì™¼ìª½ ê²½ê³„ì— ë§ì¶¤)
                Bodies.rectangle(-wallThickness/2, CANVAS_HEIGHT/2, wallThickness, CANVAS_HEIGHT + wallThickness*2, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // ì˜¤ë¥¸ìª½ ë²½ (ë™ì  ë„ˆë¹„ì— ë§ì¶¤)
                Bodies.rectangle(CANVAS_WIDTH - wallThickness/2, CANVAS_HEIGHT/2, wallThickness, CANVAS_HEIGHT + wallThickness*2, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                }),
                // ìœ„ìª½ ë²½ (í™”ë©´ ìœ„ìª½ ê²½ê³„ì— ë§ì¶¤)
                Bodies.rectangle(CANVAS_WIDTH/2, -wallThickness/2, CANVAS_WIDTH + wallThickness*2, wallThickness, { 
                    isStatic: true, 
                    render: { fillStyle: '#fff' } 
                })
            ];
            
            World.add(world, walls);
        }

        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            // ìº”ë²„ìŠ¤ í¬ê¸° ë¨¼ì € ì„¤ì •
            updateCanvasSize();
            
            // ì—”ì§„ ìƒì„±
            engine = Engine.create();
            world = engine.world;
            engine.world.gravity.y = 0.4;
            
            // ë Œë”ëŸ¬ ìƒì„±
            render = Render.create({
                canvas: document.getElementById('gameCanvas'),
                engine: engine,
                options: {
                    width: CANVAS_WIDTH,
                    height: CANVAS_HEIGHT,
                    wireframes: false,
                    background: 'transparent',
                    showVelocity: false,
                    showAngleIndicator: false,
                    showDebug: false
                }
            });
            
            // ë²½ ìƒì„±
            createWalls();
            
            // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ì œì–´ ì¶”ê°€ (ê²½ê³„ ì œí•œ)
            const mouse = Mouse.create(render.canvas);
            const mouseConstraint = MouseConstraint.create(engine, {
                mouse: mouse,
                constraint: {
                    stiffness: 0.6, // ì•½ê°„ ë¶€ë“œëŸ½ê²Œ ì¡°ì •
                    render: { visible: false },
                    length: 0, // ë§ˆìš°ìŠ¤ì™€ ë¸”ëŸ­ ì‚¬ì´ ê±°ë¦¬ ì œí•œ
                    damping: 0.9 // ê°ì‡  ì¶”ê°€ë¡œ ì•ˆì •ì„± í–¥ìƒ
                }
            });
            World.add(world, mouseConstraint);
            
            // ë Œë”ë§ ì‹œì‘
            Render.run(render);
            Engine.run(engine);
            
            // ì¶©ëŒ ê°ì§€
            Events.on(engine, 'collisionStart', handleCollision);
        }
        
                 // í…ìŠ¤íŠ¸ë¥¼ ì¤„ë°”ê¿ˆí•˜ëŠ” í•¨ìˆ˜ (20ìë¦¬ ê¸°ì¤€)
        function wrapText(text, maxCharsPerLine = 20) {
            const lines = [];
            for (let i = 0; i < text.length; i += maxCharsPerLine) {
                lines.push(text.substring(i, i + maxCharsPerLine));
            }
            return lines;
        }
        
        // ë¸”ëŸ­ í¬ê¸° ê³„ì‚° í•¨ìˆ˜ (ì»´íŒ©íŠ¸í•œ ì‚¬ì´ì¦ˆ)
        function calculateBlockSize(text) {
            const lines = wrapText(text);
            
            // ì‹¤ì œ í…ìŠ¤íŠ¸ ê¸¸ì´ë¥¼ ë” ì •í™•í•˜ê²Œ ì¸¡ì •
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = 'bold 16px Arial';
            
            // ê°€ì¥ ê¸´ ì¤„ì˜ ì‹¤ì œ í”½ì…€ ë„ˆë¹„ ê³„ì‚°
            let maxTextWidth = 0;
            lines.forEach(line => {
                const textWidth = ctx.measureText(line).width;
                maxTextWidth = Math.max(maxTextWidth, textWidth);
            });
            
            // ì»´íŒ©íŠ¸í•œ ì‚¬ì´ì¦ˆ ê³„ì‚° (í…ìŠ¤íŠ¸ ë„ˆë¹„ + ìµœì†Œ íŒ¨ë”©)
            const width = Math.max(MIN_BLOCK_WIDTH, maxTextWidth + 20); // íŒ¨ë”© 20pxë¡œ ì¤„ì„
            const height = Math.max(MIN_BLOCK_HEIGHT, lines.length * LINE_HEIGHT + 15); // ìƒí•˜ íŒ¨ë”© 15pxë¡œ ì¤„ì„
            
            return { width, height, lines };
        }
        
                 // ìƒˆ ë¸”ëŸ­ ìƒì„±
        function createTodoBlock(text) {
            // ì˜ˆìœ ì´ëª¨í‹°ì½˜ ë°°ì—´
            const prettyEmojis = [
                'ğŸŒŸ', 'âœ¨', 'ğŸ’«', 'ğŸ¯', 'ğŸ¨', 'ğŸš€', 'ğŸ’¡', 'ğŸ”¥', 
                'ğŸ“', 'ğŸ’', 'ğŸŒˆ', 'ğŸª', 'ğŸŒº', 'ğŸŒ¸', 'ğŸŠ', 'ğŸ‰',
                'â­', 'ğŸŒ¼', 'ğŸ¦‹', 'ğŸ€', 'ğŸ’', 'ğŸ­', 'ğŸ¼', 'ğŸ²',
                'ğŸŒŸ', 'ğŸ’«', 'ğŸ¨', 'ğŸŒˆ', 'âœ¨', 'ğŸ”®', 'ğŸª', 'ğŸ¯'
            ];
            
            // ëœë¤ ì´ëª¨í‹°ì½˜ ì„ íƒí•˜ì—¬ í…ìŠ¤íŠ¸ ì•ì— ì¶”ê°€
            const randomEmoji = prettyEmojis[Math.floor(Math.random() * prettyEmojis.length)];
            const decoratedText = randomEmoji + ' ' + text;
            
            // ëœë¤í•œ x ìœ„ì¹˜ (ë¸”ëŸ­ í¬ê¸°ë¥¼ ê³ ë ¤í•œ ì•ˆì „ ë²”ìœ„)
            const margin = 100; // ë²½ì—ì„œ ë–¨ì–´ì§„ ê±°ë¦¬
            const x = margin + Math.random() * (CANVAS_WIDTH - margin * 2);
            const y = 30; // ìœ„ìª½ ë²½(y=-12.5) ë°”ë¡œ ì•„ë˜ì—ì„œ ìƒì„±
            
            // ë¸”ëŸ­ í¬ê¸° ê³„ì‚° (ì´ëª¨í‹°ì½˜ì´ í¬í•¨ëœ í…ìŠ¤íŠ¸ë¡œ)
            const { width, height, lines } = calculateBlockSize(decoratedText);
            
            // ìƒ‰ìƒ ëœë¤ ìƒì„±
            const colors = [
                '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', 
                '#ffd93d', '#ff9ff3', '#54a0ff', '#5f27cd'
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const block = Bodies.rectangle(x, y, width, height, {
                render: {
                    fillStyle: color,
                    strokeStyle: '#fff',
                    lineWidth: 3
                },
                chamfer: { radius: 15 }, // ë‘¥ê·¼ ëª¨ì„œë¦¬
                density: 0.002, // 2ë°° ë¬´ê²Œê° (ê¸°ë³¸ê°’ 0.001ì˜ 2ë°°)
                frictionAir: 0.005, // ê³µê¸° ì €í•­ ê°ì†Œë¡œ ë” ë¬´ê²ê²Œ
                restitution: 0.2, // íƒ„ì„± ê°ì†Œë¡œ ë” ë¬µì§í•˜ê²Œ
                friction: 0.9 // ë§ˆì°° ì¦ê°€ë¡œ ë” ì•ˆì •ì ìœ¼ë¡œ
            });
            
            // ë¸”ëŸ­ì— í…ìŠ¤íŠ¸ ì •ë³´ ì €ì¥
            block.todoText = decoratedText;
            block.textLines = lines;
            block.blockWidth = width;
            block.blockHeight = height;
            block.isCompleted = false;
            block.isSelected = false;
            block.originalColor = color;
            block.id = Date.now() + Math.random();
            
            World.add(world, block);
            todos.push(block);
            currentBlock = block;
            isBlockFalling = true;
            
            updateStats();
            autoSave(); // ìë™ ì €ì¥
            return block;
        }
        
                 // ë¸”ëŸ­ ì™„ë£Œ ì²˜ë¦¬ (íšŒìƒ‰ + ì·¨ì†Œì„ , ì‚­ì œí•˜ì§€ ì•ŠìŒ)
        function completeBlock(block) {
            if (block && !block.isCompleted) {
                block.isCompleted = true;
                block.render.fillStyle = '#888888'; // íšŒìƒ‰ìœ¼ë¡œ ë³€ê²½
                block.originalColor = '#888888';
                completedCount++;
                
                // ì™„ë£Œ ì¶•í•˜ íŒŒí‹°í´ íš¨ê³¼ (2ë°° + ì´ëª¨í‹°ì½˜)
                const completeEmojis = ['âœ¨', 'ğŸ‰', 'âœ…', 'ğŸ‘', 'ğŸŠ', 'ğŸŒŸ', 'ğŸ’«', 'ğŸˆ'];
                createParticles(block.position.x, block.position.y, '#51cf66', 40); // 2ë°° íŒŒí‹°í´
                createEmojiParticles(block.position.x, block.position.y, completeEmojis, 20); // ì´ëª¨í‹°ì½˜ íŒŒí‹°í´
                
                updateStats();
                autoSave(); // ìë™ ì €ì¥
            }
        }
        
                 // íŒŒí‹°í´ ì‹œìŠ¤í…œ (3ë°° í™•ì¥ëœ í­ë°œ ë²”ìœ„)
        function createParticles(x, y, color, count = 20) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 30, // 3ë°° í™•ì¥
                    vy: (Math.random() - 0.5) * 30 - 15, // 3ë°° í™•ì¥
                    size: Math.random() * 5 + 2,
                    color: color,
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.01,
                    type: 'circle'
                });
            }
        }
        
        // ì´ëª¨í‹°ì½˜ íŒŒí‹°í´ ìƒì„± (3ë°° í™•ì¥ëœ í­ë°œ ë²”ìœ„)
        function createEmojiParticles(x, y, emojis, count = 15) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 24, // 3ë°° í™•ì¥
                    vy: (Math.random() - 0.5) * 24 - 9, // 3ë°° í™•ì¥
                    size: Math.random() * 10 + 15,
                    emoji: emojis[Math.floor(Math.random() * emojis.length)],
                    life: 1.0,
                    decay: Math.random() * 0.015 + 0.008,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.2,
                    type: 'emoji'
                });
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.3; // ì¤‘ë ¥
                p.vx *= 0.98; // ê³µê¸° ì €í•­
                p.life -= p.decay;
                
                // ì´ëª¨í‹°ì½˜ íŒŒí‹°í´ íšŒì „
                if (p.type === 'emoji') {
                    p.rotation += p.rotationSpeed;
                }
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìƒì„± í•¨ìˆ˜ (íšŒì „ ê³ ë ¤)
        function createResizeHandles(block) {
            removeResizeHandles(); // ê¸°ì¡´ í•¸ë“¤ ì œê±°
            
            if (!block || !block.isSelected) return;
            
            const pos = block.position;
            const width = block.blockWidth || MIN_BLOCK_WIDTH;
            const height = block.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = block.angle; // ë¸”ëŸ­ì˜ íšŒì „ ê°ë„
            
            // ë¸”ëŸ­ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ ìƒëŒ€ ìœ„ì¹˜ë“¤ (íšŒì „ ì „)
            const relativePositions = [
                { type: 'nw', x: -width/2, y: -height/2 },
                { type: 'n', x: 0, y: -height/2 },
                { type: 'ne', x: width/2, y: -height/2 },
                { type: 'e', x: width/2, y: 0 },
                { type: 'se', x: width/2, y: height/2 },
                { type: 's', x: 0, y: height/2 },
                { type: 'sw', x: -width/2, y: height/2 },
                { type: 'w', x: -width/2, y: 0 }
            ];
            
            // íšŒì „ ë³€í™˜ì„ ì ìš©í•œ ì ˆëŒ€ ìœ„ì¹˜ë“¤
            const rotatedHandles = relativePositions.map(relPos => {
                const rotatedX = relPos.x * Math.cos(angle) - relPos.y * Math.sin(angle);
                const rotatedY = relPos.x * Math.sin(angle) + relPos.y * Math.cos(angle);
                
                return {
                    type: relPos.type,
                    x: pos.x + rotatedX,
                    y: pos.y + rotatedY
                };
            });
            
            rotatedHandles.forEach(handle => {
                const handleElement = document.createElement('div');
                handleElement.className = `resize-handle ${handle.type}-resize`;
                handleElement.style.left = (handle.x - 6) + 'px';
                handleElement.style.top = (handle.y - 6) + 'px';
                handleElement.dataset.type = handle.type;
                
                // í•¸ë“¤ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                handleElement.addEventListener('mousedown', startResize);
                
                document.body.appendChild(handleElement);
                resizeHandles.push(handleElement);
            });
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ì œê±°
        function removeResizeHandles() {
            resizeHandles.forEach(handle => {
                if (handle.parentNode) {
                    handle.parentNode.removeChild(handle);
                }
            });
            resizeHandles = [];
        }
        
        // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ìƒì„±
        function createBlockButtons(block) {
            removeBlockButtons(); // ê¸°ì¡´ ë²„íŠ¼ ì œê±°
            
            if (!block || !block.isSelected) return;
            
            const pos = block.position;
            const width = block.blockWidth || MIN_BLOCK_WIDTH;
            const height = block.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = block.angle;
            
            // ë¸”ëŸ­ ìœ„ìª½ ì¤‘ì•™ ìœ„ì¹˜ ê³„ì‚° (íšŒì „ ê³ ë ¤)
            const localY = -height/2 - 40; // ë¸”ëŸ­ ìœ„ìª½ 40px ìœ„
            const rotatedX = 0 * Math.cos(angle) - localY * Math.sin(angle);
            const rotatedY = 0 * Math.sin(angle) + localY * Math.cos(angle);
            
            const buttonContainerX = pos.x + rotatedX;
            const buttonContainerY = pos.y + rotatedY;
            
            // ì™„ë£Œ ë²„íŠ¼ ìƒì„±
            const completeButton = document.createElement('button');
            completeButton.className = 'block-action-btn complete-action-btn';
            completeButton.textContent = 'ì™„ë£Œ';
            completeButton.style.left = (buttonContainerX - 40) + 'px';
            completeButton.style.top = (buttonContainerY - 15) + 'px';
            completeButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                completeBlock(block);
                removeBlockButtons();
                selectedBlock = null;
                updateButtonStates();
            });
            
            // ì‚­ì œ ë²„íŠ¼ ìƒì„±
            const deleteButton = document.createElement('button');
            deleteButton.className = 'block-action-btn delete-action-btn';
            deleteButton.textContent = 'ğŸ—‘ï¸';
            deleteButton.style.left = (buttonContainerX + 10) + 'px';
            deleteButton.style.top = (buttonContainerY - 15) + 'px';
            deleteButton.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                deleteBlock(block);
                removeBlockButtons();
                selectedBlock = null;
                updateButtonStates();
            });
            
            document.body.appendChild(completeButton);
            document.body.appendChild(deleteButton);
            blockButtons.push(completeButton, deleteButton);
        }
        
        // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ì œê±°
        function removeBlockButtons() {
            blockButtons.forEach(button => {
                if (button.parentNode) {
                    button.parentNode.removeChild(button);
                }
            });
            blockButtons = [];
        }
        
        // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function updateBlockButtons() {
            if (!selectedBlock || blockButtons.length === 0) return;
            
            const pos = selectedBlock.position;
            const width = selectedBlock.blockWidth || MIN_BLOCK_WIDTH;
            const height = selectedBlock.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = selectedBlock.angle;
            
            // ë¸”ëŸ­ ìœ„ìª½ ì¤‘ì•™ ìœ„ì¹˜ ê³„ì‚° (íšŒì „ ê³ ë ¤)
            const localY = -height/2 - 40; // ë¸”ëŸ­ ìœ„ìª½ 40px ìœ„
            const rotatedX = 0 * Math.cos(angle) - localY * Math.sin(angle);
            const rotatedY = 0 * Math.sin(angle) + localY * Math.cos(angle);
            
            const buttonContainerX = pos.x + rotatedX;
            const buttonContainerY = pos.y + rotatedY;
            
            // ì™„ë£Œ ë²„íŠ¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            if (blockButtons[0]) {
                blockButtons[0].style.left = (buttonContainerX - 40) + 'px';
                blockButtons[0].style.top = (buttonContainerY - 15) + 'px';
            }
            
            // ì‚­ì œ ë²„íŠ¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            if (blockButtons[1]) {
                blockButtons[1].style.left = (buttonContainerX + 10) + 'px';
                blockButtons[1].style.top = (buttonContainerY - 15) + 'px';
            }
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (íšŒì „ ê³ ë ¤)
        function updateResizeHandles() {
            if (!selectedBlock || resizeHandles.length === 0) return;
            
            const pos = selectedBlock.position;
            const width = selectedBlock.blockWidth || MIN_BLOCK_WIDTH;
            const height = selectedBlock.blockHeight || MIN_BLOCK_HEIGHT;
            const angle = selectedBlock.angle; // ë¸”ëŸ­ì˜ íšŒì „ ê°ë„
            
            // ë¸”ëŸ­ ì¤‘ì‹¬ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ ìƒëŒ€ ìœ„ì¹˜ë“¤ (íšŒì „ ì „)
            const relativePositions = [
                { x: -width/2, y: -height/2 }, // nw
                { x: 0, y: -height/2 },         // n
                { x: width/2, y: -height/2 },   // ne
                { x: width/2, y: 0 },           // e
                { x: width/2, y: height/2 },    // se
                { x: 0, y: height/2 },          // s
                { x: -width/2, y: height/2 },   // sw
                { x: -width/2, y: 0 }           // w
            ];
            
            // íšŒì „ ë³€í™˜ì„ ì ìš©í•œ ì ˆëŒ€ ìœ„ì¹˜ë“¤
            const rotatedPositions = relativePositions.map(relPos => {
                const rotatedX = relPos.x * Math.cos(angle) - relPos.y * Math.sin(angle);
                const rotatedY = relPos.x * Math.sin(angle) + relPos.y * Math.cos(angle);
                
                return {
                    x: pos.x + rotatedX,
                    y: pos.y + rotatedY
                };
            });
            
            resizeHandles.forEach((handle, index) => {
                if (rotatedPositions[index]) {
                    handle.style.left = (rotatedPositions[index].x - 6) + 'px';
                    handle.style.top = (rotatedPositions[index].y - 6) + 'px';
                }
            });
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ ì‹œì‘
        function startResize(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!selectedBlock) return;
            
            isResizing = true;
            const handleType = e.target.dataset.type;
            
            resizeData = {
                block: selectedBlock,
                handleType: handleType,
                startX: e.clientX,
                startY: e.clientY,
                startWidth: selectedBlock.blockWidth || MIN_BLOCK_WIDTH,
                startHeight: selectedBlock.blockHeight || MIN_BLOCK_HEIGHT,
                startPosX: selectedBlock.position.x,
                startPosY: selectedBlock.position.y,
                startAngle: selectedBlock.angle
            };
            
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', endResize);
            
            // ë¬¼ë¦¬ì—”ì§„ ì¼ì‹œ ì •ì§€ (ë¦¬ì‚¬ì´ì¦ˆ ì¤‘ ì•ˆì •ì„±ì„ ìœ„í•´)
            Body.setStatic(selectedBlock, true);
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ ì‹¤í–‰ (íšŒì „ ê³ ë ¤)
        function doResize(e) {
            if (!isResizing || !resizeData) return;
            
            const deltaX = e.clientX - resizeData.startX;
            const deltaY = e.clientY - resizeData.startY;
            const angle = resizeData.block.angle;
            
            // ë§ˆìš°ìŠ¤ ì´ë™ëŸ‰ì„ ë¸”ëŸ­ì˜ ë¡œì»¬ ì¢Œí‘œê³„ë¡œ ë³€í™˜
            const localDeltaX = deltaX * Math.cos(-angle) - deltaY * Math.sin(-angle);
            const localDeltaY = deltaX * Math.sin(-angle) + deltaY * Math.cos(-angle);
            
            let newWidth = resizeData.startWidth;
            let newHeight = resizeData.startHeight;
            let localPosOffsetX = 0;
            let localPosOffsetY = 0;
            
            // í•¸ë“¤ íƒ€ì…ì— ë”°ë¥¸ í¬ê¸° ì¡°ì • (ë¡œì»¬ ì¢Œí‘œê³„ ê¸°ì¤€)
            switch (resizeData.handleType) {
                case 'nw':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'n':
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'ne':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight - localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'e':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    localPosOffsetX = localDeltaX / 2;
                    break;
                case 'se':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth + localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 's':
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'sw':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    newHeight = Math.max(MIN_BLOCK_HEIGHT, resizeData.startHeight + localDeltaY);
                    localPosOffsetX = localDeltaX / 2;
                    localPosOffsetY = localDeltaY / 2;
                    break;
                case 'w':
                    newWidth = Math.max(MIN_BLOCK_WIDTH, resizeData.startWidth - localDeltaX);
                    localPosOffsetX = localDeltaX / 2;
                    break;
            }
            
            // ë¡œì»¬ ì¢Œí‘œê³„ì˜ ìœ„ì¹˜ ì˜¤í”„ì…‹ì„ ê¸€ë¡œë²Œ ì¢Œí‘œê³„ë¡œ ë³€í™˜
            const globalPosOffsetX = localPosOffsetX * Math.cos(angle) - localPosOffsetY * Math.sin(angle);
            const globalPosOffsetY = localPosOffsetX * Math.sin(angle) + localPosOffsetY * Math.cos(angle);
            
            const newPosX = resizeData.startPosX + globalPosOffsetX;
            const newPosY = resizeData.startPosY + globalPosOffsetY;
            
            // ë¸”ëŸ­ í¬ê¸°ì™€ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            Body.scale(resizeData.block, newWidth / resizeData.block.blockWidth, newHeight / resizeData.block.blockHeight);
            Body.setPosition(resizeData.block, { x: newPosX, y: newPosY });
            
            // ë¸”ëŸ­ ì†ì„± ì—…ë°ì´íŠ¸
            resizeData.block.blockWidth = newWidth;
            resizeData.block.blockHeight = newHeight;
            
            // í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateResizeHandles();
        }
        
        // ë¦¬ì‚¬ì´ì¦ˆ ì¢…ë£Œ
        function endResize() {
            if (isResizing && resizeData) {
                // ë¬¼ë¦¬ì—”ì§„ ì¬ê°œ
                Body.setStatic(resizeData.block, false);
                
                isResizing = false;
                resizeData = null;
                
                document.removeEventListener('mousemove', doResize);
                document.removeEventListener('mouseup', endResize);
            }
        }
        
        // ë¸”ëŸ­ ê²½ê³„ ì²´í¬ ë° ë³µêµ¬ í•¨ìˆ˜
        function checkAndFixBlockBounds() {
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                let needsRepositioning = false;
                let newX = pos.x;
                let newY = pos.y;
                
                // ì¢Œìš° ê²½ê³„ ì²´í¬ (ë²½ ë‘ê»˜ ê³ ë ¤)
                const wallThickness = 20;
                if (pos.x - blockWidth/2 < wallThickness) {
                    newX = blockWidth/2 + wallThickness + 5;
                    needsRepositioning = true;
                } else if (pos.x + blockWidth/2 > CANVAS_WIDTH - wallThickness) {
                    newX = CANVAS_WIDTH - wallThickness - blockWidth/2 - 5;
                    needsRepositioning = true;
                }
                
                // ìƒí•˜ ê²½ê³„ ì²´í¬ (ìœ„ìª½ë§Œ, ì•„ë˜ìª½ì€ ë°”ë‹¥ ë²½ì´ ì²˜ë¦¬)
                if (pos.y - blockHeight/2 < wallThickness) {
                    newY = blockHeight/2 + wallThickness + 5;
                    needsRepositioning = true;
                }
                
                // ë¸”ëŸ­ì´ í™”ë©´ ì•„ë˜ë¡œ ë„ˆë¬´ ë§ì´ ë‚˜ê°”ì„ ë•Œë„ ì²´í¬
                if (pos.y > CANVAS_HEIGHT + 100) {
                    newY = CANVAS_HEIGHT - blockHeight/2 - 5;
                    needsRepositioning = true;
                }
                
                // ìœ„ì¹˜ ì¡°ì •ì´ í•„ìš”í•œ ê²½ìš°
                if (needsRepositioning) {
                    Body.setPosition(block, { x: newX, y: newY });
                    // ì†ë„ë„ ì´ˆê¸°í™”í•´ì„œ ì•ˆì •í™”
                    Body.setVelocity(block, { x: 0, y: 0 });
                    Body.setAngularVelocity(block, 0);
                }
            });
        }
        
        function renderParticles() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                
                if (p.type === 'emoji') {
                    // ì´ëª¨í‹°ì½˜ íŒŒí‹°í´ ë Œë”ë§
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.font = `${p.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.emoji, 0, 0);
                } else {
                    // ì›í˜• íŒŒí‹°í´ ë Œë”ë§
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }
        
                 // ë¸”ëŸ­ ì‚­ì œ ì²˜ë¦¬ (íŒŒí‹°í´ íš¨ê³¼ì™€ í•¨ê»˜)
        function deleteBlock(block) {
            if (block) {
                // ì„ íƒëœ ë¸”ëŸ­ì´ ì‚­ì œë˜ëŠ” ê²½ìš° ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ê³¼ ë¸”ëŸ­ ë²„íŠ¼ ì œê±°
                if (selectedBlock && selectedBlock.id === block.id) {
                    removeResizeHandles();
                    removeBlockButtons();
                    selectedBlock = null;
                }
                
                // ì‚­ì œ í­ë°œ íŒŒí‹°í´ íš¨ê³¼
                const deleteEmojis = ['ğŸ’¥', 'ğŸ”¥', 'ğŸ’¨', 'ğŸ’€', 'âš¡', 'ğŸŒªï¸', 'ğŸ’£', 'ğŸš€'];
                createParticles(block.position.x, block.position.y, block.originalColor || block.render.fillStyle, 30);
                createEmojiParticles(block.position.x, block.position.y, deleteEmojis, 15);
                
                // ë¸”ëŸ­ ì œê±°
                World.remove(world, block);
                todos = todos.filter(todo => todo.id !== block.id);
                updateStats();
                autoSave(); // ìë™ ì €ì¥
            }
        }
        
        // ì¶©ëŒ ì²˜ë¦¬
        function handleCollision(event) {
            const pairs = event.pairs;
            pairs.forEach(pair => {
                const { bodyA, bodyB } = pair;
                
                // í˜„ì¬ ë–¨ì–´ì§€ëŠ” ë¸”ëŸ­ì´ ë‹¤ë¥¸ ë¸”ëŸ­ì´ë‚˜ ë°”ë‹¥ì— ë‹¿ìœ¼ë©´ ì¡°ì‘ ë¶ˆê°€
                if ((bodyA === currentBlock || bodyB === currentBlock) && isBlockFalling) {
                    setTimeout(() => {
                        isBlockFalling = false;
                        currentBlock = null;
                    }, 100);
                }
            });
        }
        
        // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
        document.addEventListener('keydown', (e) => {
            if (!currentBlock || !isBlockFalling) return;
            
            const force = 0.01;
            const torque = 0.1;
            
            switch(e.key) {
                case 'ArrowLeft':
                    Body.applyForce(currentBlock, currentBlock.position, { x: -force, y: 0 });
                    break;
                case 'ArrowRight':
                    Body.applyForce(currentBlock, currentBlock.position, { x: force, y: 0 });
                    break;
                case 'ArrowDown':
                    Body.applyForce(currentBlock, currentBlock.position, { x: 0, y: force * 2 });
                    break;
                case ' ':
                    e.preventDefault();
                    Body.setAngularVelocity(currentBlock, torque);
                    break;

            }
        });
        
                 // ë§ˆìš°ìŠ¤ ì›€ì§ì„ ê°ì§€ (í˜¸ë²„ íš¨ê³¼)
        document.getElementById('gameCanvas').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // í˜¸ë²„ëœ ë¸”ëŸ­ ì°¾ê¸°
            let foundBlock = null;
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                if (x >= pos.x - blockWidth/2 && x <= pos.x + blockWidth/2 &&
                    y >= pos.y - blockHeight/2 && y <= pos.y + blockHeight/2) {
                    foundBlock = block;
                }
            });
            
                         if (foundBlock !== hoveredBlock) {
                hoveredBlock = foundBlock;
                updateButtonStates();
            }
        });
        
                 // ë§ˆìš°ìŠ¤ê°€ ìº”ë²„ìŠ¤ë¥¼ ë²—ì–´ë‚  ë•Œ í˜¸ë²„ ìƒíƒœ ì´ˆê¸°í™”
        document.getElementById('gameCanvas').addEventListener('mouseleave', () => {
            hoveredBlock = null;
            updateButtonStates();
        });
        
        // ë§ˆìš°ìŠ¤ í´ë¦­ìœ¼ë¡œ ë¸”ëŸ­ ì„ íƒ
        document.getElementById('gameCanvas').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // í´ë¦­ëœ ë¸”ëŸ­ ì°¾ê¸°
            let clickedBlock = null;
            todos.forEach(block => {
                const pos = block.position;
                const blockWidth = block.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = block.blockHeight || MIN_BLOCK_HEIGHT;
                
                if (x >= pos.x - blockWidth/2 && x <= pos.x + blockWidth/2 &&
                    y >= pos.y - blockHeight/2 && y <= pos.y + blockHeight/2) {
                    clickedBlock = block;
                }
            });
            
            // ì´ì „ ì„ íƒ í•´ì œ
            if (selectedBlock) {
                selectedBlock.isSelected = false;
                selectedBlock.render.fillStyle = selectedBlock.originalColor;
                selectedBlock.render.strokeStyle = '#fff'; // ì›ë˜ í…Œë‘ë¦¬ë¡œ ë³µì›
                selectedBlock.render.lineWidth = 3; // ì›ë˜ ë‘ê»˜ë¡œ ë³µì›
                removeResizeHandles(); // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ì œê±°
                removeBlockButtons(); // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ì œê±°
            }
            
            // ìƒˆë¡œìš´ ë¸”ëŸ­ ì„ íƒ
            if (clickedBlock) {
                selectedBlock = clickedBlock;
                selectedBlock.isSelected = true;
                selectedBlock.render.strokeStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰ í…Œë‘ë¦¬
                selectedBlock.render.lineWidth = 6; // êµµì€ í…Œë‘ë¦¬
                createResizeHandles(selectedBlock); // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìƒì„±
                createBlockButtons(selectedBlock); // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ìƒì„±
            } else {
                selectedBlock = null;
                removeResizeHandles(); // ì„ íƒ í•´ì œ ì‹œ í•¸ë“¤ ì œê±°
                removeBlockButtons(); // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ì œê±°
            }
            
            updateButtonStates();
        });
        
        
        
        // í• ì¼ ì¶”ê°€
        function addTodo() {
            const input = document.getElementById('todoInput');
            const text = input.value.trim();
            
            if (text && !isBlockFalling) {
                createTodoBlock(text);
                input.value = '';
                totalCount++;
                updateStats();
            }
        }
        
        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            // DOM ìš”ì†Œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸ í›„ ì—…ë°ì´íŠ¸
            const totalElement = document.getElementById('totalTodos');
            const completedElement = document.getElementById('completedTodos');
            const activeElement = document.getElementById('activeTodos');
            
            if (totalElement) totalElement.textContent = totalCount;
            if (completedElement) completedElement.textContent = completedCount;
            if (activeElement) activeElement.textContent = todos.filter(t => !t.isCompleted).length;
            
            // ì½˜ì†”ì— í†µê³„ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
            console.log(`ğŸ“Š í†µê³„ - ì´: ${totalCount}, ì™„ë£Œ: ${completedCount}, í™œì„±: ${todos.filter(t => !t.isCompleted).length}`);
        }
        
                 // ë¸”ëŸ­ í…ìŠ¤íŠ¸ ë Œë”ë§
        function renderBlockText() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            todos.forEach(block => {
                if (block.render.visible !== false) {
                    const pos = block.position;
                    const angle = block.angle;
                    
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(angle);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // ì™„ë£Œëœ ë¸”ëŸ­ì€ ì·¨ì†Œì„  ì¶”ê°€
                    if (block.isCompleted) {
                        ctx.fillStyle = '#333333'; // ì™„ë£Œëœ ë¸”ëŸ­ì€ ì–´ë‘ìš´ ê¸€ì
                    }
                    
                    // ë©€í‹°ë¼ì¸ í…ìŠ¤íŠ¸ ë Œë”ë§
                    if (block.textLines && block.textLines.length > 1) {
                        const totalHeight = (block.textLines.length - 1) * LINE_HEIGHT;
                        const startY = -totalHeight / 2;
                        
                        block.textLines.forEach((line, index) => {
                            const y = startY + (index * LINE_HEIGHT);
                            ctx.fillText(line, 0, y);
                            
                            // ì™„ë£Œëœ ë¸”ëŸ­ì€ ì·¨ì†Œì„  ê·¸ë¦¬ê¸°
                            if (block.isCompleted) {
                                ctx.strokeStyle = '#333333';
                                ctx.lineWidth = 2;
                                ctx.beginPath();
                                ctx.moveTo(-ctx.measureText(line).width / 2, y);
                                ctx.lineTo(ctx.measureText(line).width / 2, y);
                                ctx.stroke();
                            }
                        });
                    } else {
                        ctx.fillText(block.todoText, 0, 0);
                        
                        // ì™„ë£Œëœ ë¸”ëŸ­ì€ ì·¨ì†Œì„  ê·¸ë¦¬ê¸°
                        if (block.isCompleted) {
                            ctx.strokeStyle = '#333333';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(-ctx.measureText(block.todoText).width / 2, 0);
                            ctx.lineTo(ctx.measureText(block.todoText).width / 2, 0);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.restore();
                }
            });
        }
        
                 // ë Œë”ë§ ë£¨í”„
        function gameLoop() {
            updateParticles();
            checkAndFixBlockBounds(); // ë§¤ í”„ë ˆì„ë§ˆë‹¤ ë¸”ëŸ­ ê²½ê³„ ì²´í¬
            updateResizeHandles(); // ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateBlockButtons(); // ë¸”ëŸ­ ìœ„ ë²„íŠ¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            renderBlockText();
            renderParticles();
            requestAnimationFrame(gameLoop);
        }
        
                 // ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateButtonStates() {
            const completeBtn = document.getElementById('completeBtn');
            const deleteBtn = document.getElementById('deleteBtn');
            
            if (selectedBlock) {
                completeBtn.disabled = false;
                deleteBtn.disabled = false;
            } else {
                completeBtn.disabled = true;
                deleteBtn.disabled = true;
            }
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ëŠ” í•­ìƒ ê³ ì •
            completeBtn.textContent = 'ì™„ë£Œ';
            deleteBtn.textContent = 'ğŸ—‘ï¸';
        }
        
        // ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
        function completeSelectedBlock() {
            if (selectedBlock) {
                completeBlock(selectedBlock);
                selectedBlock = null;
                updateButtonStates();
            }
        }
        
        function deleteSelectedBlock() {
            if (selectedBlock) {
                deleteBlock(selectedBlock);
                selectedBlock = null;
                updateButtonStates();
            }
        }
        
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— TODO ë°ì´í„° ì €ì¥
        function saveTodosToLocalStorage() {
            const todoData = todos.map(block => ({
                id: block.id,
                todoText: block.todoText,
                isCompleted: block.isCompleted,
                position: { x: block.position.x, y: block.position.y },
                angle: block.angle,
                blockWidth: block.blockWidth,
                blockHeight: block.blockHeight,
                originalColor: block.originalColor,
                textLines: block.textLines
            }));
            
            const saveData = {
                todos: todoData,
                totalCount: totalCount,
                completedCount: completedCount,
                timestamp: Date.now()
            };
            
            localStorage.setItem('physicsToDoData', JSON.stringify(saveData));
            alert('ğŸ’¾ TODO ë°ì´í„°ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }
        
        // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ TODO ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        function loadTodosFromLocalStorage() {
            try {
                const savedData = localStorage.getItem('physicsToDoData');
                if (!savedData) {
                    alert('ğŸ“‚ ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                const data = JSON.parse(savedData);
                console.log('ë¶ˆëŸ¬ì˜¨ ë°ì´í„°:', data); // ë””ë²„ê¹…ìš©
                
                if (!data.todos || !Array.isArray(data.todos)) {
                    alert('âŒ ì €ì¥ëœ ë°ì´í„° í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ê¸°ì¡´ ë¸”ëŸ­ë“¤ ëª¨ë‘ ì œê±°
                clearAllTodos();
                
                // ì €ì¥ëœ ë¸”ëŸ­ë“¤ ë³µì›
                let successCount = 0;
                data.todos.forEach((todoData, index) => {
                    try {
                        const block = createBlockFromData(todoData);
                        if (block) {
                            todos.push(block);
                            successCount++;
                        }
                    } catch (blockError) {
                        console.error(`ë¸”ëŸ­ ${index} ë³µì› ì‹¤íŒ¨:`, blockError, todoData);
                    }
                });
                
                // í†µê³„ ë³µì›
                totalCount = data.totalCount || successCount;
                completedCount = data.completedCount || todos.filter(t => t.isCompleted).length;
                
                updateStats();
                alert(`ğŸ“‚ ${successCount}ê°œì˜ TODOë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤!`);
                
            } catch (error) {
                console.error('ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
                alert(`âŒ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            }
        }
        
        // ëª¨ë“  TODO ë¸”ëŸ­ ì œê±°
        function clearAllTodos() {
            todos.forEach(block => {
                World.remove(world, block);
            });
            todos = [];
            selectedBlock = null;
            removeResizeHandles();
            removeBlockButtons();
        }
        
        // ì €ì¥ëœ ë°ì´í„°ë¡œë¶€í„° ë¸”ëŸ­ ìƒì„±
        function createBlockFromData(data) {
            try {
                // í•„ìˆ˜ ë°ì´í„° ê²€ì¦
                if (!data || !data.todoText) {
                    console.error('í•„ìˆ˜ ë°ì´í„° ëˆ„ë½:', data);
                    return null;
                }
                
                // ê¸°ë³¸ê°’ ì„¤ì •
                const position = data.position || { x: CANVAS_WIDTH/2, y: 100 };
                const blockWidth = data.blockWidth || MIN_BLOCK_WIDTH;
                const blockHeight = data.blockHeight || MIN_BLOCK_HEIGHT;
                const originalColor = data.originalColor || '#ff6b6b';
                const angle = data.angle || 0;
                
                const block = Bodies.rectangle(position.x, position.y, blockWidth, blockHeight, {
                    render: {
                        fillStyle: data.isCompleted ? '#888888' : originalColor,
                        strokeStyle: '#fff',
                        lineWidth: 3
                    },
                    chamfer: { radius: 15 },
                    density: 0.002,
                    frictionAir: 0.005,
                    restitution: 0.2,
                    friction: 0.9
                });
                
                // ë¸”ëŸ­ ì†ì„± ë³µì›
                block.id = data.id || Date.now() + Math.random();
                block.todoText = data.todoText;
                block.isCompleted = data.isCompleted || false;
                block.blockWidth = blockWidth;
                block.blockHeight = blockHeight;
                block.originalColor = originalColor;
                block.textLines = data.textLines || wrapText(data.todoText);
                block.isSelected = false;
                
                // íšŒì „ ê°ë„ ë³µì› (ì•ˆì „í•˜ê²Œ)
                if (angle && !isNaN(angle)) {
                    Body.setAngle(block, angle);
                }
                
                World.add(world, block);
                return block;
                
            } catch (error) {
                console.error('ë¸”ëŸ­ ìƒì„± ì˜¤ë¥˜:', error, data);
                return null;
            }
        }
        
        // JSON íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°
        function exportTodosToJSON() {
            const todoData = todos.map(block => ({
                id: block.id,
                todoText: block.todoText,
                isCompleted: block.isCompleted,
                position: { x: block.position.x, y: block.position.y },
                angle: block.angle,
                blockWidth: block.blockWidth,
                blockHeight: block.blockHeight,
                originalColor: block.originalColor,
                textLines: block.textLines
            }));
            
            const exportData = {
                todos: todoData,
                totalCount: totalCount,
                completedCount: completedCount,
                exportDate: new Date().toISOString(),
                version: "1.0"
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `ë¬¼ë¦¬ì—”ì§„TODO_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            alert('ğŸ“¤ TODO ë°ì´í„°ê°€ JSON íŒŒì¼ë¡œ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
        }
        
        // JSON íŒŒì¼ì—ì„œ ê°€ì ¸ì˜¤ê¸°
        function importTodosFromJSON() {
            document.getElementById('fileInput').click();
        }
        
        // íŒŒì¼ ì„ íƒ ì²˜ë¦¬
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    console.log('ê°€ì ¸ì˜¨ íŒŒì¼ ë°ì´í„°:', data); // ë””ë²„ê¹…ìš©
                    
                    if (!data.todos || !Array.isArray(data.todos)) {
                        alert('âŒ ì˜¬ë°”ë¥¸ TODO JSON íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤.');
                        return;
                    }
                    
                    // ê¸°ì¡´ ë¸”ëŸ­ë“¤ ëª¨ë‘ ì œê±°
                    clearAllTodos();
                    
                    // ê°€ì ¸ì˜¨ ë¸”ëŸ­ë“¤ ë³µì›
                    let successCount = 0;
                    data.todos.forEach((todoData, index) => {
                        try {
                            const block = createBlockFromData(todoData);
                            if (block) {
                                todos.push(block);
                                successCount++;
                            }
                        } catch (blockError) {
                            console.error(`ë¸”ëŸ­ ${index} ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:`, blockError, todoData);
                        }
                    });
                    
                    // í†µê³„ ë³µì›
                    totalCount = data.totalCount || successCount;
                    completedCount = data.completedCount || todos.filter(t => t.isCompleted).length;
                    
                    updateStats();
                    alert(`ğŸ“¥ ${successCount}ê°œì˜ TODOë¥¼ ê°€ì ¸ì™”ìŠµë‹ˆë‹¤!`);
                    
                } catch (error) {
                    console.error('íŒŒì¼ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
                    alert(`âŒ íŒŒì¼ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // íŒŒì¼ ì…ë ¥ ì´ˆê¸°í™”
            event.target.value = '';
        }
        
        // ìë™ ì €ì¥ (ë¸”ëŸ­ ì¶”ê°€/ì™„ë£Œ/ì‚­ì œ ì‹œ)
        function autoSave() {
            const todoData = todos.map(block => ({
                id: block.id,
                todoText: block.todoText,
                isCompleted: block.isCompleted,
                position: { x: block.position.x, y: block.position.y },
                angle: block.angle,
                blockWidth: block.blockWidth,
                blockHeight: block.blockHeight,
                originalColor: block.originalColor,
                textLines: block.textLines
            }));
            
            const saveData = {
                todos: todoData,
                totalCount: totalCount,
                completedCount: completedCount,
                timestamp: Date.now()
            };
            
            localStorage.setItem('physicsToDoData', JSON.stringify(saveData));
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('addBtn').addEventListener('click', addTodo);
        document.getElementById('completeBtn').addEventListener('click', completeSelectedBlock);
        document.getElementById('deleteBtn').addEventListener('click', deleteSelectedBlock);
        document.getElementById('saveBtn').addEventListener('click', saveTodosToLocalStorage);
        document.getElementById('loadBtn').addEventListener('click', loadTodosFromLocalStorage);
        document.getElementById('exportBtn').addEventListener('click', exportTodosToJSON);
        document.getElementById('importBtn').addEventListener('click', importTodosFromJSON);
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        document.getElementById('todoInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const input = document.getElementById('todoInput');
                const text = input.value.trim();
                
                // ì…ë ¥ì°½ ì¦‰ì‹œ ì§€ìš°ê¸°
                input.value = '';
                
                // í…ìŠ¤íŠ¸ê°€ ìˆê³  ë¸”ëŸ­ì´ ë–¨ì–´ì§€ê³  ìˆì§€ ì•Šì„ ë•Œë§Œ ë¸”ëŸ­ ìƒì„±
                if (text && !isBlockFalling) {
                    createTodoBlock(text);
                    totalCount++;
                    updateStats();
                }
            }
        });
        
        // ë¸Œë¼ìš°ì € í¬ê¸° ë³€ê²½ ê°ì§€
        function handleResize() {
            updateCanvasSize();
            createWalls();
            // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ë¦¬ì‚¬ì´ì¦ˆ í•¸ë“¤ê³¼ ë¸”ëŸ­ ë²„íŠ¼ ìœ„ì¹˜ë„ ì—…ë°ì´íŠ¸
            if (selectedBlock) {
                createResizeHandles(selectedBlock);
                createBlockButtons(selectedBlock);
            }
        }
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        window.addEventListener('resize', handleResize);
        window.addEventListener('load', handleResize);
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ìœ¼ë¡œ ì €ì¥ëœ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        function autoLoadOnStart() {
            try {
                const savedData = localStorage.getItem('physicsToDoData');
                if (savedData) {
                    const data = JSON.parse(savedData);
                    if (data.todos && data.todos.length > 0) {
                        // ì €ì¥ëœ ë¸”ëŸ­ë“¤ ë³µì›
                        let successCount = 0;
                        data.todos.forEach((todoData, index) => {
                            try {
                                const block = createBlockFromData(todoData);
                                if (block) {
                                    todos.push(block);
                                    successCount++;
                                }
                            } catch (blockError) {
                                console.error(`ìë™ ë¡œë“œ ë¸”ëŸ­ ${index} ì‹¤íŒ¨:`, blockError);
                            }
                        });
                        
                        // í†µê³„ ë³µì›
                        totalCount = data.totalCount || successCount;
                        completedCount = data.completedCount || todos.filter(t => t.isCompleted).length;
                        
                        updateStats();
                        if (successCount > 0) {
                            console.log(`ìë™ìœ¼ë¡œ ${successCount}ê°œì˜ TODOë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.`);
                        }
                    }
                }
            } catch (error) {
                console.error('ìë™ ë¡œë“œ ì˜¤ë¥˜:', error);
            }
        }
        
        // ê²Œì„ ì‹œì‘
        initGame();
        gameLoop();
        updateStats();
        updateButtonStates();
        
        // ìë™ ë¡œë“œ (ê²Œì„ ì´ˆê¸°í™” í›„)
        setTimeout(autoLoadOnStart, 100);
    </script>
</body>
</html>
