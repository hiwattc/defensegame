<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ë””íœìŠ¤ ê²Œì„2</title>
    <style>
        canvas {
            border: 1px solid black;
            background: #87CEEB;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #333;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            catapult: {
                x: 100,
                y: 500,
                power: 0,
                angle: 45,
                charging: false,
                maxPower: 400, // ìµœëŒ€ íŒŒì›Œë¥¼ 400ìœ¼ë¡œ ì¦ê°€
                displayMaxPower: 100 // í‘œì‹œìš© ìµœëŒ€ íŒŒì›Œ
            },
            enemies: [],
            projectiles: [],
            score: 0,
            explosions: [],
            enemyEmojis: ['ğŸ‘¾', 'ğŸ‘»', 'ğŸ¤–', 'ğŸ‘½', 'ğŸƒ', 'ğŸ’€', 'ğŸ‘¹', 'ğŸ‘º', 'ğŸ¤¡', 'ğŸ‘¿'] // ì  ì´ëª¨í‹°ì½˜ ë°°ì—´
        };

        // ì§€ë©´ ê·¸ë¦¬ê¸°
        function drawGround() {
            // ë©”ì¸ ì§€ë©´
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 20);

            // ì”ë”” íš¨ê³¼
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, canvas.height - 20, canvas.width, 5);

            // ì§€ë©´ í…ìŠ¤ì²˜
            for (let i = 0; i < canvas.width; i += 20) {
                ctx.fillStyle = '#A0522D';
                ctx.fillRect(i, canvas.height - 20, 10, 20);
            }
        }

        // íˆ¬ì„ê¸° ê·¸ë¦¬ê¸°
        function drawCatapult() {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(gameState.catapult.x - 20, gameState.catapult.y - 10, 40, 20);
            
            // ë°œì‚¬ëŒ€ ê·¸ë¦¬ê¸°
            ctx.beginPath();
            ctx.moveTo(gameState.catapult.x, gameState.catapult.y);
            ctx.lineTo(
                gameState.catapult.x + Math.cos(gameState.catapult.angle * Math.PI / 180) * 50,
                gameState.catapult.y - Math.sin(gameState.catapult.angle * Math.PI / 180) * 50
            );
            ctx.strokeStyle = '#4A4A4A';
            ctx.lineWidth = 5;
            ctx.stroke();
        }

        // í¬íƒ„ ê·¸ë¦¬ê¸°
        function drawProjectile(projectile) {
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#FF4500';
            ctx.fill();

            // ë¶ˆê½ƒ íš¨ê³¼
            ctx.beginPath();
            ctx.moveTo(projectile.x, projectile.y);
            ctx.lineTo(
                projectile.x - projectile.vx * 0.5,
                projectile.y - projectile.vy * 0.5
            );
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // ì  ê·¸ë¦¬ê¸°
        function drawEnemy(enemy) {
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(enemy.emoji, enemy.x, enemy.y);
        }

        // ì˜ˆìƒ ê¶¤ì  ê·¸ë¦¬ê¸°
        function drawTrajectory() {
            if (!gameState.catapult.charging) return;

            const power = gameState.catapult.power;
            const angle = gameState.catapult.angle * Math.PI / 180;
            // íŒŒì›Œì— ë”°ë¥¸ ì†ë„ ê³„ìˆ˜ ì¡°ì • (0-400% ë²”ìœ„ì—ì„œ 0.5-2.0ìœ¼ë¡œ ë§¤í•‘)
            const speedMultiplier = 0.5 + (power / gameState.catapult.maxPower) * 1.5;
            const vx = Math.cos(angle) * power * speedMultiplier;
            const vy = -Math.sin(angle) * power * speedMultiplier;
            
            ctx.beginPath();
            ctx.moveTo(gameState.catapult.x, gameState.catapult.y);
            
            let x = gameState.catapult.x;
            let y = gameState.catapult.y;
            let vxTemp = vx;
            let vyTemp = vy;
            
            for (let i = 0; i < 300; i++) {
                x += vxTemp;
                y += vyTemp;
                vyTemp += 0.1;
                
                if (y > canvas.height - 20 || x > canvas.width * 2) break;
                
                ctx.lineTo(x, y);
            }
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // íŒŒì›Œ ê²Œì´ì§€ ê·¸ë¦¬ê¸°
        function drawPowerGauge() {
            const gaugeWidth = 400;
            const gaugeHeight = 40;
            const gaugeX = 50;
            const gaugeY = 50;

            // ë°°ê²½
            ctx.fillStyle = '#333';
            ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);

            // íŒŒì›Œ ê²Œì´ì§€ (ì‹¤ì œ íŒŒì›Œì˜ 25%ë¥¼ 100%ë¡œ í‘œì‹œ)
            const displayPower = (gameState.catapult.power / gameState.catapult.maxPower) * gameState.catapult.displayMaxPower;
            const powerWidth = (displayPower / gameState.catapult.displayMaxPower) * gaugeWidth;
            
            // ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼ ì¶”ê°€
            const gradient = ctx.createLinearGradient(gaugeX, gaugeY, gaugeX + powerWidth, gaugeY);
            gradient.addColorStop(0, '#00FF00');
            gradient.addColorStop(1, '#00CC00');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(gaugeX, gaugeY, powerWidth, gaugeHeight);

            // ê²Œì´ì§€ í…Œë‘ë¦¬
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight);

            // ê±°ë¦¬ í‘œì‹œ (ì‹¤ì œ íŒŒì›Œì˜ 25%ë¥¼ 100%ë¡œ í‘œì‹œ)
            const displayPercentage = Math.floor((gameState.catapult.power / gameState.catapult.maxPower) * gameState.catapult.displayMaxPower);
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 24px Arial';
            ctx.fillText(`íŒŒì›Œ: ${displayPercentage}%`, gaugeX, gaugeY - 10);
        }

        // í­ë°œ íš¨ê³¼ ê·¸ë¦¬ê¸°
        function drawExplosion(explosion) {
            const gradient = ctx.createRadialGradient(
                explosion.x, explosion.y, 0,
                explosion.x, explosion.y, explosion.radius
            );
            gradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 100, 0, 0.6)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');

            ctx.beginPath();
            ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // í­ë°œ íŒŒí¸ íš¨ê³¼
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const x = explosion.x + Math.cos(angle) * explosion.radius;
                const y = explosion.y + Math.sin(angle) * explosion.radius;
                
                ctx.beginPath();
                ctx.moveTo(explosion.x, explosion.y);
                ctx.lineTo(x, y);
                ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // ì¶©ëŒ ê°ì§€
        function checkCollision(projectile, enemy) {
            const dx = projectile.x - enemy.x;
            const dy = projectile.y - enemy.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < 25; // ì´ëª¨í‹°ì½˜ í¬ê¸°ì— ë§ê²Œ ì¶©ëŒ ë°˜ê²½ ì¡°ì •
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ì§€ë©´ ê·¸ë¦¬ê¸°
            drawGround();

            // íˆ¬ì„ê¸° ê·¸ë¦¬ê¸°
            drawCatapult();

            // ì˜ˆìƒ ê¶¤ì  ê·¸ë¦¬ê¸°
            drawTrajectory();

            // íŒŒì›Œ ê²Œì´ì§€ ê·¸ë¦¬ê¸°
            drawPowerGauge();

            // í¬íƒ„ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            gameState.projectiles.forEach((projectile, pIndex) => {
                projectile.x += projectile.vx;
                projectile.y += projectile.vy;
                projectile.vy += 0.1;

                drawProjectile(projectile);

                // ì ê³¼ì˜ ì¶©ëŒ ì²´í¬
                gameState.enemies.forEach((enemy, eIndex) => {
                    if (checkCollision(projectile, enemy)) {
                        // í­ë°œ íš¨ê³¼ ìƒì„±
                        gameState.explosions.push({
                            x: enemy.x,
                            y: enemy.y,
                            radius: 0,
                            maxRadius: 50,
                            duration: 20
                        });
                        
                        // ì  ì œê±°
                        gameState.enemies.splice(eIndex, 1);
                        // í¬íƒ„ ì œê±°
                        gameState.projectiles.splice(pIndex, 1);
                        // ì ìˆ˜ ì¦ê°€
                        gameState.score += 100;
                    }
                });

                // ì§€ë©´ ì¶©ëŒ ì²´í¬
                if (projectile.y > canvas.height - 20 || projectile.x > canvas.width * 2) {
                    // í­ë°œ íš¨ê³¼
                    gameState.explosions.push({
                        x: projectile.x,
                        y: projectile.y,
                        radius: 0,
                        maxRadius: 30,
                        duration: 15
                    });
                    gameState.projectiles.splice(pIndex, 1);
                }
            });

            // í­ë°œ íš¨ê³¼ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            gameState.explosions.forEach((explosion, index) => {
                explosion.radius += explosion.maxRadius / explosion.duration;
                drawExplosion(explosion);
                
                if (explosion.radius >= explosion.maxRadius) {
                    gameState.explosions.splice(index, 1);
                }
            });

            // ì  ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            gameState.enemies.forEach((enemy, index) => {
                enemy.x += enemy.speed;
                drawEnemy(enemy);

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì  ì œê±°
                if (enemy.x < 0) { // ì™¼ìª½ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                    gameState.enemies.splice(index, 1);
                }
            });

            // ì ìˆ˜ í‘œì‹œ
            ctx.fillStyle = '#FFF';
            ctx.font = '20px Arial';
            ctx.fillText(`ì ìˆ˜: ${gameState.score}`, 20, 100);

            requestAnimationFrame(gameLoop);
        }

        // ì  ìƒì„±
        function spawnEnemy() {
            const randomEmoji = gameState.enemyEmojis[Math.floor(Math.random() * gameState.enemyEmojis.length)];
            gameState.enemies.push({
                x: canvas.width,
                y: Math.random() * (canvas.height - 100) + 50,
                speed: -0.5, // ìŒìˆ˜ë¡œ ë³€ê²½í•˜ì—¬ ì™¼ìª½ìœ¼ë¡œ ì´ë™
                emoji: randomEmoji
            });
        }

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                gameState.catapult.angle = Math.min(90, gameState.catapult.angle + 5);
            }
            if (e.key === 'ArrowRight') {
                gameState.catapult.angle = Math.max(0, gameState.catapult.angle - 5);
            }
            if (e.key === ' ') {
                gameState.catapult.charging = true;
                gameState.catapult.power = 0;
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ' && gameState.catapult.charging) {
                gameState.catapult.charging = false;
                const power = gameState.catapult.power;
                const angle = gameState.catapult.angle * Math.PI / 180;
                
                // íŒŒì›Œì— ë”°ë¥¸ ì†ë„ ê³„ìˆ˜ ì¡°ì • (0-400% ë²”ìœ„ì—ì„œ 0.5-2.0ìœ¼ë¡œ ë§¤í•‘)
                const speedMultiplier = 0.5 + (power / gameState.catapult.maxPower) * 1.5;
                
                gameState.projectiles.push({
                    x: gameState.catapult.x,
                    y: gameState.catapult.y,
                    vx: Math.cos(angle) * power * speedMultiplier,
                    vy: -Math.sin(angle) * power * speedMultiplier
                });
            }
        });

        // íŒŒì›Œ ê²Œì´ì§€ ì—…ë°ì´íŠ¸
        setInterval(() => {
            if (gameState.catapult.charging) {
                gameState.catapult.power = Math.min(gameState.catapult.maxPower, gameState.catapult.power + 4); // íŒŒì›Œ ì¦ê°€ ì†ë„ ì¡°ì •
            }
        }, 50);

        // ì  ìƒì„± íƒ€ì´ë¨¸ (2ì´ˆë§ˆë‹¤)
        setInterval(spawnEnemy, 2000);

        // ê²Œì„ ì‹œì‘
        gameLoop();
    </script>
</body>
</html>
