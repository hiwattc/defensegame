<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ë³¼ë§ ê²Œì„</title>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: #222; color: #fff; text-align: center; }
    h1 { margin-top: 30px; }
    .scoreboard { margin: 30px auto; display: flex; justify-content: center; }
    .frame {
      border: 2px solid #fff;
      border-radius: 8px;
      margin: 0 2px;
      padding: 8px 4px;
      width: 60px;
      background: #333;
    }
    .frame.current { background: #444; border-color: #ff0; }
    .rolls { font-size: 18px; margin-bottom: 4px; }
    .total { font-size: 16px; color: #ff0; }
    .pins { margin: 20px 0; }
    .pin-btn {
      background: #555;
      color: #fff;
      border: none;
      border-radius: 4px;
      margin: 2px;
      padding: 10px 14px;
      font-size: 16px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .pin-btn:hover { background: #ff9800; }
    #resetBtn {
      margin-top: 20px;
      background: #e53935;
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    #resetBtn:hover { background: #b71c1c; }
  </style>
</head>
<body>
  <h1>ğŸ³ ë³¼ë§ ê²Œì„</h1>
  <div id="gameArea" style="display:flex; flex-direction:column; align-items:center;">
    <canvas id="bowlingCanvas" width="500" height="350" style="background:#222; border:2px solid #fff; margin-bottom:20px;"></canvas>
  </div>
  <div class="scoreboard" id="scoreboard"></div>
  <div class="pins" id="pins"></div>
  <button id="resetBtn">ê²Œì„ ë¦¬ì…‹</button>
  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>
  <script>
    // Matter.js ë¬¼ë¦¬ì—”ì§„ ì´ˆê¸°í™”
    const { Engine, Render, Runner, World, Bodies, Body, Events, Mouse, MouseConstraint, Composite } = Matter;
    const engine = Engine.create();
    const world = engine.world;
    const canvas = document.getElementById('bowlingCanvas');
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: 500,
        height: 350,
        wireframes: false,
        background: '#222',
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    // ë³¼ë§í•€ê³¼ ê³µ, ë°”ë‹¥ ë“± ìƒì„±
    let ball, pins = [], ground, leftWall, rightWall, launchReady = true;
    const pinWidth = 18, pinHeight = 40, ballRadius = 18;
    function setupPhysics() {
      // ì›”ë“œ ì´ˆê¸°í™”
      World.clear(world);
      Engine.clear(engine);
      pins = [];
      // ë°”ë‹¥, ë²½
      ground = Bodies.rectangle(250, 340, 500, 20, { isStatic: true, render: { fillStyle: '#888' } });
      leftWall = Bodies.rectangle(5, 175, 10, 350, { isStatic: true, render: { visible: false } });
      rightWall = Bodies.rectangle(495, 175, 10, 350, { isStatic: true, render: { visible: false } });
      World.add(world, [ground, leftWall, rightWall]);
      // ë³¼ë§ê³µ
      ball = Bodies.circle(250, 300, ballRadius, {
        restitution: 0.5,
        friction: 0.01,
        density: 0.04,
        render: { fillStyle: '#00bcd4' }
      });
      World.add(world, ball);
      // í•€ ë°°ì¹˜ (ì‚¼ê°í˜• í˜•íƒœ)
      const startX = 250, startY = 80, gap = 26;
      let pinId = 0;
      for (let row = 0; row < 4; row++) {
        for (let i = 0; i <= row; i++) {
          let x = startX - gap * row / 2 + i * gap;
          let y = startY + row * (pinHeight * 0.7);
          let pin = Bodies.rectangle(x, y, pinWidth, pinHeight, {
            isStatic: false,
            restitution: 0.3,
            friction: 0.2,
            density: 0.01,
            label: 'pin',
            render: { fillStyle: '#fff', strokeStyle: '#f00', lineWidth: 2 }
          });
          pin.customId = pinId++;
          pins.push(pin);
        }
      }
      World.add(world, pins);
      launchReady = true;
    }

    // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ ë³¼ë§ê³µ ë˜ì§€ê¸°
    let mouse = Mouse.create(render.canvas);
    let mouseConstraint = MouseConstraint.create(engine, {
      mouse: mouse,
      constraint: {
        stiffness: 0.2,
        render: { visible: false }
      },
      collisionFilter: { mask: 0x0001 }
    });
    World.add(world, mouseConstraint);
    // ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ ì‹œì‘ ìœ„ì¹˜, ë ìœ„ì¹˜
    let dragStart = null;
    render.canvas.addEventListener('mousedown', function(e) {
      if (!launchReady) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      // ê³µ ìœ„ì—ì„œë§Œ ë“œë˜ê·¸ ì‹œì‘
      const dx = mx - ball.position.x;
      const dy = my - ball.position.y;
      if (dx*dx + dy*dy <= ballRadius*ballRadius) {
        dragStart = { x: mx, y: my };
      }
    });
    render.canvas.addEventListener('mouseup', function(e) {
      if (!launchReady || !dragStart) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      // ë˜ì§€ëŠ” ë°©í–¥: ë“œë˜ê·¸ ë°˜ëŒ€ ë°©í–¥
      const dx = dragStart.x - mx;
      const dy = dragStart.y - my;
      // ì†ë„ ì œí•œ
      const forceScale = 0.04;
      Body.setVelocity(ball, { x: dx * forceScale, y: dy * forceScale });
      launchReady = false;
      dragStart = null;
    });

    // í•€ ì“°ëŸ¬ì§ ê°ì§€ ë° ì ìˆ˜ ì²˜ë¦¬
    let fallenPins = [];
    function checkPins() {
      let count = 0;
      fallenPins = [];
      for (let pin of pins) {
        // í•€ì´ ì¼ì • ê°ë„ ì´ìƒ ê¸°ìš¸ì–´ì§€ë©´ ì“°ëŸ¬ì§„ ê²ƒìœ¼ë¡œ ê°„ì£¼
        if (Math.abs(pin.angle) > 0.5 || pin.position.y > 340) {
          count++;
          fallenPins.push(pin.customId);
        }
      }
      return count;
    }

    // í•œ ë²ˆ ë˜ì§„ í›„ í•€ ì“°ëŸ¬ì§ ì²´í¬ ë° ì ìˆ˜íŒ ì—°ë™
    function afterThrow() {
      setTimeout(() => {
        let fallen = checkPins();
        // ì ìˆ˜íŒì— ë°˜ì˜ (í•€ ê°œìˆ˜ë§Œí¼ roll)
        if (fallen > 0 && !isGameOver) {
          roll(fallen);
        } else if (!isGameOver) {
          roll(0);
        }
        // ë‹¤ìŒ íˆ¬êµ¬ë¥¼ ìœ„í•´ ë¦¬ì…‹
        setTimeout(() => {
          setupPhysics();
        }, 1200);
      }, 1200);
    }

    // ë³¼ë§ê³µì´ ë˜ì ¸ì§„ í›„ ë©ˆì¶”ë©´ afterThrow ì‹¤í–‰
    Events.on(engine, 'afterUpdate', function() {
      if (!launchReady && Math.abs(ball.velocity.x) < 0.5 && Math.abs(ball.velocity.y) < 0.5) {
        launchReady = true; // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
        afterThrow();
      }
    });

    // ë³¼ë§ ê²Œì„ ìƒíƒœ
    let rolls = [];
    let currentFrame = 0;
    let isGameOver = false;

    function renderScoreboard() {
      const scoreboard = document.getElementById('scoreboard');
      scoreboard.innerHTML = '';
      let rollIndex = 0;
      let total = 0;
      for (let frame = 0; frame < 10; frame++) {
        let frameHtml = '<div class="frame' + (frame === currentFrame ? ' current' : '') + '">';
        let roll1 = rolls[rollIndex] !== undefined ? rolls[rollIndex] : '';
        let roll2 = rolls[rollIndex + 1] !== undefined ? rolls[rollIndex + 1] : '';
        let roll3 = '';
        // 10í”„ë ˆì„ ë³´ë„ˆìŠ¤ ì²˜ë¦¬
        if (frame === 9 && (roll1 === 10 || roll1 + roll2 === 10)) {
          roll3 = rolls[rollIndex + 2] !== undefined ? rolls[rollIndex + 2] : '';
        }
        // ì ìˆ˜ ê³„ì‚°
        let frameScore = getFrameScore(frame, rollIndex);
        if (frame < 9) {
          frameHtml += `<div class="rolls">${formatRoll(roll1)} | ${formatRoll(roll2)}</div>`;
          frameHtml += `<div class="total">${frameScore !== null ? (total += frameScore) : ''}</div>`;
        } else {
          frameHtml += `<div class="rolls">${formatRoll(roll1)} | ${formatRoll(roll2)}${roll3 !== '' ? ' | ' + formatRoll(roll3) : ''}</div>`;
          frameHtml += `<div class="total">${frameScore !== null ? (total += frameScore) : ''}</div>`;
        }
        frameHtml += '</div>';
        scoreboard.innerHTML += frameHtml;
        // ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì´ë™
        if (frame < 9) {
          if (roll1 === 10) {
            rollIndex += 1;
          } else {
            rollIndex += 2;
          }
        } else {
          rollIndex += 2;
          if (roll1 === 10 || roll1 + roll2 === 10) rollIndex++;
        }
      }
    }

    function formatRoll(roll) {
      if (roll === 10) return 'X';
      if (roll === '') return '';
      return roll;
    }

    function getFrameScore(frame, rollIndex) {
      if (rolls[rollIndex] === undefined) return null;
      // ìŠ¤íŠ¸ë¼ì´í¬
      if (rolls[rollIndex] === 10) {
        if (rolls[rollIndex + 1] !== undefined && rolls[rollIndex + 2] !== undefined) {
          return 10 + rolls[rollIndex + 1] + rolls[rollIndex + 2];
        } else {
          return null;
        }
      }
      // ìŠ¤í˜ì–´
      if (rolls[rollIndex + 1] !== undefined && rolls[rollIndex] + rolls[rollIndex + 1] === 10) {
        if (rolls[rollIndex + 2] !== undefined) {
          return 10 + rolls[rollIndex + 2];
        } else {
          return null;
        }
      }
      // ì¼ë°˜
      if (rolls[rollIndex + 1] !== undefined) {
        return rolls[rollIndex] + rolls[rollIndex + 1];
      }
      return null;
    }

    function renderPins() {
      const pinsDiv = document.getElementById('pins');
      if (isGameOver) {
        pinsDiv.innerHTML = '<h2>ê²Œì„ ì¢…ë£Œ! ğŸ‰</h2>';
        return;
      }
      let maxPins = getMaxPins();
      let html = '';
      for (let i = 0; i <= maxPins; i++) {
        html += `<button class="pin-btn" onclick="roll(${i})">${i}</button>`;
      }
      pinsDiv.innerHTML = html;
    }

    function getMaxPins() {
      let rollIndex = 0;
      let frame = 0;
      while (frame < currentFrame) {
        if (rolls[rollIndex] === 10 && frame < 9) {
          rollIndex += 1;
        } else {
          rollIndex += 2;
        }
        frame++;
      }
      // 10í”„ë ˆì„ ë³´ë„ˆìŠ¤ ì²˜ë¦¬
      if (currentFrame === 9) {
        let first = rolls[rollIndex] || 0;
        let second = rolls[rollIndex + 1] || 0;
        if (first === 10 || first + second === 10) {
          // 3ë²ˆì§¸ íˆ¬êµ¬
          if (rolls.length - rollIndex >= 2) {
            return 10;
          } else if (rolls.length - rollIndex === 1) {
            return first === 10 ? 10 : 10 - first;
          } else {
            return 10;
          }
        } else if (rolls.length - rollIndex === 1) {
          return 10 - first;
        } else {
          return 10;
        }
      }
      // ì¼ë°˜ í”„ë ˆì„
      if (rolls.length - rollIndex === 1) {
        return 10 - rolls[rollIndex];
      }
      return 10;
    }

    function roll(pins) {
      if (isGameOver) return;
      let rollIndex = 0;
      let frame = 0;
      while (frame < currentFrame) {
        if (rolls[rollIndex] === 10 && frame < 9) {
          rollIndex += 1;
        } else {
          rollIndex += 2;
        }
        frame++;
      }
      rolls.push(pins);
      // í”„ë ˆì„ ì´ë™
      if (currentFrame < 9) {
        if (pins === 10 || rolls.length - rollIndex === 2) {
          currentFrame++;
        }
      } else {
        // 10í”„ë ˆì„ ì²˜ë¦¬
        let first = rolls[rollIndex] || 0;
        let second = rolls[rollIndex + 1] || 0;
        if (first === 10 || first + second === 10) {
          if (rolls.length - rollIndex === 3) {
            isGameOver = true;
          }
        } else if (rolls.length - rollIndex === 2) {
          isGameOver = true;
        }
      }
      renderScoreboard();
      renderPins();
    }

    document.getElementById('resetBtn').onclick = function() {
      rolls = [];
      currentFrame = 0;
      isGameOver = false;
      renderScoreboard();
      renderPins();
      setupPhysics();
    };

    // ì´ˆê¸° ë Œë”ë§ ë° ë¬¼ë¦¬ì—”ì§„ ì„¸íŒ…
    renderScoreboard();
    renderPins();
    setupPhysics();
    window.roll = roll;
  </script>
</body>
</html>
