<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스마트 캘린더 - 일정 관리 시스템</title>
    <style>
        /* CSS Reset 및 기본 스타일 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* 라이트 테마 색상 */
            --primary-color: #1976d2;
            --secondary-color: #42a5f5;
            --background-color: #ffffff;
            --surface-color: #f5f5f5;
            --text-color: #212121;
            --text-secondary: #757575;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            --hover-color: rgba(25, 118, 210, 0.1);
        }

        [data-theme="dark"] {
            /* 다크 테마 색상 */
            --primary-color: #90caf9;
            --secondary-color: #64b5f6;
            --background-color: #121212;
            --surface-color: #1e1e1e;
            --text-color: #ffffff;
            --text-secondary: #b0b0b0;
            --border-color: #333333;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --success-color: #81c784;
            --warning-color: #ffb74d;
            --error-color: #e57373;
            --hover-color: rgba(144, 202, 249, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow-x: hidden;
        }

        /* 헤더 스타일 */
        .header {
            background-color: var(--surface-color);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        .header h1 {
            color: var(--primary-color);
            font-size: 1.8rem;
            font-weight: 600;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .nav-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s ease;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px var(--shadow-color);
        }

        .btn-secondary {
            background-color: var(--surface-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .btn-icon {
            padding: 0.5rem;
            min-width: 40px;
            justify-content: center;
        }

        .view-selector {
            display: flex;
            background-color: var(--surface-color);
            border-radius: 6px;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .view-btn {
            padding: 0.5rem 1rem;
            border: none;
            background-color: transparent;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s ease;
            border-right: 1px solid var(--border-color);
        }

        .view-btn:last-child {
            border-right: none;
        }

        .view-btn.active {
            background-color: var(--primary-color);
            color: white;
        }

        .search-container {
            position: relative;
        }

        .search-input {
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--background-color);
            color: var(--text-color);
            width: 200px;
            transition: all 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }

        .search-icon {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
        }

        /* 메인 컨테이너 */
        .main-container {
            display: flex;
            height: calc(100vh - 80px);
        }

        /* 사이드바 */
        .sidebar {
            width: 280px;
            background-color: var(--surface-color);
            border-right: 1px solid var(--border-color);
            padding: 1.5rem;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar-section {
            margin-bottom: 2rem;
        }

        .sidebar-section h3 {
            margin-bottom: 1rem;
            color: var(--text-color);
            font-size: 1rem;
            font-weight: 600;
        }

        .category-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .category-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-item:hover {
            background-color: var(--hover-color);
        }

        .category-item.active {
            background-color: var(--primary-color);
            color: white;
        }

        .category-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid var(--border-color);
        }

        .mini-calendar {
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
        }

        .mini-calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .mini-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            text-align: center;
        }

        .mini-calendar-day {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .mini-calendar-day:hover {
            background-color: var(--hover-color);
        }

        .mini-calendar-day.today {
            background-color: var(--primary-color);
            color: white;
        }

        .mini-calendar-day.other-month {
            color: var(--text-secondary);
        }

        /* 캘린더 메인 뷰 */
        .calendar-container {
            flex: 1;
            padding: 1.5rem;
            overflow: auto;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .current-date {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color);
        }

        /* 월간 뷰 */
        .month-view {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background-color: var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        .day-header {
            background-color: var(--surface-color);
            padding: 1rem;
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        .day-cell {
            background-color: var(--background-color);
            min-height: 120px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .day-cell:hover {
            background-color: var(--hover-color);
        }

        .day-cell.other-month {
            background-color: var(--surface-color);
            color: var(--text-secondary);
        }

        .day-cell.today {
            background-color: rgba(25, 118, 210, 0.1);
        }

        .day-number {
            font-weight: 600;
            margin-bottom: 0.5rem;
            align-self: flex-start;
        }

        .day-cell.today .day-number {
            background-color: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
        }

        .event-list {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
        }

        .event-item {
            background-color: var(--primary-color);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .event-item:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px var(--shadow-color);
        }

        /* 주간 뷰 */
        .week-view {
            display: grid;
            grid-template-columns: 60px repeat(7, 1fr);
            gap: 1px;
            background-color: var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        .time-slot {
            background-color: var(--surface-color);
            padding: 0.5rem;
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .hour-cell {
            background-color: var(--background-color);
            height: 60px;
            position: relative;
            border-bottom: 1px solid var(--border-color);
        }

        /* 일간 뷰 */
        .day-view {
            display: grid;
            grid-template-columns: 60px 1fr;
            gap: 1px;
            background-color: var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px var(--shadow-color);
        }

        .day-view-container {
            position: relative;
            background-color: var(--background-color);
        }

        .day-event-item {
            position: absolute;
            background-color: var(--primary-color);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 1px 3px var(--shadow-color);
            z-index: 10;
        }

        .day-event-item:hover {
            z-index: 20;
            box-shadow: 0 2px 8px var(--shadow-color);
            transform: scale(1.02);
        }

        .day-event-item.overlapping {
            opacity: 0.9;
        }

        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--background-color);
            border-radius: 12px;
            padding: 2rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px var(--shadow-color);
            animation: slideIn 0.3s ease;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .modal-header h2 {
            color: var(--text-color);
            font-size: 1.25rem;
            font-weight: 600;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .close-btn:hover {
            background-color: var(--hover-color);
            color: var(--text-color);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }

        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: 1rem;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .checkbox {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
        }

        .color-picker {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s ease;
        }

        .color-option.selected {
            border-color: var(--text-color);
            transform: scale(1.1);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        /* 알림 스타일 */
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--background-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            box-shadow: 0 4px 12px var(--shadow-color);
            z-index: 1001;
            animation: slideInRight 0.3s ease;
            max-width: 300px;
        }

        .notification.success {
            border-left: 4px solid var(--success-color);
        }

        .notification.warning {
            border-left: 4px solid var(--warning-color);
        }

        .notification.error {
            border-left: 4px solid var(--error-color);
        }

        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .notification-title {
            font-weight: 600;
            color: var(--text-color);
        }

        .notification-content {
            color: var(--text-secondary);
            font-size: 0.875rem;
        }

        /* 로딩 스피너 */
        .loading-spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        /* 애니메이션 */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            .header {
                padding: 1rem;
                flex-direction: column;
                align-items: stretch;
            }

            .header-controls {
                justify-content: space-between;
            }

            .search-input {
                width: 150px;
            }

            .sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                height: 100vh;
                z-index: 999;
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-container {
                margin-left: 0;
            }

            .day-cell {
                min-height: 80px;
                padding: 0.25rem;
            }

            .event-item {
                font-size: 0.625rem;
                padding: 1px 4px;
            }

            .modal-content {
                padding: 1rem;
                margin: 1rem;
            }
        }

        @media (max-width: 480px) {
            .month-view {
                grid-template-columns: repeat(7, 1fr);
                gap: 0;
            }

            .day-cell {
                min-height: 60px;
                padding: 0.125rem;
            }

            .day-number {
                font-size: 0.75rem;
            }

            .event-item {
                font-size: 0.5rem;
                padding: 1px 2px;
            }
        }

        /* 숨김 클래스 */
        .hidden {
            display: none !important;
        }

        /* 드래그 앤 드롭 */
        .dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .drop-zone {
            background-color: rgba(25, 118, 210, 0.1);
            border: 2px dashed var(--primary-color);
        }

        /* 테마 토글 버튼 */
        .theme-toggle {
            position: relative;
            width: 50px;
            height: 25px;
            background-color: var(--border-color);
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .theme-toggle::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background-color: var(--background-color);
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .theme-toggle {
            background-color: var(--primary-color);
        }

        [data-theme="dark"] .theme-toggle::before {
            transform: translateX(25px);
        }
    </style>
</head>
<body>
    <!-- 헤더 -->
    <header class="header">
        <div class="header-left">
            <h1>📅 스마트 캘린더</h1>
        </div>
        <div class="header-controls">
            <div class="nav-controls">
                <button class="btn btn-icon" id="prevBtn" title="이전">❮</button>
                <button class="btn btn-secondary" id="todayBtn">오늘</button>
                <button class="btn btn-icon" id="nextBtn" title="다음">❯</button>
            </div>
            <div class="view-selector">
                <button class="view-btn active" data-view="month">월</button>
                <button class="view-btn" data-view="week">주</button>
                <button class="view-btn" data-view="day">일</button>
            </div>
            <div class="search-container">
                <input type="text" class="search-input" id="searchInput" placeholder="일정 검색...">
                <span class="search-icon">🔍</span>
            </div>
            <button class="btn" id="addEventBtn">+ 일정 추가</button>
            <div class="theme-toggle" id="themeToggle" title="다크모드 전환"></div>
        </div>
    </header>

    <!-- 메인 컨테이너 -->
    <div class="main-container">
        <!-- 사이드바 -->
        <aside class="sidebar" id="sidebar">
            <!-- 미니 캘린더 -->
            <div class="sidebar-section">
                <div class="mini-calendar">
                    <div class="mini-calendar-header">
                        <button class="btn btn-icon" id="miniPrevBtn">❮</button>
                        <span id="miniCalendarTitle">2024년 1월</span>
                        <button class="btn btn-icon" id="miniNextBtn">❯</button>
                    </div>
                    <div class="mini-calendar-grid" id="miniCalendarGrid">
                        <!-- 미니 캘린더 날짜들이 여기에 생성됩니다 -->
                    </div>
                </div>
            </div>

            <!-- 카테고리 목록 -->
            <div class="sidebar-section">
                <h3>카테고리</h3>
                <div class="category-list" id="categoryList">
                    <!-- 카테고리 목록이 여기에 생성됩니다 -->
                </div>
                <button class="btn btn-secondary" id="addCategoryBtn" style="width: 100%; margin-top: 1rem;">+ 카테고리 추가</button>
            </div>

            <!-- 필터 옵션 -->
            <div class="sidebar-section">
                <h3>필터</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="allDayFilter" class="checkbox">
                    <label for="allDayFilter">종일 일정만</label>
                </div>
                <div class="checkbox-group" style="margin-top: 0.5rem;">
                    <input type="checkbox" id="reminderFilter" class="checkbox">
                    <label for="reminderFilter">알림 설정된 일정만</label>
                </div>
            </div>
        </aside>

        <!-- 캘린더 메인 뷰 -->
        <main class="calendar-container">
            <div class="calendar-header">
                <h2 class="current-date" id="currentDate">2024년 1월</h2>
                <div class="calendar-controls">
                    <button class="btn btn-secondary" id="exportBtn">내보내기</button>
                    <button class="btn btn-secondary" id="importBtn">가져오기</button>
                    <input type="file" id="importFile" style="display: none;" accept=".json">
                </div>
            </div>

            <!-- 월간 뷰 -->
            <div class="month-view" id="monthView">
                <!-- 월간 캘린더가 여기에 생성됩니다 -->
            </div>

            <!-- 주간 뷰 -->
            <div class="week-view hidden" id="weekView">
                <!-- 주간 캘린더가 여기에 생성됩니다 -->
            </div>

            <!-- 일간 뷰 -->
            <div class="day-view hidden" id="dayView">
                <!-- 일간 캘린더가 여기에 생성됩니다 -->
            </div>
        </main>
    </div>

    <!-- 일정 추가/편집 모달 -->
    <div class="modal" id="eventModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">일정 추가</h2>
                <button class="close-btn" id="closeModal">&times;</button>
            </div>
            <form id="eventForm">
                <div class="form-group">
                    <label for="eventTitle">제목 *</label>
                    <input type="text" id="eventTitle" class="form-input" required>
                </div>
                <div class="form-group">
                    <label for="eventDescription">설명</label>
                    <textarea id="eventDescription" class="form-input" rows="3"></textarea>
                </div>
                <div class="form-group">
                    <label for="eventStartDate">시작 날짜/시간 *</label>
                    <input type="datetime-local" id="eventStartDate" class="form-input" required>
                </div>
                <div class="form-group">
                    <label for="eventEndDate">종료 날짜/시간 *</label>
                    <input type="datetime-local" id="eventEndDate" class="form-input" required>
                </div>
                <div class="form-group">
                    <div class="checkbox-group">
                        <input type="checkbox" id="allDayEvent" class="checkbox">
                        <label for="allDayEvent">종일 일정</label>
                    </div>
                </div>
                <div class="form-group">
                    <label for="eventCategory">카테고리</label>
                    <select id="eventCategory" class="form-select">
                        <!-- 카테고리 옵션들이 여기에 생성됩니다 -->
                    </select>
                </div>
                <div class="form-group">
                    <label>색상</label>
                    <div class="color-picker" id="colorPicker">
                        <!-- 색상 옵션들이 여기에 생성됩니다 -->
                    </div>
                </div>
                <div class="form-group">
                    <label for="reminderTime">알림</label>
                    <select id="reminderTime" class="form-select">
                        <option value="0">알림 없음</option>
                        <option value="5">5분 전</option>
                        <option value="15">15분 전</option>
                        <option value="30">30분 전</option>
                        <option value="60">1시간 전</option>
                        <option value="1440">1일 전</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="repeatType">반복</label>
                    <select id="repeatType" class="form-select">
                        <option value="none">반복 없음</option>
                        <option value="daily">매일</option>
                        <option value="weekly">매주</option>
                        <option value="monthly">매월</option>
                        <option value="yearly">매년</option>
                    </select>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="deleteEventBtn" style="display: none;">삭제</button>
                    <button type="button" class="btn btn-secondary" id="cancelBtn">취소</button>
                    <button type="submit" class="btn">저장</button>
                </div>
            </form>
        </div>
    </div>

    <!-- 카테고리 추가 모달 -->
    <div class="modal" id="categoryModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>카테고리 추가</h2>
                <button class="close-btn" id="closeCategoryModal">&times;</button>
            </div>
            <form id="categoryForm">
                <div class="form-group">
                    <label for="categoryName">카테고리 이름 *</label>
                    <input type="text" id="categoryName" class="form-input" required>
                </div>
                <div class="form-group">
                    <label>색상</label>
                    <div class="color-picker" id="categoryColorPicker">
                        <!-- 색상 옵션들이 여기에 생성됩니다 -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancelCategoryBtn">취소</button>
                    <button type="submit" class="btn">추가</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // 전역 변수
        let currentDate = new Date();
        let currentView = 'month';
        let events = JSON.parse(localStorage.getItem('calendarEvents')) || [];
        let categories = JSON.parse(localStorage.getItem('calendarCategories')) || [
            { id: 'work', name: '업무', color: '#1976d2', active: true },
            { id: 'personal', name: '개인', color: '#4caf50', active: true },
            { id: 'family', name: '가족', color: '#ff9800', active: true },
            { id: 'health', name: '건강', color: '#e91e63', active: true }
        ];
        let editingEventId = null;
        let reminderTimeouts = [];

        // 색상 팔레트
        const colorPalette = [
            '#1976d2', '#4caf50', '#ff9800', '#e91e63',
            '#9c27b0', '#673ab7', '#3f51b5', '#2196f3',
            '#00bcd4', '#009688', '#8bc34a', '#cddc39',
            '#ffeb3b', '#ffc107', '#ff5722', '#795548'
        ];

        // DOM 요소 참조
        const elements = {
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            todayBtn: document.getElementById('todayBtn'),
            currentDateEl: document.getElementById('currentDate'),
            monthView: document.getElementById('monthView'),
            weekView: document.getElementById('weekView'),
            dayView: document.getElementById('dayView'),
            viewBtns: document.querySelectorAll('.view-btn'),
            eventModal: document.getElementById('eventModal'),
            eventForm: document.getElementById('eventForm'),
            addEventBtn: document.getElementById('addEventBtn'),
            closeModal: document.getElementById('closeModal'),
            deleteEventBtn: document.getElementById('deleteEventBtn'),
            cancelBtn: document.getElementById('cancelBtn'),
            categoryModal: document.getElementById('categoryModal'),
            categoryForm: document.getElementById('categoryForm'),
            addCategoryBtn: document.getElementById('addCategoryBtn'),
            closeCategoryModal: document.getElementById('closeCategoryModal'),
            cancelCategoryBtn: document.getElementById('cancelCategoryBtn'),
            searchInput: document.getElementById('searchInput'),
            themeToggle: document.getElementById('themeToggle'),
            exportBtn: document.getElementById('exportBtn'),
            importBtn: document.getElementById('importBtn'),
            importFile: document.getElementById('importFile'),
            categoryList: document.getElementById('categoryList'),
            miniCalendarGrid: document.getElementById('miniCalendarGrid'),
            miniCalendarTitle: document.getElementById('miniCalendarTitle'),
            miniPrevBtn: document.getElementById('miniPrevBtn'),
            miniNextBtn: document.getElementById('miniNextBtn')
        };

        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            // 이벤트 리스너 등록
            registerEventListeners();
            
            // 카테고리 렌더링
            renderCategories();
            
            // 색상 피커 초기화
            initializeColorPickers();
            
            // 초기 캘린더 렌더링
            renderCalendar();
            
            // 미니 캘린더 렌더링
            renderMiniCalendar();
            
            // 알림 권한 요청
            requestNotificationPermission();
            
            // 알림 스케줄 설정
            scheduleReminders();
            
            // 테마 초기화
            initializeTheme();
            
            console.log('스마트 캘린더가 초기화되었습니다.');
        }

        function registerEventListeners() {
            // 네비게이션 버튼
            elements.prevBtn.addEventListener('click', () => navigateCalendar(-1));
            elements.nextBtn.addEventListener('click', () => navigateCalendar(1));
            elements.todayBtn.addEventListener('click', goToToday);

            // 뷰 전환 버튼
            elements.viewBtns.forEach(btn => {
                btn.addEventListener('click', () => switchView(btn.dataset.view));
            });

            // 일정 추가 버튼
            elements.addEventBtn.addEventListener('click', () => openEventModal());

            // 모달 관련
            elements.closeModal.addEventListener('click', closeEventModal);
            elements.cancelBtn.addEventListener('click', closeEventModal);
            elements.deleteEventBtn.addEventListener('click', deleteEvent);
            elements.eventForm.addEventListener('submit', saveEvent);

            // 카테고리 모달
            elements.addCategoryBtn.addEventListener('click', () => openCategoryModal());
            elements.closeCategoryModal.addEventListener('click', closeCategoryModal);
            elements.cancelCategoryBtn.addEventListener('click', closeCategoryModal);
            elements.categoryForm.addEventListener('submit', saveCategory);

            // 검색
            elements.searchInput.addEventListener('input', debounce(searchEvents, 300));

            // 테마 토글
            elements.themeToggle.addEventListener('click', toggleTheme);

            // 내보내기/가져오기
            elements.exportBtn.addEventListener('click', exportData);
            elements.importBtn.addEventListener('click', () => elements.importFile.click());
            elements.importFile.addEventListener('change', importData);

            // 미니 캘린더
            elements.miniPrevBtn.addEventListener('click', () => navigateMiniCalendar(-1));
            elements.miniNextBtn.addEventListener('click', () => navigateMiniCalendar(1));

            // 모달 외부 클릭 시 닫기
            elements.eventModal.addEventListener('click', (e) => {
                if (e.target === elements.eventModal) closeEventModal();
            });
            elements.categoryModal.addEventListener('click', (e) => {
                if (e.target === elements.categoryModal) closeCategoryModal();
            });

            // 종일 일정 체크박스
            document.getElementById('allDayEvent').addEventListener('change', toggleAllDay);

            // 키보드 단축키
            document.addEventListener('keydown', handleKeyboardShortcuts);

            // 필터 이벤트
            document.getElementById('allDayFilter').addEventListener('change', renderCalendar);
            document.getElementById('reminderFilter').addEventListener('change', renderCalendar);
        }

        function navigateCalendar(direction) {
            switch (currentView) {
                case 'month':
                    currentDate.setMonth(currentDate.getMonth() + direction);
                    break;
                case 'week':
                    currentDate.setDate(currentDate.getDate() + (direction * 7));
                    break;
                case 'day':
                    currentDate.setDate(currentDate.getDate() + direction);
                    break;
            }
            renderCalendar();
            renderMiniCalendar();
        }

        function navigateMiniCalendar(direction) {
            const miniDate = new Date(currentDate);
            miniDate.setMonth(miniDate.getMonth() + direction);
            currentDate = miniDate;
            renderCalendar();
            renderMiniCalendar();
        }

        function goToToday() {
            currentDate = new Date();
            renderCalendar();
            renderMiniCalendar();
        }

        function switchView(view) {
            currentView = view;
            
            // 활성 버튼 업데이트
            elements.viewBtns.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });

            // 뷰 컨테이너 표시/숨김
            elements.monthView.classList.toggle('hidden', view !== 'month');
            elements.weekView.classList.toggle('hidden', view !== 'week');
            elements.dayView.classList.toggle('hidden', view !== 'day');

            renderCalendar();
        }

        function renderCalendar() {
            updateCurrentDateDisplay();
            
            switch (currentView) {
                case 'month':
                    renderMonthView();
                    break;
                case 'week':
                    renderWeekView();
                    break;
                case 'day':
                    renderDayView();
                    break;
            }
        }

        function updateCurrentDateDisplay() {
            const options = { year: 'numeric', month: 'long' };
            if (currentView === 'day') {
                options.day = 'numeric';
                options.weekday = 'long';
            } else if (currentView === 'week') {
                const weekStart = getWeekStart(currentDate);
                const weekEnd = getWeekEnd(currentDate);
                elements.currentDateEl.textContent = 
                    `${weekStart.getFullYear()}년 ${weekStart.getMonth() + 1}월 ${weekStart.getDate()}일 - ${weekEnd.getMonth() + 1}월 ${weekEnd.getDate()}일`;
                return;
            }
            elements.currentDateEl.textContent = currentDate.toLocaleDateString('ko-KR', options);
        }

        function renderMonthView() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            // 월의 첫 날과 마지막 날
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            
            // 달력 시작일 (월요일부터 시작)
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - ((firstDay.getDay() + 6) % 7));
            
            elements.monthView.innerHTML = '';
            
            // 요일 헤더
            const dayHeaders = ['월', '화', '수', '목', '금', '토', '일'];
            dayHeaders.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                dayHeader.textContent = day;
                elements.monthView.appendChild(dayHeader);
            });
            
            // 날짜 셀 생성
            const today = new Date();
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const dayCell = document.createElement('div');
                dayCell.className = 'day-cell';
                dayCell.dataset.date = cellDate.toISOString().split('T')[0];
                
                // 클래스 추가
                if (cellDate.getMonth() !== month) {
                    dayCell.classList.add('other-month');
                }
                if (cellDate.toDateString() === today.toDateString()) {
                    dayCell.classList.add('today');
                }
                
                // 날짜 번호
                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = cellDate.getDate();
                dayCell.appendChild(dayNumber);
                
                // 이벤트 목록
                const eventList = document.createElement('div');
                eventList.className = 'event-list';
                
                const dayEvents = getEventsForDate(cellDate);
                const filteredEvents = filterEvents(dayEvents);
                
                // 각 일정에 대해 해당 날짜에서 시작하는지 확인
                const eventsToShow = filteredEvents.slice(0, 3).map(event => {
                    const eventStart = new Date(event.startDate);
                    const eventStartDate = eventStart.toISOString().split('T')[0];
                    const cellDateStr = cellDate.toISOString().split('T')[0];
                    
                    return {
                        ...event,
                        isStartDate: eventStartDate === cellDateStr,
                        isContinuation: eventStartDate !== cellDateStr
                    };
                });
                
                eventsToShow.forEach(eventInfo => {
                    const eventItem = document.createElement('div');
                    eventItem.className = 'event-item';
                    
                    // 연속 일정인 경우 스타일 변경
                    if (eventInfo.isContinuation) {
                        eventItem.style.backgroundColor = eventInfo.color;
                        eventItem.style.opacity = '0.7';
                        eventItem.style.borderLeft = `3px solid ${eventInfo.color}`;
                        eventItem.textContent = `⋯ ${eventInfo.title}`;
                        // 연속 일정은 드래그 불가
                        eventItem.draggable = false;
                    } else {
                        eventItem.style.backgroundColor = eventInfo.color;
                        eventItem.textContent = eventInfo.title;
                        // 시작 날짜에서만 드래그 가능
                        eventItem.draggable = true;
                        eventItem.addEventListener('dragstart', (e) => handleDragStart(e, eventInfo));
                    }
                    
                    eventItem.dataset.eventId = eventInfo.id;
                    eventItem.addEventListener('click', (e) => {
                        e.stopPropagation();
                        editEvent(eventInfo.id);
                    });
                    
                    eventList.appendChild(eventItem);
                });
                
                if (filteredEvents.length > 3) {
                    const moreItem = document.createElement('div');
                    moreItem.className = 'event-item';
                    moreItem.style.backgroundColor = '#999';
                    moreItem.textContent = `+${filteredEvents.length - 3}개 더`;
                    eventList.appendChild(moreItem);
                }
                
                dayCell.appendChild(eventList);
                
                // 클릭 이벤트
                dayCell.addEventListener('click', () => openEventModal(cellDate));
                dayCell.addEventListener('dragover', handleDragOver);
                dayCell.addEventListener('drop', (e) => handleDrop(e, cellDate));
                
                elements.monthView.appendChild(dayCell);
            }
        }

        function renderWeekView() {
            // 주간 뷰 구현
            const weekStart = getWeekStart(currentDate);
            elements.weekView.innerHTML = '';
            
            // 시간 슬롯 헤더
            const timeHeader = document.createElement('div');
            timeHeader.className = 'time-slot';
            elements.weekView.appendChild(timeHeader);
            
            // 요일 헤더
            for (let i = 0; i < 7; i++) {
                const date = new Date(weekStart);
                date.setDate(weekStart.getDate() + i);
                
                const dayHeader = document.createElement('div');
                dayHeader.className = 'day-header';
                dayHeader.textContent = `${date.getMonth() + 1}/${date.getDate()} (${['일', '월', '화', '수', '목', '금', '토'][date.getDay()]})`;
                elements.weekView.appendChild(dayHeader);
            }
            
            // 시간별 행 생성
            for (let hour = 0; hour < 24; hour++) {
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot';
                timeSlot.textContent = `${hour.toString().padStart(2, '0')}:00`;
                elements.weekView.appendChild(timeSlot);
                
                for (let day = 0; day < 7; day++) {
                    const hourCell = document.createElement('div');
                    hourCell.className = 'hour-cell';
                    
                    const cellDate = new Date(weekStart);
                    cellDate.setDate(weekStart.getDate() + day);
                    cellDate.setHours(hour, 0, 0, 0);
                    
                    hourCell.dataset.date = cellDate.toISOString();
                    hourCell.addEventListener('click', () => openEventModal(cellDate));
                    
                    elements.weekView.appendChild(hourCell);
                }
            }
        }

        function renderDayView() {
            // 일간 뷰 구현
            elements.dayView.innerHTML = '';
            
            const dayStart = new Date(currentDate);
            dayStart.setHours(0, 0, 0, 0);
            
            // 시간별 행 생성 (시간 라벨)
            for (let hour = 0; hour < 24; hour++) {
                const timeSlot = document.createElement('div');
                timeSlot.className = 'time-slot';
                timeSlot.textContent = `${hour.toString().padStart(2, '0')}:00`;
                elements.dayView.appendChild(timeSlot);
                
                const hourCell = document.createElement('div');
                hourCell.className = 'hour-cell';
                
                const cellDate = new Date(dayStart);
                cellDate.setHours(hour, 0, 0, 0);
                
                hourCell.dataset.date = cellDate.toISOString();
                hourCell.addEventListener('click', () => openEventModal(cellDate));
                
                elements.dayView.appendChild(hourCell);
            }
            
            // 이벤트 컨테이너 생성
            const eventContainer = document.createElement('div');
            eventContainer.className = 'day-view-container';
            eventContainer.style.position = 'absolute';
            eventContainer.style.top = '0';
            eventContainer.style.left = '61px'; // 시간 슬롯 너비만큼 이동
            eventContainer.style.right = '0';
            eventContainer.style.height = `${24 * 60}px`; // 24시간 * 60px per hour
            eventContainer.style.pointerEvents = 'none';
            
            // 빈 공간 클릭으로 이벤트 생성
            eventContainer.addEventListener('click', (e) => {
                const rect = eventContainer.getBoundingClientRect();
                const y = e.clientY - rect.top;
                const minutes = Math.floor(y);
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                
                if (hours >= 0 && hours < 24) {
                    const clickDate = new Date(dayStart);
                    clickDate.setHours(hours, mins, 0, 0);
                    openEventModal(clickDate);
                }
            });
            eventContainer.style.pointerEvents = 'auto';
            
            // 부모 컨테이너에 relative 포지션 설정
            elements.dayView.style.position = 'relative';
            elements.dayView.appendChild(eventContainer);
            
            // 하루의 모든 이벤트 가져오기
            const dayEvents = getEventsForDay(dayStart);
            const filteredEvents = filterEvents(dayEvents);
            
            // 이벤트 겹침 처리 및 렌더링
            renderDayEvents(filteredEvents, eventContainer);
        }

        function renderMiniCalendar() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            elements.miniCalendarTitle.textContent = `${year}년 ${month + 1}월`;
            elements.miniCalendarGrid.innerHTML = '';
            
            // 요일 헤더
            const dayHeaders = ['월', '화', '수', '목', '금', '토', '일'];
            dayHeaders.forEach(day => {
                const dayElement = document.createElement('div');
                dayElement.className = 'mini-calendar-day';
                dayElement.style.fontWeight = 'bold';
                dayElement.style.color = 'var(--text-secondary)';
                dayElement.textContent = day;
                elements.miniCalendarGrid.appendChild(dayElement);
            });
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - ((firstDay.getDay() + 6) % 7));
            
            const today = new Date();
            
            for (let i = 0; i < 42; i++) {
                const cellDate = new Date(startDate);
                cellDate.setDate(startDate.getDate() + i);
                
                const dayElement = document.createElement('div');
                dayElement.className = 'mini-calendar-day';
                dayElement.textContent = cellDate.getDate();
                
                if (cellDate.getMonth() !== month) {
                    dayElement.classList.add('other-month');
                }
                if (cellDate.toDateString() === today.toDateString()) {
                    dayElement.classList.add('today');
                }
                
                dayElement.addEventListener('click', () => {
                    currentDate = new Date(cellDate);
                    renderCalendar();
                });
                
                elements.miniCalendarGrid.appendChild(dayElement);
            }
        }

        function getEventsForDate(date) {
            const dateStr = date.toISOString().split('T')[0];
            return events.filter(event => {
                const eventStart = new Date(event.startDate).toISOString().split('T')[0];
                const eventEnd = new Date(event.endDate).toISOString().split('T')[0];
                return dateStr >= eventStart && dateStr <= eventEnd;
            });
        }

        function getEventsForHour(date) {
            return events.filter(event => {
                const eventStart = new Date(event.startDate);
                const eventEnd = new Date(event.endDate);
                const hourStart = new Date(date);
                const hourEnd = new Date(date);
                hourEnd.setHours(hourEnd.getHours() + 1);
                
                return (eventStart < hourEnd && eventEnd > hourStart);
            });
        }

        function getEventsForDay(date) {
            const dayStart = new Date(date);
            dayStart.setHours(0, 0, 0, 0);
            const dayEnd = new Date(date);
            dayEnd.setHours(23, 59, 59, 999);
            
            return events.filter(event => {
                const eventStart = new Date(event.startDate);
                const eventEnd = new Date(event.endDate);
                
                return (eventStart < dayEnd && eventEnd > dayStart);
            });
        }

        function renderDayEvents(dayEvents, container) {
            if (dayEvents.length === 0) return;
            
            // 이벤트를 시작 시간으로 정렬
            dayEvents.sort((a, b) => new Date(a.startDate) - new Date(b.startDate));
            
            // 각 이벤트의 위치 정보 계산
            const eventPositions = calculateEventPositions(dayEvents);
            
            // 이벤트 렌더링
            eventPositions.forEach(eventInfo => {
                const eventElement = createDayEventElement(eventInfo);
                container.appendChild(eventElement);
            });
        }

        function calculateEventPositions(dayEvents) {
            const eventPositions = [];
            const columns = [];
            
            dayEvents.forEach(event => {
                const eventStart = new Date(event.startDate);
                const eventEnd = new Date(event.endDate);
                
                // 시간을 분으로 변환 (하루의 시작부터)
                const startMinutes = eventStart.getHours() * 60 + eventStart.getMinutes();
                const endMinutes = eventEnd.getHours() * 60 + eventEnd.getMinutes();
                const duration = endMinutes - startMinutes;
                
                // 겹치는 이벤트 찾기
                let columnIndex = 0;
                let overlappingEvents = [];
                
                // 기존 컬럼들과 겹치는지 확인
                for (let i = 0; i < columns.length; i++) {
                    let hasOverlap = false;
                    for (let j = 0; j < columns[i].length; j++) {
                        const existingEvent = columns[i][j];
                        if (eventsOverlap(event, existingEvent.event)) {
                            hasOverlap = true;
                            overlappingEvents.push(existingEvent);
                            break;
                        }
                    }
                    if (!hasOverlap) {
                        columnIndex = i;
                        break;
                    }
                    if (i === columns.length - 1) {
                        columnIndex = columns.length;
                    }
                }
                
                // 새 컬럼이 필요한 경우
                if (columnIndex >= columns.length) {
                    columns.push([]);
                }
                
                const eventInfo = {
                    event: event,
                    startMinutes: startMinutes,
                    duration: duration,
                    columnIndex: columnIndex,
                    overlappingEvents: overlappingEvents
                };
                
                columns[columnIndex].push(eventInfo);
                eventPositions.push(eventInfo);
            });
            
            // 각 이벤트의 너비와 위치 계산
            eventPositions.forEach(eventInfo => {
                const maxColumns = getMaxOverlappingColumns(eventInfo, eventPositions);
                eventInfo.width = 100 / maxColumns;
                eventInfo.left = eventInfo.columnIndex * eventInfo.width;
            });
            
            return eventPositions;
        }

        function eventsOverlap(event1, event2) {
            const start1 = new Date(event1.startDate);
            const end1 = new Date(event1.endDate);
            const start2 = new Date(event2.startDate);
            const end2 = new Date(event2.endDate);
            
            return start1 < end2 && start2 < end1;
        }

        function getMaxOverlappingColumns(eventInfo, allEvents) {
            let maxColumns = 1;
            
            allEvents.forEach(otherEvent => {
                if (eventInfo.event.id !== otherEvent.event.id && 
                    eventsOverlap(eventInfo.event, otherEvent.event)) {
                    maxColumns = Math.max(maxColumns, otherEvent.columnIndex + 1);
                }
            });
            
            return maxColumns;
        }

        function createDayEventElement(eventInfo) {
            const eventElement = document.createElement('div');
            eventElement.className = 'day-event-item';
            if (eventInfo.overlappingEvents.length > 0) {
                eventElement.classList.add('overlapping');
            }
            
            // 스타일 설정
            eventElement.style.backgroundColor = eventInfo.event.color;
            eventElement.style.top = `${eventInfo.startMinutes}px`;
            eventElement.style.height = `${Math.max(eventInfo.duration, 20)}px`; // 최소 높이 20px
            eventElement.style.left = `${eventInfo.left}%`;
            eventElement.style.width = `${eventInfo.width - 0.5}%`; // 약간의 간격
            eventElement.style.pointerEvents = 'auto';
            
            // 이벤트 정보 표시
            const timeText = formatEventTime(eventInfo.event);
            eventElement.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 2px;">${eventInfo.event.title}</div>
                <div style="font-size: 0.65rem; opacity: 0.9;">${timeText}</div>
            `;
            
            // 이벤트 리스너
            eventElement.dataset.eventId = eventInfo.event.id;
            eventElement.addEventListener('click', (e) => {
                e.stopPropagation();
                editEvent(eventInfo.event.id);
            });
            
            // 드래그 기능
            eventElement.draggable = true;
            eventElement.addEventListener('dragstart', (e) => handleDragStart(e, eventInfo.event));
            
            return eventElement;
        }

        function formatEventTime(event) {
            const start = new Date(event.startDate);
            const end = new Date(event.endDate);
            
            if (event.isAllDay) {
                return '종일';
            }
            
            const startTime = `${start.getHours().toString().padStart(2, '0')}:${start.getMinutes().toString().padStart(2, '0')}`;
            const endTime = `${end.getHours().toString().padStart(2, '0')}:${end.getMinutes().toString().padStart(2, '0')}`;
            
            return `${startTime} - ${endTime}`;
        }

        function filterEvents(eventList) {
            const allDayFilter = document.getElementById('allDayFilter').checked;
            const reminderFilter = document.getElementById('reminderFilter').checked;
            const activeCategories = categories.filter(cat => cat.active).map(cat => cat.id);
            
            return eventList.filter(event => {
                // 카테고리 필터
                if (!activeCategories.includes(event.category)) return false;
                
                // 종일 일정 필터
                if (allDayFilter && !event.isAllDay) return false;
                
                // 알림 필터
                if (reminderFilter && (!event.reminder || event.reminder === 0)) return false;
                
                return true;
            });
        }

        function getWeekStart(date) {
            const start = new Date(date);
            const day = start.getDay();
            const diff = start.getDate() - day + (day === 0 ? -6 : 1);
            start.setDate(diff);
            start.setHours(0, 0, 0, 0);
            return start;
        }

        function getWeekEnd(date) {
            const end = getWeekStart(date);
            end.setDate(end.getDate() + 6);
            end.setHours(23, 59, 59, 999);
            return end;
        }

        function openEventModal(date = null, eventId = null) {
            editingEventId = eventId;
            
            if (eventId) {
                // 기존 이벤트 편집
                const event = events.find(e => e.id === eventId);
                if (event) {
                    document.getElementById('modalTitle').textContent = '일정 편집';
                    document.getElementById('eventTitle').value = event.title;
                    document.getElementById('eventDescription').value = event.description || '';
                    document.getElementById('eventStartDate').value = formatDateTimeLocal(event.startDate);
                    document.getElementById('eventEndDate').value = formatDateTimeLocal(event.endDate);
                    document.getElementById('allDayEvent').checked = event.isAllDay || false;
                    document.getElementById('eventCategory').value = event.category;
                    document.getElementById('reminderTime').value = event.reminder || 0;
                    document.getElementById('repeatType').value = event.repeat || 'none';
                    
                    // 색상 선택
                    selectColor(event.color);
                    
                    elements.deleteEventBtn.style.display = 'block';
                }
            } else {
                // 새 이벤트 추가
                document.getElementById('modalTitle').textContent = '일정 추가';
                elements.eventForm.reset();
                
                if (date) {
                    const startDate = new Date(date);
                    const endDate = new Date(date);
                    endDate.setHours(endDate.getHours() + 1);
                    
                    document.getElementById('eventStartDate').value = formatDateTimeLocal(startDate);
                    document.getElementById('eventEndDate').value = formatDateTimeLocal(endDate);
                }
                
                // 기본 색상 선택
                selectColor(colorPalette[0]);
                
                elements.deleteEventBtn.style.display = 'none';
            }
            
            // 카테고리 옵션 업데이트
            updateCategoryOptions();
            
            elements.eventModal.classList.add('show');
        }

        function closeEventModal() {
            elements.eventModal.classList.remove('show');
            editingEventId = null;
            elements.eventForm.reset();
        }

        function saveEvent(e) {
            e.preventDefault();
            
            const formData = new FormData(elements.eventForm);
            const eventData = {
                id: editingEventId || generateId(),
                title: document.getElementById('eventTitle').value,
                description: document.getElementById('eventDescription').value,
                startDate: document.getElementById('eventStartDate').value,
                endDate: document.getElementById('eventEndDate').value,
                isAllDay: document.getElementById('allDayEvent').checked,
                category: document.getElementById('eventCategory').value,
                color: getSelectedColor(),
                reminder: parseInt(document.getElementById('reminderTime').value),
                repeat: document.getElementById('repeatType').value
            };
            
            // 유효성 검사
            if (!eventData.title.trim()) {
                showNotification('제목을 입력해주세요.', 'error');
                return;
            }
            
            if (new Date(eventData.startDate) >= new Date(eventData.endDate)) {
                showNotification('종료 시간은 시작 시간보다 늦어야 합니다.', 'error');
                return;
            }
            
            if (editingEventId) {
                // 기존 이벤트 업데이트
                const index = events.findIndex(e => e.id === editingEventId);
                if (index !== -1) {
                    events[index] = eventData;
                    showNotification('일정이 수정되었습니다.', 'success');
                }
            } else {
                // 새 이벤트 추가
                events.push(eventData);
                showNotification('일정이 추가되었습니다.', 'success');
            }
            
            // 반복 일정 처리
            if (eventData.repeat !== 'none') {
                generateRecurringEvents(eventData);
            }
            
            saveEventsToStorage();
            renderCalendar();
            scheduleReminders();
            closeEventModal();
        }

        function deleteEvent() {
            if (editingEventId && confirm('정말로 이 일정을 삭제하시겠습니까?')) {
                events = events.filter(e => e.id !== editingEventId);
                saveEventsToStorage();
                renderCalendar();
                closeEventModal();
                showNotification('일정이 삭제되었습니다.', 'success');
            }
        }

        function editEvent(eventId) {
            openEventModal(null, eventId);
        }

        function generateRecurringEvents(baseEvent) {
            const startDate = new Date(baseEvent.startDate);
            const endDate = new Date(baseEvent.endDate);
            const duration = endDate.getTime() - startDate.getTime();
            
            const occurrences = 10; // 최대 10회 반복
            
            for (let i = 1; i < occurrences; i++) {
                const newStartDate = new Date(startDate);
                
                switch (baseEvent.repeat) {
                    case 'daily':
                        newStartDate.setDate(startDate.getDate() + i);
                        break;
                    case 'weekly':
                        newStartDate.setDate(startDate.getDate() + (i * 7));
                        break;
                    case 'monthly':
                        newStartDate.setMonth(startDate.getMonth() + i);
                        break;
                    case 'yearly':
                        newStartDate.setFullYear(startDate.getFullYear() + i);
                        break;
                }
                
                const newEndDate = new Date(newStartDate.getTime() + duration);
                
                const recurringEvent = {
                    ...baseEvent,
                    id: generateId(),
                    startDate: newStartDate.toISOString(),
                    endDate: newEndDate.toISOString(),
                    isRecurring: true,
                    parentId: baseEvent.id
                };
                
                events.push(recurringEvent);
            }
        }

        function renderCategories() {
            elements.categoryList.innerHTML = '';
            
            categories.forEach(category => {
                const categoryItem = document.createElement('div');
                categoryItem.className = `category-item ${category.active ? 'active' : ''}`;
                categoryItem.innerHTML = `
                    <div class="category-color" style="background-color: ${category.color}"></div>
                    <span>${category.name}</span>
                `;
                
                categoryItem.addEventListener('click', () => {
                    category.active = !category.active;
                    categoryItem.classList.toggle('active', category.active);
                    saveCategoriestoStorage();
                    renderCalendar();
                });
                
                elements.categoryList.appendChild(categoryItem);
            });
        }

        function openCategoryModal() {
            elements.categoryModal.classList.add('show');
            initializeCategoryColorPicker();
        }

        function closeCategoryModal() {
            elements.categoryModal.classList.remove('show');
            elements.categoryForm.reset();
        }

        function saveCategory(e) {
            e.preventDefault();
            
            const name = document.getElementById('categoryName').value.trim();
            const color = getCategorySelectedColor();
            
            if (!name) {
                showNotification('카테고리 이름을 입력해주세요.', 'error');
                return;
            }
            
            if (categories.some(cat => cat.name === name)) {
                showNotification('이미 존재하는 카테고리 이름입니다.', 'error');
                return;
            }
            
            const newCategory = {
                id: generateId(),
                name: name,
                color: color,
                active: true
            };
            
            categories.push(newCategory);
            saveCategoriestoStorage();
            renderCategories();
            updateCategoryOptions();
            closeCategoryModal();
            showNotification('카테고리가 추가되었습니다.', 'success');
        }

        function initializeColorPickers() {
            const colorPicker = document.getElementById('colorPicker');
            const categoryColorPicker = document.getElementById('categoryColorPicker');
            
            colorPalette.forEach(color => {
                // 이벤트 색상 피커
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.dataset.color = color;
                colorOption.addEventListener('click', () => selectColor(color));
                colorPicker.appendChild(colorOption);
                
                // 카테고리 색상 피커
                const categoryColorOption = document.createElement('div');
                categoryColorOption.className = 'color-option';
                categoryColorOption.style.backgroundColor = color;
                categoryColorOption.dataset.color = color;
                categoryColorOption.addEventListener('click', () => selectCategoryColor(color));
                categoryColorPicker.appendChild(categoryColorOption);
            });
        }

        function initializeCategoryColorPicker() {
            const categoryColorPicker = document.getElementById('categoryColorPicker');
            selectCategoryColor(colorPalette[0]);
        }

        function selectColor(color) {
            document.querySelectorAll('#colorPicker .color-option').forEach(option => {
                option.classList.toggle('selected', option.dataset.color === color);
            });
        }

        function selectCategoryColor(color) {
            document.querySelectorAll('#categoryColorPicker .color-option').forEach(option => {
                option.classList.toggle('selected', option.dataset.color === color);
            });
        }

        function getSelectedColor() {
            const selected = document.querySelector('#colorPicker .color-option.selected');
            return selected ? selected.dataset.color : colorPalette[0];
        }

        function getCategorySelectedColor() {
            const selected = document.querySelector('#categoryColorPicker .color-option.selected');
            return selected ? selected.dataset.color : colorPalette[0];
        }

        function updateCategoryOptions() {
            const select = document.getElementById('eventCategory');
            select.innerHTML = '';
            
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category.id;
                option.textContent = category.name;
                select.appendChild(option);
            });
        }

        function searchEvents() {
            const query = elements.searchInput.value.toLowerCase().trim();
            
            if (!query) {
                renderCalendar();
                return;
            }
            
            const filteredEvents = events.filter(event => {
                return event.title.toLowerCase().includes(query) ||
                       (event.description && event.description.toLowerCase().includes(query));
            });
            
            // 검색 결과 표시 (간단한 구현)
            console.log('검색 결과:', filteredEvents);
            renderCalendar(); // 실제로는 검색 결과만 표시하도록 수정 필요
        }

        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        showNotification('알림이 허용되었습니다.', 'success');
                    }
                });
            }
        }

        function scheduleReminders() {
            // 기존 알림 타이머 제거
            reminderTimeouts.forEach(timeout => clearTimeout(timeout));
            reminderTimeouts = [];
            
            const now = new Date();
            
            events.forEach(event => {
                if (event.reminder && event.reminder > 0) {
                    const eventStart = new Date(event.startDate);
                    const reminderTime = new Date(eventStart.getTime() - (event.reminder * 60 * 1000));
                    
                    if (reminderTime > now) {
                        const timeout = setTimeout(() => {
                            showEventReminder(event);
                        }, reminderTime.getTime() - now.getTime());
                        
                        reminderTimeouts.push(timeout);
                    }
                }
            });
        }

        function showEventReminder(event) {
            const message = `${event.title} 일정이 ${event.reminder}분 후에 시작됩니다.`;
            
            // 브라우저 알림
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('일정 알림', {
                    body: message,
                    icon: '📅'
                });
            }
            
            // 인앱 알림
            showNotification(message, 'warning');
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <div class="notification-header">
                    <span class="notification-title">${type === 'success' ? '성공' : type === 'error' ? '오류' : '알림'}</span>
                    <button class="close-btn" onclick="this.parentElement.parentElement.remove()">&times;</button>
                </div>
                <div class="notification-content">${message}</div>
            `;
            
            document.body.appendChild(notification);
            
            // 3초 후 자동 제거
            setTimeout(() => {
                if (notification.parentElement) {
                    notification.remove();
                }
            }, 3000);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
        }

        function initializeTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.documentElement.setAttribute('data-theme', savedTheme);
        }

        function toggleAllDay() {
            const isAllDay = document.getElementById('allDayEvent').checked;
            const startDateInput = document.getElementById('eventStartDate');
            const endDateInput = document.getElementById('eventEndDate');
            
            if (isAllDay) {
                // 종일 일정으로 변경
                const startDate = new Date(startDateInput.value);
                const endDate = new Date(endDateInput.value);
                
                startDate.setHours(0, 0, 0, 0);
                endDate.setHours(23, 59, 59, 999);
                
                startDateInput.value = formatDateTimeLocal(startDate);
                endDateInput.value = formatDateTimeLocal(endDate);
            }
        }

        function handleKeyboardShortcuts(e) {
            // Ctrl/Cmd + N: 새 일정
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                e.preventDefault();
                openEventModal();
            }
            
            // Ctrl/Cmd + T: 오늘로 이동
            if ((e.ctrlKey || e.metaKey) && e.key === 't') {
                e.preventDefault();
                goToToday();
            }
            
            // 방향키: 네비게이션
            if (e.key === 'ArrowLeft' && !e.target.matches('input, textarea')) {
                e.preventDefault();
                navigateCalendar(-1);
            }
            
            if (e.key === 'ArrowRight' && !e.target.matches('input, textarea')) {
                e.preventDefault();
                navigateCalendar(1);
            }
            
            // ESC: 모달 닫기
            if (e.key === 'Escape') {
                if (elements.eventModal.classList.contains('show')) {
                    closeEventModal();
                }
                if (elements.categoryModal.classList.contains('show')) {
                    closeCategoryModal();
                }
            }
        }

        function handleDragStart(e, event) {
            // 드래그 데이터에 이벤트 정보 저장
            const dragData = {
                eventId: event.id,
                originalStartDate: event.startDate,
                originalEndDate: event.endDate
            };
            
            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            e.target.classList.add('dragging');
            
            // 같은 이벤트의 다른 인스턴스들도 드래그 상태로 표시
            document.querySelectorAll(`[data-event-id="${event.id}"]`).forEach(el => {
                el.classList.add('dragging');
            });
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drop-zone');
        }

        function handleDrop(e, targetDate) {
            e.preventDefault();
            e.currentTarget.classList.remove('drop-zone');
            
            try {
                // 드래그 데이터 파싱
                const dragDataStr = e.dataTransfer.getData('text/plain');
                let dragData;
                
                // 이전 버전 호환성 체크
                try {
                    dragData = JSON.parse(dragDataStr);
                } catch {
                    // 이전 방식 (단순 ID)인 경우
                    dragData = { eventId: dragDataStr };
                }
                
                const eventId = dragData.eventId;
                const event = events.find(e => e.id === eventId);
                
                if (!event) {
                    console.warn('드래그된 이벤트를 찾을 수 없습니다:', eventId);
                    return;
                }
                
                // 원본 일정 정보
                const originalStart = new Date(event.startDate);
                const originalEnd = new Date(event.endDate);
                const duration = originalEnd.getTime() - originalStart.getTime();
                
                // 새로운 시작 날짜 설정
                const newStart = new Date(targetDate);
                
                // 종일 일정인 경우 처리
                if (event.isAllDay) {
                    newStart.setHours(0, 0, 0, 0);
                    const newEnd = new Date(newStart.getTime() + duration);
                    
                    event.startDate = newStart.toISOString();
                    event.endDate = newEnd.toISOString();
                } else {
                    // 일반 일정의 경우 시간 유지
                    newStart.setHours(originalStart.getHours(), originalStart.getMinutes(), originalStart.getSeconds(), originalStart.getMilliseconds());
                    const newEnd = new Date(newStart.getTime() + duration);
                    
                    event.startDate = newStart.toISOString();
                    event.endDate = newEnd.toISOString();
                }
                
                // 데이터 정합성 검증 및 저장
                validateAndSaveEvents();
                renderCalendar();
                showNotification('일정이 이동되었습니다.', 'success');
                
            } catch (error) {
                console.error('일정 이동 중 오류 발생:', error);
                showNotification('일정 이동 중 오류가 발생했습니다.', 'error');
            }
            
            // 드래그 상태 제거
            document.querySelectorAll('.dragging').forEach(el => {
                el.classList.remove('dragging');
            });
        }

        function validateAndSaveEvents() {
            // 중복 이벤트 제거 (같은 ID를 가진 이벤트가 여러 개 생성되는 것 방지)
            const uniqueEvents = [];
            const seenIds = new Set();
            
            events.forEach(evt => {
                if (evt && evt.id && !seenIds.has(evt.id)) {
                    // 필수 필드 검증
                    if (evt.title && evt.startDate && evt.endDate) {
                        seenIds.add(evt.id);
                        uniqueEvents.push(evt);
                    } else {
                        console.warn('잘못된 이벤트 데이터:', evt);
                    }
                }
            });
            
            events = uniqueEvents;
            saveEventsToStorage();
        }

        function exportData() {
            const data = {
                events: events,
                categories: categories,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `calendar_backup_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('데이터가 내보내기되었습니다.', 'success');
        }

        function importData(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.events && Array.isArray(data.events)) {
                        events = data.events;
                        saveEventsToStorage();
                    }
                    
                    if (data.categories && Array.isArray(data.categories)) {
                        categories = data.categories;
                        saveCategoriestoStorage();
                        renderCategories();
                        updateCategoryOptions();
                    }
                    
                    renderCalendar();
                    scheduleReminders();
                    showNotification('데이터가 가져오기되었습니다.', 'success');
                    
                } catch (error) {
                    showNotification('파일 형식이 올바르지 않습니다.', 'error');
                }
            };
            reader.readAsText(file);
            
            // 파일 입력 초기화
            e.target.value = '';
        }

        // 유틸리티 함수들
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        function formatDateTimeLocal(date) {
            const d = new Date(date);
            const year = d.getFullYear();
            const month = (d.getMonth() + 1).toString().padStart(2, '0');
            const day = d.getDate().toString().padStart(2, '0');
            const hours = d.getHours().toString().padStart(2, '0');
            const minutes = d.getMinutes().toString().padStart(2, '0');
            
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function saveEventsToStorage() {
            localStorage.setItem('calendarEvents', JSON.stringify(events));
        }

        function saveCategoriestoStorage() {
            localStorage.setItem('calendarCategories', JSON.stringify(categories));
        }

        // 접근성 개선
        function setupAccessibility() {
            // ARIA 라벨 추가
            elements.monthView.setAttribute('role', 'grid');
            elements.monthView.setAttribute('aria-label', '달력');
            
            // 키보드 네비게이션 지원
            document.addEventListener('keydown', (e) => {
                if (e.target.classList.contains('day-cell')) {
                    let targetCell = null;
                    
                    switch (e.key) {
                        case 'Enter':
                        case ' ':
                            e.preventDefault();
                            e.target.click();
                            break;
                        case 'ArrowLeft':
                            targetCell = e.target.previousElementSibling;
                            break;
                        case 'ArrowRight':
                            targetCell = e.target.nextElementSibling;
                            break;
                        case 'ArrowUp':
                            const upIndex = Array.from(e.target.parentElement.children).indexOf(e.target) - 7;
                            targetCell = e.target.parentElement.children[upIndex];
                            break;
                        case 'ArrowDown':
                            const downIndex = Array.from(e.target.parentElement.children).indexOf(e.target) + 7;
                            targetCell = e.target.parentElement.children[downIndex];
                            break;
                    }
                    
                    if (targetCell && targetCell.classList.contains('day-cell')) {
                        e.preventDefault();
                        targetCell.focus();
                    }
                }
            });
        }

        // 성능 최적화
        function optimizePerformance() {
            // 가상 스크롤링 (대량 데이터용)
            // 메모리 누수 방지
            window.addEventListener('beforeunload', () => {
                reminderTimeouts.forEach(timeout => clearTimeout(timeout));
            });
        }

        // 앱 초기화 후 접근성 및 성능 설정
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                setupAccessibility();
                optimizePerformance();
            }, 100);
        });
    </script>
</body>
</html>
