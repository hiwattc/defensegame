<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Throw Defense (Vanilla)</title>
  <style>
    html, body { margin:0; height:100%; background:#0b0f14; overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #wrap { position:relative; width:100%; height:100%; }
    canvas { display:block; width:100%; height:100%; }

    .hud {
      position:absolute; left:16px; top:16px;
      color:#e8f0ff; background:rgba(10,14,20,.55);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:10px 12px; backdrop-filter: blur(6px);
      line-height:1.35;
      max-width:min(520px, calc(100% - 32px));
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
      user-select:none;
    }
    .hud b { color:#fff; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill {
      display:inline-flex; gap:8px; align-items:center;
      padding:4px 10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.08);
      font-size:12px;
    }
    .center {
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      color:rgba(255,255,255,.75);
      text-align:center; user-select:none;
      pointer-events:none;
    }
    .crosshair {
      width:18px; height:18px; border-radius:50%;
      border:1px solid rgba(255,255,255,.6);
      position:relative; margin:0 auto 10px;
      box-shadow: 0 0 18px rgba(120,180,255,.25);
    }
    .crosshair:before, .crosshair:after {
      content:""; position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      background:rgba(255,255,255,.7);
    }
    .crosshair:before { width:10px; height:1px; }
    .crosshair:after  { width:1px; height:10px; }

    .overlay {
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(10,16,26,.75), rgba(0,0,0,.85));
      color:#eaf2ff;
    }
    .card {
      width:min(560px, calc(100% - 32px));
      padding:20px 18px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }
    .card h1 { margin:0 0 8px; font-size:18px; }
    .card p { margin:6px 0; color:rgba(255,255,255,.82); }
    .btn {
      margin-top:12px;
      display:inline-flex; align-items:center; justify-content:center;
      padding:10px 14px; border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(120,180,255,.16);
      color:#fff; cursor:pointer;
      font-weight:700;
    }
    .btn:hover { background:rgba(120,180,255,.22); }
    .rightHud { position:absolute; right:16px; top:16px; }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div class="hud">
    <div class="row">
      <span class="pill">HP: <b id="hp">100</b></span>
      <span class="pill">점수: <b id="score">0</b></span>
      <span class="pill">웨이브: <b id="wave">1</b></span>
      <span class="pill">남은 적: <b id="left">0</b></span>
    </div>
    <div style="margin-top:8px; font-size:12px; color:rgba(255,255,255,.75);">
      이동: <b>WASD</b> / 조준: <b>마우스</b> / 발사: <b>클릭</b> 또는 <b>Space</b> /
      리스타트: <b>R</b>
    </div>
  </div>

  <div class="hud rightHud">
    <div class="pill">투사체 속도: <b id="spd">34</b></div>
    <div class="pill">재장전: <b id="cd">0.22s</b></div>
  </div>

  <div class="center" id="hint" style="display:none;">
    <div class="crosshair"></div>
    <div style="font-size:13px;">클릭/Space로 공 던지기</div>
  </div>

  <div class="overlay" id="startOverlay">
    <div class="card">
      <h1>3D Throw Defense</h1>
      <p>적이 서서히 다가옵니다. 공을 던져 처치하세요.</p>
      <p style="opacity:.9;">브라우저 포인터락(마우스 고정)을 사용합니다. 시작 버튼을 누르면 마우스가 게임에 고정돼요.</p>
      <div class="btn" id="startBtn">시작하기</div>
      <p style="margin-top:10px; font-size:12px; opacity:.75;">
        팁: 멀리 있는 적을 먼저 노리면 후반이 편해요. 머리(위쪽)가 조금 더 데미지 큼.
      </p>
    </div>
  </div>
</div>

<script>
(() => {
  // =============== Canvas & resize ===============
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize);
  resize();

  // =============== HUD refs ===============
  const hpEl = document.getElementById('hp');
  const scoreEl = document.getElementById('score');
  const waveEl = document.getElementById('wave');
  const leftEl = document.getElementById('left');
  const hintEl = document.getElementById('hint');
  const spdEl = document.getElementById('spd');
  const cdEl  = document.getElementById('cd');

  // =============== World "pseudo-3D" camera ===============
  // We simulate 3D with a simple perspective projection.
  // World coordinates: x (left/right), y (up/down), z (forward, positive away from player)
  // Player is at z=0 looking toward +z.
  const cam = {
    x: 0, y: 1.6, z: 0,
    yaw: 0, pitch: 0,
    fov: 75 * Math.PI/180, // radians
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }

  // Convert world point to camera space then project to screen.
  function project(p, w, h){
    // translate
    let x = p.x - cam.x;
    let y = p.y - cam.y;
    let z = p.z - cam.z;

    // rotate by yaw (Y axis)
    const cy = Math.cos(-cam.yaw), sy = Math.sin(-cam.yaw);
    let x1 = x*cy - z*sy;
    let z1 = x*sy + z*cy;

    // rotate by pitch (X axis)
    const cp = Math.cos(-cam.pitch), sp = Math.sin(-cam.pitch);
    let y2 = y*cp - z1*sp;
    let z2 = y*sp + z1*cp;

    // behind camera
    if (z2 <= 0.08) return null;

    const f = (0.5*h) / Math.tan(cam.fov/2);
    const sx = (x1 * f) / z2 + w/2;
    const sy2 = (y2 * f) / z2 + h/2;

    return { x:sx, y:sy2, z:z2, scale: f / z2 };
  }

  // =============== Game state ===============
  const state = {
    running: false,
    hp: 100,
    score: 0,
    wave: 1,

    // tuning
    moveSpeed: 7.5,
    projectileSpeed: 34,
    projectileCooldown: 0.22, // seconds
    lastShot: -999,

    enemies: [],
    balls: [],
    particles: [],

    // input
    keys: new Set(),
    wantsShoot: false,
  };

  spdEl.textContent = state.projectileSpeed.toFixed(0);
  cdEl.textContent  = state.projectileCooldown.toFixed(2) + "s";

  // =============== Pointer Lock / Mouse look ===============
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');

  startBtn.addEventListener('click', async () => {
    await canvas.requestPointerLock?.();
    startOverlay.style.display = 'none';
    hintEl.style.display = 'block';
    resetGame();
    state.running = true;
  });

  document.addEventListener('pointerlockchange', () => {
    const locked = document.pointerLockElement === canvas;
    hintEl.style.display = locked ? 'block' : 'none';
  });

  document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas) return;
    const sens = 0.0022;
    cam.yaw   += e.movementX * sens;
    cam.pitch += e.movementY * sens;
    cam.pitch = clamp(cam.pitch, -0.95, 0.95);
  });

  // =============== Input ===============
  addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    state.keys.add(k);
    if (k === ' ') state.wantsShoot = true;
    if (k === 'r') resetGame();
  });
  addEventListener('keyup', (e) => {
    const k = e.key.toLowerCase();
    state.keys.delete(k);
    if (k === ' ') state.wantsShoot = false;
  });
  addEventListener('mousedown', () => {
    if (document.pointerLockElement !== canvas) {
      canvas.requestPointerLock?.();
      return;
    }
    state.wantsShoot = true;
  });
  addEventListener('mouseup', () => state.wantsShoot = false);

  // =============== Enemy / Ball ===============
  function spawnWave(wave){
    const base = 6 + wave * 2;
    const n = Math.min(32, base);
    const speed = 1.5 + wave * 0.12;
    const hp = 18 + wave * 4;

    for (let i=0;i<n;i++){
      state.enemies.push({
        x: rand(-18, 18),
        y: 0,
        z: rand(30, 75) + i*1.5,
        r: rand(0.55, 0.85),
        hp,
        speed: speed * rand(0.85, 1.15),
        wobble: Math.random()*Math.PI*2,
        alive: true
      });
    }
    leftEl.textContent = state.enemies.filter(e=>e.alive).length;
  }

  function shootBall(now){
    const t = now/1000;
    if (t - state.lastShot < state.projectileCooldown) return;
    state.lastShot = t;

    // ball origin slightly in front of camera
    const ox = cam.x;
    const oy = cam.y - 0.12;
    const oz = cam.z + 0.6;

    // direction from yaw/pitch
    const dx = Math.sin(cam.yaw) * Math.cos(cam.pitch);
    const dy = Math.sin(cam.pitch);
    const dz = Math.cos(cam.yaw) * Math.cos(cam.pitch);

    state.balls.push({
      x: ox + dx*0.8,
      y: oy + dy*0.8,
      z: oz + dz*0.8,
      vx: dx * state.projectileSpeed,
      vy: dy * state.projectileSpeed,
      vz: dz * state.projectileSpeed,
      r: 0.18,
      life: 2.2
    });
  }

  function explode(x,y,z, amount=14){
    for (let i=0;i<amount;i++){
      state.particles.push({
        x,y,z,
        vx: rand(-6,6),
        vy: rand(0,7),
        vz: rand(-6,6),
        life: rand(0.25, 0.8)
      });
    }
  }

  // =============== Reset ===============
  function resetGame(){
    state.hp = 100;
    state.score = 0;
    state.wave = 1;
    state.enemies = [];
    state.balls = [];
    state.particles = [];
    cam.x = 0; cam.z = 0;
    cam.yaw = 0; cam.pitch = 0;
    spawnWave(state.wave);
    syncHud();
  }

  function syncHud(){
    hpEl.textContent = Math.max(0, Math.floor(state.hp));
    scoreEl.textContent = Math.floor(state.score);
    waveEl.textContent = state.wave;
    leftEl.textContent = state.enemies.filter(e=>e.alive).length;
  }

  // =============== Main loop ===============
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    update(dt, now);
    render();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt, now){
    if (!state.running) return;

    // movement (WASD in camera yaw plane)
    let mx = 0, mz = 0;
    if (state.keys.has('w')) mz += 1;
    if (state.keys.has('s')) mz -= 1;
    if (state.keys.has('a')) mx -= 1;
    if (state.keys.has('d')) mx += 1;

    const len = Math.hypot(mx, mz) || 1;
    mx /= len; mz /= len;

    const s = state.moveSpeed;
    const yaw = cam.yaw;
    // forward in +z (world) aligned with yaw
    const fx = Math.sin(yaw), fz = Math.cos(yaw);
    const rx = Math.sin(yaw - Math.PI/2), rz = Math.cos(yaw - Math.PI/2);

    cam.x += (rx*mx + fx*mz) * s * dt;
    cam.z += (rz*mx + fz*mz) * s * dt;

    // keep in arena
    cam.x = clamp(cam.x, -22, 22);
    cam.z = clamp(cam.z, -8, 8);

    // shoot
    if (state.wantsShoot) shootBall(now);

    // update balls
    for (let i=state.balls.length-1;i>=0;i--){
      const b = state.balls[i];
      b.life -= dt;
      // small gravity for arc feel
      b.vy -= 9.5 * dt;

      b.x += b.vx * dt;
      b.y += b.vy * dt;
      b.z += b.vz * dt;

      if (b.life <= 0 || b.y < -1.2) state.balls.splice(i,1);
    }

    // update enemies
    let aliveCount = 0;
    for (const e of state.enemies){
      if (!e.alive) continue;
      aliveCount++;

      e.wobble += dt * 2.0;
      const strafe = Math.sin(e.wobble) * 0.6;

      // move toward player (cam.x, cam.z)
      const tx = cam.x - e.x;
      const tz = cam.z - e.z;
      const dist = Math.hypot(tx, tz) || 1;
      const nx = tx / dist;
      const nz = tz / dist;

      e.x += (nx * e.speed + strafe*0.35) * dt;
      e.z += (nz * e.speed) * dt;

      // contact damage
      if (dist < (e.r + 0.9)) {
        state.hp -= 18 * dt;
        // knockback the enemy a bit
        e.z -= nz * 1.2 * dt;
        e.x -= nx * 1.2 * dt;
      }
    }

    // collisions ball vs enemy
    for (let i=state.balls.length-1;i>=0;i--){
      const b = state.balls[i];
      let hit = false;
      for (const e of state.enemies){
        if (!e.alive) continue;

        // enemy "body" center approx at y = 1.2
        const ex = e.x, ey = 1.2, ez = e.z;
        const dx = b.x - ex;
        const dy = b.y - ey;
        const dz = b.z - ez;
        const d = Math.hypot(dx,dy,dz);

        if (d < (e.r + b.r + 0.25)){
          // headshot-ish if higher
          const headBonus = (b.y > 1.65) ? 1.35 : 1.0;
          const dmg = 26 * headBonus;

          e.hp -= dmg;
          explode(b.x, b.y, b.z, 10);
          hit = true;

          // ricochet / slow down a bit
          b.vx *= 0.35; b.vy *= 0.35; b.vz *= 0.35;
          b.life = Math.min(b.life, 0.18);

          if (e.hp <= 0){
            e.alive = false;
            state.score += 100;
            explode(ex, ey, ez, 22);
          } else {
            state.score += 10;
          }
          break;
        }
      }
      if (hit) { /* keep ball short-lived */ }
    }

    // particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      p.life -= dt;
      p.vy -= 10 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.z += p.vz * dt;
      if (p.life <= 0) state.particles.splice(i,1);
    }

    // wave clear
    if (aliveCount === 0){
      state.wave++;
      spawnWave(state.wave);
    }

    // game over
    if (state.hp <= 0){
      state.running = false;
      startOverlay.style.display = 'flex';
      startOverlay.querySelector('h1').textContent = 'Game Over';
      startOverlay.querySelector('p').textContent = `점수: ${Math.floor(state.score)} / 웨이브: ${state.wave}`;
      startBtn.textContent = '다시 시작';
    }

    syncHud();
  }

  // =============== Rendering ===============
  function render(){
    const w = innerWidth, h = innerHeight;

    // background
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0, '#0b1220');
    g.addColorStop(1, '#070a0f');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // ground
    const horizon = h*0.56;
    const gg = ctx.createLinearGradient(0,horizon,0,h);
    gg.addColorStop(0, 'rgba(40,70,60,.25)');
    gg.addColorStop(1, 'rgba(10,16,14,1)');
    ctx.fillStyle = gg;
    ctx.fillRect(0,horizon,w,h-horizon);

    // perspective grid
    drawGrid(w,h,horizon);

    // gather drawable objects with depth sorting
    const drawables = [];

    // enemies
    for (const e of state.enemies){
      if (!e.alive) continue;
      const p = project({x:e.x,y:1.2,z:e.z}, w,h);
      if (!p) continue;
      drawables.push({ z:p.z, type:'enemy', e, p });
    }

    // balls
    for (const b of state.balls){
      const p = project({x:b.x,y:b.y,z:b.z}, w,h);
      if (!p) continue;
      drawables.push({ z:p.z, type:'ball', b, p });
    }

    // particles
    for (const p0 of state.particles){
      const p = project({x:p0.x,y:p0.y,z:p0.z}, w,h);
      if (!p) continue;
      drawables.push({ z:p.z, type:'particle', p0, p });
    }

    drawables.sort((a,b)=> b.z - a.z); // far -> near (painters algorithm)
    for (const d of drawables){
      if (d.type === 'enemy') drawEnemy(d.e, d.p);
      else if (d.type === 'ball') drawBall(d.b, d.p);
      else drawParticle(d.p0, d.p);
    }

    // vignette
    const vg = ctx.createRadialGradient(w/2,h/2, Math.min(w,h)*0.1, w/2,h/2, Math.max(w,h)*0.65);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,.55)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);

    // subtle crosshair when locked
    if (document.pointerLockElement === canvas){
      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.strokeStyle = 'rgba(255,255,255,.8)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(w/2,h/2, 8, 0, Math.PI*2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w/2-14,h/2); ctx.lineTo(w/2-4,h/2);
      ctx.moveTo(w/2+4,h/2);  ctx.lineTo(w/2+14,h/2);
      ctx.moveTo(w/2,h/2-14); ctx.lineTo(w/2,h/2-4);
      ctx.moveTo(w/2,h/2+4);  ctx.lineTo(w/2,h/2+14);
      ctx.stroke();
      ctx.restore();
    }
  }

  function drawGrid(w,h,horizon){
    ctx.save();
    ctx.globalAlpha = 0.18;

    // draw lines converging to a vanishing point based on yaw
    const vpX = w/2 + Math.sin(-cam.yaw)*w*0.35;
    const vpY = horizon + Math.sin(cam.pitch)*h*0.18;

    ctx.strokeStyle = 'rgba(140,220,180,.35)';
    ctx.lineWidth = 1;

    // radial lines
    for (let i=-18;i<=18;i++){
      const x = (w/2) + i*(w/28);
      ctx.beginPath();
      ctx.moveTo(x,h);
      ctx.lineTo(vpX, vpY);
      ctx.stroke();
    }

    // horizontal depth lines
    for (let k=1;k<=22;k++){
      const t = k/22;
      const y = horizon + (h-horizon) * (t*t);
      ctx.beginPath();
      ctx.moveTo(0,y);
      ctx.lineTo(w,y);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawEnemy(e, pr){
    const w = innerWidth, h = innerHeight;
    const s = pr.scale;

    // enemy size in pixels
    const bodyR = e.r * 36 * s;
    const headR = e.r * 20 * s;

    // shadow on ground
    const groundP = project({x:e.x,y:0,z:e.z}, w,h);
    if (groundP){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = 'rgba(0,0,0,.6)';
      ctx.beginPath();
      ctx.ellipse(groundP.x, groundP.y, bodyR*1.1, bodyR*0.45, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // body
    ctx.save();

    // color shifts by distance/hp
    const hp01 = clamp(e.hp / (18 + state.wave*4), 0, 1);
    const glow = clamp(1 - pr.z/70, 0, 1);

    // body gradient
    const grad = ctx.createRadialGradient(pr.x-bodyR*0.2, pr.y-bodyR*0.2, bodyR*0.2, pr.x, pr.y, bodyR*1.6);
    grad.addColorStop(0, `rgba(${Math.floor(220-80*hp01)}, ${Math.floor(90+80*hp01)}, 110, 1)`);
    grad.addColorStop(1, `rgba(40, 20, 35, 1)`);
    ctx.fillStyle = grad;

    ctx.beginPath();
    ctx.arc(pr.x, pr.y, bodyR, 0, Math.PI*2);
    ctx.fill();

    // head
    const hy = pr.y - bodyR*0.95;
    const hgrad = ctx.createRadialGradient(pr.x-headR*0.2, hy-headR*0.2, headR*0.2, pr.x, hy, headR*1.6);
    hgrad.addColorStop(0, `rgba(240, 220, 190, 1)`);
    hgrad.addColorStop(1, `rgba(80, 60, 60, 1)`);
    ctx.fillStyle = hgrad;

    ctx.beginPath();
    ctx.arc(pr.x, hy, headR, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = `rgba(255,255,255,${0.65+0.25*glow})`;
    ctx.beginPath();
    ctx.arc(pr.x - headR*0.35, hy - headR*0.05, headR*0.12, 0, Math.PI*2);
    ctx.arc(pr.x + headR*0.35, hy - headR*0.05, headR*0.12, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = 'rgba(10,10,12,.8)';
    ctx.beginPath();
    ctx.arc(pr.x - headR*0.35, hy - headR*0.05, headR*0.06, 0, Math.PI*2);
    ctx.arc(pr.x + headR*0.35, hy - headR*0.05, headR*0.06, 0, Math.PI*2);
    ctx.fill();

    // hp bar
    const barW = bodyR*2.0;
    const barH = Math.max(3, 5*s);
    const bx = pr.x - barW/2;
    const by = hy - headR - 18*s;

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = 'rgba(0,0,0,.55)';
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = `rgba(120,210,255,.95)`;
    ctx.fillRect(bx, by, barW*hp01, barH);

    // outline
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,.35)';
    ctx.lineWidth = Math.max(1, 2*s);
    ctx.beginPath();
    ctx.arc(pr.x, pr.y, bodyR, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();
  }

  function drawBall(b, pr){
    const s = pr.scale;
    const r = b.r * 28 * s;

    // glow trail impression
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = 'rgba(120,180,255,.35)';
    ctx.beginPath();
    ctx.arc(pr.x, pr.y, r*2.2, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // ball
    const grad = ctx.createRadialGradient(pr.x-r*0.35, pr.y-r*0.35, r*0.25, pr.x, pr.y, r*1.6);
    grad.addColorStop(0, 'rgba(245,250,255,1)');
    grad.addColorStop(1, 'rgba(110,150,190,1)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(pr.x, pr.y, r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = Math.max(1, 1.5*s);
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawParticle(p0, pr){
    const s = pr.scale;
    const r = 2.2 * s * (0.7 + 0.6*p0.life);
    ctx.save();
    ctx.globalAlpha = clamp(p0.life, 0, 1);
    ctx.fillStyle = 'rgba(200,230,255,.85)';
    ctx.beginPath();
    ctx.arc(pr.x, pr.y, r, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
})();
</script>
</body>
</html>
