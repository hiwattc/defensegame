<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë ˆì´ì‹± ê²Œì„</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        
        #gameContainer {
            position: relative;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            gap: 20px;
        }
        
        #rankings {
            width: 300px;
            padding: 15px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-height: 850px;
            overflow-y: auto;
        }
        
        #gameCanvas {
            display: block;
            border: 2px solid #333;
        }
        
        #controls {
            margin-top: 20px;
            text-align: center;
        }
        
        #info {
            margin-top: 10px;
            display: flex;
            gap: 20px;
            font-size: 18px;
            font-weight: bold;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #instructions {
            margin-top: 15px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 5px;
            max-width: 600px;
        }

        /* ì§€ë„ ëª¨ë“œ ìŠ¤íƒ€ì¼ */
        .car-marker {
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            position: absolute !important;
            z-index: 1000;
            pointer-events: none;
        }

        /* ì°¨ëŸ‰ì„ í™”ë©´ ì¤‘ì•™ì— ì ˆëŒ€ ê³ ì • */
        .leaflet-container .car-marker {
            position: absolute !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            margin: 0 !important;
        }
    </style>
</head>
<body>
    <h1>ğŸï¸ ë ˆì´ì‹± ê²Œì„</h1>
    
    <div id="gameContainer">
        <div id="rankings">
            <h3 style="margin: 0 0 10px 0; text-align: center;">ğŸ† ì‹¤ì‹œê°„ ìˆœìœ„</h3>
            <div id="rankingList"></div>
        </div>
        <canvas id="gameCanvas" width="850" height="850"></canvas>
        <!-- ì§€ë„ ëª¨ë“œìš© ì»¨í…Œì´ë„ˆ -->
        <div id="mapContainer" style="width: 850px; height: 850px; display: none; border: 2px solid #333;"></div>
    </div>
    
    <div id="controls">
        <button id="startBtn">ê²Œì„ ì‹œì‘</button>
        <button id="resetBtn">ë‹¤ì‹œ ì‹œì‘</button>
        <button id="firstPersonBtn">1ì¸ì¹­ ëª¨ë“œ</button>
        <button id="mapBtn">ì§€ë„ ëª¨ë“œ</button>
        <select id="mapTypeSelect" style="margin-left: 10px; padding: 5px; display: none;">
            <option value="osm">OpenStreetMap</option>
            <option value="cartodb_dark">CartoDB Dark</option>
            <option value="cartodb_positron">CartoDB Positron</option>
            <option value="satellite">í•­ê³µì§€ë„ (Esri)</option>
        </select>
        <button id="labelToggleBtn" style="margin-left: 10px; padding: 5px 10px; display: none;">ë¼ë²¨ ì¼œê¸°</button>
        <span id="zoomLevel" style="margin-left: 10px; padding: 5px; font-size: 12px; background: #f0f0f0; border-radius: 3px; display: none;">ì¤Œ: 19</span>
    </div>
    
    <div id="info">
        <div>â±ï¸ ì‹œê°„: <span id="timer">0.0</span>ì´ˆ</div>
        <div>ğŸ ë©: <span id="lap">0</span>/10</div>
        <div>âš¡ ì†ë„: <span id="speed">0</span> / <span id="speedKmh">0</span> km/h</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        let gameState = {
            running: false,
            firstPersonMode: false, // 1ì¸ì¹­ ëª¨ë“œ ìƒíƒœ
            mapMode: false, // ì§€ë„ ëª¨ë“œ ìƒíƒœ
            car: {
                x: 720,
                y: 430,
                angle: Math.PI,
                speed: 0,
                maxSpeed: 3, // 50% ê°ì†Œ
                acceleration: 0.1,
                friction: 0.05,
                turnSpeed: 0.028, // 30% ë” ì„¸ë°€í•˜ê²Œ (0.04 â†’ 0.028)
                collisionCooldown: 0,
                name: 'í”Œë ˆì´ì–´',
                color: '#e74c3c',
                lap: 0,
                passedCheckpoint: false
            },
            timer: 0,
            lap: 0,
            maxLaps: 3, // 3ë°”í€´ë¡œ ë³€ê²½
            passedCheckpoint: false,
            startTime: 0,
            aiCars: []
        };

        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ (1ì¸ì¹­ ëª¨ë“œìš©)
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;

        // ì§€ë„ ëª¨ë“œ ë³€ìˆ˜ë“¤
        let map = null;
        let currentMapSpeed = 0; // í˜„ì¬ ì§€ë„ ëª¨ë“œ ì†ë„
        let acceleration = 0.0006 / (10 * 60); // 10ì´ˆ ë™ì•ˆ ìµœê³ ì†ë„ ë„ë‹¬í•˜ëŠ” ê°€ì†ë„ (500 km/h)
        let deceleration = acceleration * 0.2; // ê°ì†ì„ 20%ë¡œ ì¤„ì„ (ë” ê¸´ ê´€ì„± ì£¼í–‰)
        let currentTileLayer = null;
        let labelLayer = null; // ë¼ë²¨ ë ˆì´ì–´
        let labelsEnabled = false; // ë¼ë²¨ í‘œì‹œ ìƒíƒœ
        let labelsOnlyMode = false; // ë¼ë²¨ë§Œ ëª¨ë“œ ìƒíƒœ
        
        // AI ì°¨ëŸ‰ ì´ˆê¸°í™”
        function initAICars() {
            // í—¤ë“œë¼ì´íŠ¸ ìƒ‰ìƒ ì˜µì…˜
            const headlightColors = ['#00ff00', '#ff0000', '#0000ff', '#ffffff'];

            const aiCarConfigs = [
                { color: '#3498db', name: 'Blue', maxSpeed: 2.25, accel: 0.08, startOffset: { x: 0, y: -20 }, pathIndex: 0 },
                { color: '#2ecc71', name: 'Green', maxSpeed: 2.1, accel: 0.075, startOffset: { x: 0, y: 20 }, pathIndex: 5 },
                { color: '#f39c12', name: 'Yellow', maxSpeed: 2.4, accel: 0.085, startOffset: { x: -20, y: 0 }, pathIndex: 10 },
                { color: '#9b59b6', name: 'Purple', maxSpeed: 2.3, accel: 0.082, startOffset: { x: -40, y: -10 }, pathIndex: 15 },
                { color: '#e91e63', name: 'Pink', maxSpeed: 2.2, accel: 0.078, startOffset: { x: -40, y: 10 }, pathIndex: 20 },
                { color: '#00bcd4', name: 'Cyan', maxSpeed: 2.35, accel: 0.083, startOffset: { x: -60, y: 0 }, pathIndex: 25 },
                { color: '#ff5722', name: 'Orange', maxSpeed: 2.15, accel: 0.076, startOffset: { x: -60, y: -20 }, pathIndex: 30 },
                { color: '#795548', name: 'Brown', maxSpeed: 2.0, accel: 0.073, startOffset: { x: -60, y: 20 }, pathIndex: 35 },
                { color: '#607d8b', name: 'Gray', maxSpeed: 2.28, accel: 0.081, startOffset: { x: -80, y: -10 }, pathIndex: 40 },
                { color: '#cddc39', name: 'Lime', maxSpeed: 2.18, accel: 0.077, startOffset: { x: -80, y: 10 }, pathIndex: 45 },
                // ì¶”ê°€ 10ëŒ€ AI ì°¨ëŸ‰ (ì´ 20ëŒ€)
                { color: '#ff9800', name: 'Amber', maxSpeed: 2.32, accel: 0.084, startOffset: { x: -100, y: -20 }, pathIndex: 50 },
                { color: '#8bc34a', name: 'LightGreen', maxSpeed: 2.22, accel: 0.079, startOffset: { x: -100, y: 20 }, pathIndex: 55 },
                { color: '#673ab7', name: 'DeepPurple', maxSpeed: 2.26, accel: 0.080, startOffset: { x: -120, y: 0 }, pathIndex: 60 },
                { color: '#3f51b5', name: 'Indigo', maxSpeed: 2.29, accel: 0.083, startOffset: { x: -120, y: -30 }, pathIndex: 65 },
                { color: '#009688', name: 'Teal', maxSpeed: 2.21, accel: 0.078, startOffset: { x: -120, y: 30 }, pathIndex: 70 },
                { color: '#ffc107', name: 'Gold', maxSpeed: 2.37, accel: 0.086, startOffset: { x: -140, y: -10 }, pathIndex: 75 },
                { color: '#e91e63', name: 'HotPink', maxSpeed: 2.19, accel: 0.077, startOffset: { x: -140, y: 10 }, pathIndex: 80 },
                { color: '#2196f3', name: 'LightBlue', maxSpeed: 2.33, accel: 0.085, startOffset: { x: -160, y: 0 }, pathIndex: 85 },
                { color: '#4caf50', name: 'MediumGreen', maxSpeed: 2.24, accel: 0.081, startOffset: { x: -160, y: -25 }, pathIndex: 90 },
                { color: '#ffeb3b', name: 'BrightYellow', maxSpeed: 2.16, accel: 0.075, startOffset: { x: -160, y: 25 }, pathIndex: 95 }
            ];
            
            gameState.aiCars = aiCarConfigs.map(config => ({
                x: 720 + config.startOffset.x,
                y: 430 + config.startOffset.y,
                angle: Math.PI,
                speed: 0,
                maxSpeed: config.maxSpeed,
                acceleration: config.accel,
                friction: 0.05,
                turnSpeed: 0.042, // 30% ë” ì„¸ë°€í•˜ê²Œ (0.06 â†’ 0.042)
                color: config.color,
                name: config.name,
                pathIndex: config.pathIndex,
                lap: 0,
                passedCheckpoint: false,
                recoveryTime: 0,
                collisionCooldown: 0,
                headlightColor: headlightColors[Math.floor(Math.random() * headlightColors.length)] // ëœë¤ í—¤ë“œë¼ì´íŠ¸ ìƒ‰ìƒ
            }));
        }
        
        // í‚¤ë³´ë“œ ì…ë ¥
        const keys = {
            up: false,
            down: false,
            left: false,
            right: false
        };
        
        // íŠ¸ë™ ê²½ë¡œ (ëŒ€ëµì ì¸ ì¤‘ì‹¬ì„ )
        const trackPath = [
            {x: 720, y: 430}, {x: 650, y: 430}, {x: 580, y: 430},
            {x: 520, y: 410}, {x: 470, y: 370}, {x: 440, y: 320},
            {x: 430, y: 260}, {x: 430, y: 200}, {x: 430, y: 140},
            {x: 450, y: 90}, {x: 490, y: 60}, {x: 540, y: 50},
            {x: 600, y: 60}, {x: 650, y: 90}, {x: 680, y: 130},
            {x: 690, y: 180}, {x: 680, y: 230}, {x: 650, y: 270},
            {x: 600, y: 290}, {x: 540, y: 280}, {x: 490, y: 250},
            {x: 470, y: 200}, {x: 480, y: 150}, {x: 520, y: 120},
            {x: 250, y: 120}, {x: 200, y: 140}, {x: 170, y: 180},
            {x: 160, y: 230}, {x: 160, y: 290}, {x: 160, y: 350},
            {x: 160, y: 410}, {x: 180, y: 460}, {x: 220, y: 490},
            {x: 270, y: 500}, {x: 330, y: 490}, {x: 380, y: 460},
            {x: 410, y: 420}, {x: 420, y: 370}, {x: 410, y: 320},
            {x: 380, y: 280}, {x: 330, y: 260}, {x: 270, y: 260},
            {x: 220, y: 280}, {x: 190, y: 320}, {x: 180, y: 370},
            {x: 180, y: 430}, {x: 180, y: 490}, {x: 180, y: 550},
            {x: 200, y: 600}, {x: 240, y: 630}, {x: 290, y: 650},
            {x: 350, y: 660}, {x: 410, y: 660}, {x: 470, y: 660},
            {x: 530, y: 660}, {x: 590, y: 650}, {x: 640, y: 620},
            {x: 680, y: 580}, {x: 700, y: 530}, {x: 710, y: 470},
            {x: 720, y: 430}
        ];
        
        const trackWidth = 84; // íŠ¸ë™ í­ (30% ê°ì†Œ)
        
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.addEventListener('keydown', (e) => {
            // ì§€ë„ ëª¨ë“œì—ì„œëŠ” í™”ì‚´í‘œ í‚¤ì˜ ê¸°ë³¸ ë™ì‘ ë°©ì§€
            if (gameState.mapMode && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                e.preventDefault();
            }

            if (e.key === 'ArrowUp') keys.up = true;
            if (e.key === 'ArrowDown') keys.down = true;
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowUp') keys.up = false;
            if (e.key === 'ArrowDown') keys.down = false;
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
        });
        
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('resetBtn').addEventListener('click', resetGame);
        document.getElementById('firstPersonBtn').addEventListener('click', toggleFirstPersonMode);
        document.getElementById('mapBtn').addEventListener('click', toggleMapMode);
        document.getElementById('mapTypeSelect').addEventListener('change', changeMapType);
        document.getElementById('labelToggleBtn').addEventListener('click', toggleLabels);

        // ì§€ë„ íƒ€ì… ë³€ê²½ í•¨ìˆ˜
        function changeMapType() {
            if (!map) return;

            const newMapType = document.getElementById('mapTypeSelect').value;
            const tileConfig = getTileLayerConfig(newMapType);

            // ê¸°ì¡´ íƒ€ì¼ ë ˆì´ì–´ ì œê±°
            if (currentTileLayer) {
                map.removeLayer(currentTileLayer);
            }

            // ìƒˆë¡œìš´ íƒ€ì¼ ë ˆì´ì–´ ì¶”ê°€
            currentTileLayer = L.tileLayer(tileConfig.url, {
                attribution: tileConfig.attribution
            }).addTo(map);

            // ì‹¤ì œ ì§€ì›ë˜ëŠ” ìµœëŒ€ ì¤Œ ë ˆë²¨ (18ë ˆë²¨ê¹Œì§€)
            map.setMaxZoom(18);

            // ë¼ë²¨ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ ì²˜ë¦¬
            const labelBtn = document.getElementById('labelToggleBtn');
            if (newMapType === 'satellite' || newMapType === 'osm') {
                labelBtn.style.display = 'inline-block';
                // ì§€ë„ íƒ€ì… ë³€ê²½ ì‹œ ë¼ë²¨ ìƒíƒœ ì´ˆê¸°í™”
                if (labelsEnabled && labelLayer) {
                    map.removeLayer(labelLayer);
                    labelLayer = null;
                }
                if (currentTileLayer) {
                    currentTileLayer.setOpacity(1);
                }
                labelsEnabled = false;
                labelsOnlyMode = false;
                labelBtn.textContent = 'ë¼ë²¨ ì¼œê¸°';
            } else {
                labelBtn.style.display = 'none';
                // ë‹¤ë¥¸ ì§€ë„ì—ì„œëŠ” ë¼ë²¨ ê°•ì œ ë„ê¸°
                if (labelLayer) {
                    map.removeLayer(labelLayer);
                    labelLayer = null;
                }
                if (currentTileLayer) {
                    currentTileLayer.setOpacity(1);
                }
                labelsEnabled = false;
                labelsOnlyMode = false;
            }
        }

        // ë¼ë²¨ í† ê¸€ í•¨ìˆ˜ (3ê°€ì§€ ìƒíƒœ: ë„ê¸° â†’ ì¼œê¸° â†’ ë¼ë²¨ë§Œ)
        function toggleLabels() {
            if (!map) return;

            const btn = document.getElementById('labelToggleBtn');
            const mapType = document.getElementById('mapTypeSelect').value;
            const tileConfig = getTileLayerConfig(mapType);

            if (labelsOnlyMode) {
                // ë¼ë²¨ë§Œ ëª¨ë“œ â†’ ë¼ë²¨ ë„ê¸°
                if (labelLayer) {
                    map.removeLayer(labelLayer);
                    labelLayer = null;
                }
                // ì§€ë„ íƒ€ì¼ ë‹¤ì‹œ í‘œì‹œ
                if (currentTileLayer) {
                    currentTileLayer.setOpacity(1);
                }
                labelsOnlyMode = false;
                labelsEnabled = false;
                btn.textContent = 'ë¼ë²¨ ì¼œê¸°';

            } else if (labelsEnabled) {
                // ë¼ë²¨ ì¼œê¸° â†’ ë¼ë²¨ë§Œ ëª¨ë“œ
                if (currentTileLayer && tileConfig.referenceUrl) {
                    // ì§€ë„ íƒ€ì¼ì„ íˆ¬ëª…í•˜ê²Œ ë§Œë“¤ê³  ë¼ë²¨ë§Œ í‘œì‹œ
                    currentTileLayer.setOpacity(0);
                    labelsOnlyMode = true;
                    btn.textContent = 'ë¼ë²¨ ë„ê¸°';
                }

            } else {
                // ë¼ë²¨ ë„ê¸° â†’ ë¼ë²¨ ì¼œê¸°
                if (tileConfig.referenceUrl) {
                    if (!labelLayer) {
                        const maxZoomLevel = 18; // ì‹¤ì œ ì§€ì›ë˜ëŠ” ìµœëŒ€ ì¤Œ ë ˆë²¨
                        labelLayer = L.tileLayer(tileConfig.referenceUrl, {
                            attribution: tileConfig.attribution,
                            minZoom: 0,
                            maxZoom: maxZoomLevel,
                            opacity: 0.4
                        }).addTo(map);
                    }
                    // ì§€ë„ íƒ€ì¼ ë¶ˆíˆ¬ëª…í•˜ê²Œ ìœ ì§€
                    if (currentTileLayer) {
                        currentTileLayer.setOpacity(1);
                    }
                    labelsEnabled = true;
                    labelsOnlyMode = false;
                    btn.textContent = 'ë¼ë²¨ë§Œ';
                }
            }
        }

        // 1ì¸ì¹­ ëª¨ë“œ í† ê¸€ í•¨ìˆ˜
        function toggleFirstPersonMode() {
            gameState.firstPersonMode = !gameState.firstPersonMode;
            const btn = document.getElementById('firstPersonBtn');
            btn.textContent = gameState.firstPersonMode ? '3ì¸ì¹­ ëª¨ë“œ' : '1ì¸ì¹­ ëª¨ë“œ';

            // ëª¨ë“œ ë³€ê²½ ì‹œ ì¹´ë©”ë¼ ë¦¬ì…‹
            cameraOffsetX = 0;
            cameraOffsetY = 0;

            // í™”ë©´ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            if (!gameState.running) {
                drawTrack();
                drawCar();
                gameState.aiCars.forEach(aiCar => drawAICar(aiCar));
                updateUI();
            }
        }

        // ì§€ë„ ëª¨ë“œ í† ê¸€ í•¨ìˆ˜
        function toggleMapMode() {
            gameState.mapMode = !gameState.mapMode;
            const btn = document.getElementById('mapBtn');
            btn.textContent = gameState.mapMode ? 'íŠ¸ë™ ëª¨ë“œ' : 'ì§€ë„ ëª¨ë“œ';

            const canvas = document.getElementById('gameCanvas');
            const mapContainer = document.getElementById('mapContainer');

            if (gameState.mapMode) {
                // ì§€ë„ ëª¨ë“œë¡œ ì „í™˜ - í•­ê³µì‚¬ì§„ì„ ê¸°ë³¸ìœ¼ë¡œ ì„¤ì •
                canvas.style.display = 'none';
                mapContainer.style.display = 'block';
                document.getElementById('mapTypeSelect').style.display = 'inline-block';

                // í•­ê³µì‚¬ì§„ì„ ê¸°ë³¸ìœ¼ë¡œ ì„ íƒ
                document.getElementById('mapTypeSelect').value = 'satellite';
                // í•­ê³µì§€ë„ì´ë¯€ë¡œ ë¼ë²¨ ë²„íŠ¼ í‘œì‹œ
                document.getElementById('labelToggleBtn').style.display = 'inline-block';
                // ë¼ë²¨ ìƒíƒœ ì´ˆê¸°í™”
                labelsEnabled = false;
                labelsOnlyMode = false;
                document.getElementById('labelToggleBtn').textContent = 'ë¼ë²¨ ì¼œê¸°';

                initMap();
            } else {
                // íŠ¸ë™ ëª¨ë“œë¡œ ì „í™˜
                canvas.style.display = 'block';
                mapContainer.style.display = 'none';
                document.getElementById('mapTypeSelect').style.display = 'none';
                document.getElementById('labelToggleBtn').style.display = 'none';
                document.getElementById('zoomLevel').style.display = 'none';

                // ê¸°ì¡´ ì°¨ëŸ‰ ìš”ì†Œ ì œê±°
                const existingCar = document.getElementById('fixedCar');
                if (existingCar) {
                    existingCar.remove();
                }

                if (map) {
                    map.remove();
                    map = null;
                    currentTileLayer = null;
                }
                // í™”ë©´ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                if (!gameState.running) {
                    drawTrack();
                    drawCar();
                    gameState.aiCars.forEach(aiCar => drawAICar(aiCar));
                    updateUI();
                }
            }
        }

        // ì§€ë„ íƒ€ì…ë³„ íƒ€ì¼ ì„¤ì • í•¨ìˆ˜
        function getTileLayerConfig(mapType) {
            const configs = {
                osm: {
                    url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    attribution: 'Â© OpenStreetMap contributors'
                },
                cartodb_dark: {
                    url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
                    attribution: 'Â© CartoDB contributors'
                },
                cartodb_positron: {
                    url: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
                    attribution: 'Â© CartoDB contributors'
                },
                satellite: {
                    url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                    attribution: 'Â© Esri contributors',
                    referenceUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'
                }
            };
            return configs[mapType] || configs.osm;
        }

        // ì§€ë„ ì´ˆê¸°í™” í•¨ìˆ˜
        function initMap() {
            if (map) return;

            // ì„œìš¸ ì‹œì²­ ì¢Œí‘œ (ì¤‘ì‹¬ì )
            const seoulCenter = [37.5665, 126.9780];
            const mapType = document.getElementById('mapTypeSelect').value;

            // Leaflet ì§€ë„ ìƒì„± - í‚¤ë³´ë“œ ì¡°ì‘ ë¹„í™œì„±í™”, ë“œë˜ê·¸ í™œì„±í™”
            map = L.map('mapContainer', {
                keyboard: false,  // í‚¤ë³´ë“œ ì¡°ì‘ ë¹„í™œì„±í™”
                dragging: true,   // ë“œë˜ê·¸ í™œì„±í™” (íŒ¨ë‹ ê°€ëŠ¥)
                zoomControl: true,
                scrollWheelZoom: true
            }).setView(seoulCenter, 13);

            // ì„ íƒëœ ì§€ë„ íƒ€ì…ì˜ íƒ€ì¼ ì¶”ê°€
            const tileConfig = getTileLayerConfig(mapType);
            currentTileLayer = L.tileLayer(tileConfig.url, {
                attribution: tileConfig.attribution
            }).addTo(map);

            // ì„œìš¸ì‹œë‚´ ì£¼í–‰ ê²½ë¡œ (ì‹œì²­ ì£¼ë³€ ë„ë¡œ)
            const seoulPath = [
                [37.5665, 126.9780], // ì‹œì²­
                [37.5675, 126.9800], // ì‹œì²­ ì•
                [37.5690, 126.9820], // ì²­ê³„ì²œ ë°©í–¥
                [37.5710, 126.9840], // ì¢…ë¡œ ë°©í–¥
                [37.5730, 126.9860], // ì¢…ë¡œ3ê°€
                [37.5750, 126.9880], // ì¢…ë¡œ5ê°€
                [37.5770, 126.9900], // ë™ëŒ€ë¬¸ ë°©í–¥
                [37.5790, 126.9920], // ë™ëŒ€ë¬¸
                [37.5810, 126.9940], // ì‹ ì„¤ë™
                [37.5830, 126.9960], // ì²­ëŸ‰ë¦¬ ë°©í–¥
                [37.5850, 126.9980], // ì œê¸°ë™
                [37.5870, 127.0000], // ìš©ë‘ë™
                [37.5890, 127.0020], // ì‹ ë‹µì—­
                [37.5910, 127.0040], // ì¥ì•ˆë™
                [37.5930, 127.0060], // ë‹µì‹­ë¦¬
                [37.5950, 127.0080], // ì¥í•œí‰
                [37.5970, 127.0100], // êµ°ìë™
                [37.5990, 127.0120], // ì¤‘ê³¡ë™
                [37.6010, 127.0140], // ê´‘ë‚˜ë£¨
                [37.6030, 127.0160], // êµ¬ì˜ë™
                [37.6050, 127.0180], // ê°•ë³€ì—­
                [37.6070, 127.0200], // ëšì„¬
                [37.6090, 127.0220], // ì„±ìˆ˜ë™
                [37.6110, 127.0240], // ê¸ˆí˜¸ë™
                [37.6130, 127.0260], // ì˜¥ìˆ˜ë™
                [37.6150, 127.0280], // í•œê°•ëŒ€êµ
                [37.6170, 127.0300], // ì´ì´Œë™
                [37.6190, 127.0320], // ë™ì‘ëŒ€êµ
                [37.6210, 127.0340], // ë…¸ëŸ‰ì§„
                [37.6230, 127.0360], // ìƒë„ë™
                [37.6250, 127.0380], // ìˆ­ì‹¤ëŒ€
                [37.6270, 127.0400], // ì‚¬ë‹¹ì—­
                [37.6290, 127.0420], // ë°©ë°°ë™
                [37.6310, 127.0440], // ì„œì´ˆë™
                [37.6330, 127.0460], // êµëŒ€ì—­
                [37.6350, 127.0480], // ê°•ë‚¨ì—­
                [37.6370, 127.0500], // ì—­ì‚¼ë™
                [37.6390, 127.0520], // ì„ ë¦‰ì—­
                [37.6410, 127.0540], // ì‚¼ì„±ë™
                [37.6430, 127.0560], // ì²­ë‹´ë™
                [37.6450, 127.0580], // ì••êµ¬ì •
                [37.6470, 127.0600], // ì‹ ì‚¬ì—­
                [37.6490, 127.0620], // ê°€ë¡œìˆ˜ê¸¸
                [37.6510, 127.0640], // ë…¼í˜„ë™
                [37.6530, 127.0660], // í•™ë™ì—­
                [37.6550, 127.0680], // ê°•ë‚¨êµ¬ì²­
                [37.6570, 127.0700], // ê°œí¬ë™
                [37.6590, 127.0720], // ì¼ì›ë™
                [37.6610, 127.0740], // ìˆ˜ì„œì—­
                [37.6630, 127.0760], // ê°€ë½ë™
                [37.6650, 127.0780], // ë¬¸ì •ë™
                [37.6670, 127.0800], // ì¥ì§€ì—­
                [37.6690, 127.0820], // ë³µì •ì—­
                [37.6710, 127.0840], // ìœ„ë¡€ì‹ ë„ì‹œ
                [37.6730, 127.0860], // ê±°ì—¬ë™
                [37.6750, 127.0880], // ë§ˆì²œë™
                [37.6770, 127.0900], // ì†¡íŒŒêµ¬ì²­
                [37.6790, 127.0920], // ë°©ì´ë™
                [37.6810, 127.0940], // ì˜¤ê¸ˆì—­
                [37.6830, 127.0960], // ì ì‹¤ì—­
                [37.6850, 127.0980], // ì„ì´Œí˜¸ìˆ˜
                [37.6870, 127.1000], // ì†¡íŒŒë‚˜ë£¨
                [37.6890, 127.1020], // í•œê°• ë°©í–¥
                [37.6910, 127.1040], // ì˜¬ë¦¼í”½ëŒ€êµ
                [37.6930, 127.1060], // ê´‘ì§„êµ¬
                [37.6950, 127.1080], // ì¤‘ê³¡ë™
                [37.6970, 127.1100], // êµ°ìì—­
                [37.6990, 127.1120], // ì•„ì°¨ì‚°
                [37.7010, 127.1140], // ê´‘ë‚˜ë£¨ì—­
                [37.7030, 127.1160], // êµ¬ì˜ì—­
                [37.7050, 127.1180], // ê°•ë³€ì—­
                [37.7070, 127.1200], // ëšì„¬ì—­
                [37.7090, 127.1220], // ì„±ìˆ˜ì—­
                [37.7110, 127.1240], // ìƒì™•ì‹­ë¦¬
                [37.7130, 127.1260], // ì™•ì‹­ë¦¬ì—­
                [37.7150, 127.1280], // ë§ˆì¥ë™
                [37.7170, 127.1300], // ìš©ë§ˆì‚°
                [37.7190, 127.1320], // ì²­ëŸ‰ë¦¬ì—­
                [37.7210, 127.1340], // íšŒê¸°ì—­
                [37.7230, 127.1360], // ì™¸ëŒ€ì•
                [37.7250, 127.1380], // ì‹ ì´ë¬¸
                [37.7270, 127.1400], // ì„ê³„ì—­
                [37.7290, 127.1420], // ê´‘ìš´ëŒ€
                [37.7310, 127.1440], // ì›”ê³„ë™
                [37.7330, 127.1460], // ê³µë¦‰ë™
                [37.7350, 127.1480], // íƒœë¦‰ì…êµ¬
                [37.7370, 127.1500], // í™”ë‘ëŒ€
                [37.7390, 127.1520], // ê³µë¦‰ì—­
                [37.7410, 127.1540], // ë¨¹ê³¨ì—­
                [37.7430, 127.1560], // ì¤‘í™”ì—­
                [37.7450, 127.1580], // ìƒë´‰ì—­
                [37.7470, 127.1600], // ë©´ëª©ì—­
                [37.7490, 127.1620], // ì‚¬ê°€ì •ì—­
                [37.7510, 127.1640], // ìš©ë§ˆì—­
                [37.7530, 127.1660], // ì¤‘ê³¡ì—­
                [37.5665, 126.9780]  // ì‹œì²­ìœ¼ë¡œ ëŒì•„ì˜´ (ì›í˜• ì½”ìŠ¤)
            ];

            // í”Œë ˆì´ì–´ ì°¨ëŸ‰ ë§ˆì»¤ ì´ˆê¸°í™” (íŠ¸ë™ ëª¨ë“œì™€ ìœ ì‚¬í•œ ë””ìì¸)
            const carIcon = L.divIcon({
                html: `
                    <div style="
                        width: 30px;
                        height: 20px;
                        background: #e74c3c;
                        border-radius: 2px;
                        position: relative;
                        transform-origin: center;
                    ">
                        <div style="
                            width: 10px;
                            height: 14px;
                            background: #3498db;
                            position: absolute;
                            top: 3px;
                            left: 10px;
                            border-radius: 1px;
                        "></div>
                        <div style="
                            width: 4px;
                            height: 3px;
                            background: #000;
                            position: absolute;
                            bottom: 0;
                            left: 2px;
                        "></div>
                        <div style="
                            width: 4px;
                            height: 3px;
                            background: #000;
                            position: absolute;
                            bottom: 0;
                            right: 2px;
                        "></div>
                        <div style="
                            width: 4px;
                            height: 3px;
                            background: #000;
                            position: absolute;
                            top: 0;
                            left: 2px;
                        "></div>
                        <div style="
                            width: 4px;
                            height: 3px;
                            background: #000;
                            position: absolute;
                            top: 0;
                            right: 2px;
                        "></div>
                    </div>
                `,
                className: 'car-marker',
                iconSize: [30, 20],
                iconAnchor: [15, 10]
            });

            // ì°¨ëŸ‰ì„ í™”ë©´ ì¤‘ì•™ì— ê³ ì •ëœ HTML ìš”ì†Œë¡œ ìƒì„±
            const mapContainer = document.getElementById('mapContainer');
            const carElement = document.createElement('div');
            carElement.id = 'fixedCar';
            carElement.innerHTML = `
                <div style="
                    width: 24px;
                    height: 16px;
                    background: #e74c3c;
                    border-radius: 1.6px;
                    position: relative;
                    transform-origin: center;
                ">
                    <div style="
                        width: 8px;
                        height: 11.2px;
                        background: #3498db;
                        position: absolute;
                        top: 2.4px;
                        left: 8px;
                        border-radius: 0.8px;
                    "></div>
                    <div style="
                        width: 3.2px;
                        height: 2.4px;
                        background: #000;
                        position: absolute;
                        bottom: 0;
                        left: 1.6px;
                    "></div>
                    <div style="
                        width: 3.2px;
                        height: 2.4px;
                        background: #000;
                        position: absolute;
                        bottom: 0;
                        right: 1.6px;
                    "></div>
                    <div style="
                        width: 3.2px;
                        height: 2.4px;
                        background: #000;
                        position: absolute;
                        top: 0;
                        left: 1.6px;
                    "></div>
                    <div style="
                        width: 3.2px;
                        height: 2.4px;
                        background: #000;
                        position: absolute;
                        top: 0;
                        right: 1.6px;
                    "></div>
                    <!-- í—¤ë“œë¼ì´íŠ¸ (ì°¨ëŸ‰ ì¢Œì¸¡ì— ì¶”ê°€, ì°¨ëŸ‰ ê¸¸ì´ 3ë°°ë§Œí¼ ë¹„ì¶¤) -->
                    <div style="
                        width: 2.4px;
                        height: 2.4px;
                        background: #ffff99;
                        position: absolute;
                        top: 6.4px;
                        left: -2.4px;
                        border-radius: 50%;
                        box-shadow:
                            0 0 6px #ffff99,
                            -72px 0 24px 24px rgba(255, 255, 153, 0.3),
                            -48px 0 18px 18px rgba(255, 255, 153, 0.4),
                            -24px 0 12px 12px rgba(255, 255, 153, 0.5);
                    "></div>
                    <div style="
                        width: 2.4px;
                        height: 2.4px;
                        background: #ffff99;
                        position: absolute;
                        bottom: 6.4px;
                        left: -2.4px;
                        border-radius: 50%;
                        box-shadow:
                            0 0 6px #ffff99,
                            -72px 0 24px 24px rgba(255, 255, 153, 0.3),
                            -48px 0 18px 18px rgba(255, 255, 153, 0.4),
                            -24px 0 12px 12px rgba(255, 255, 153, 0.5);
                    "></div>
                </div>
            `;
            carElement.style.cssText = `
                position: absolute;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                z-index: 1000;
                pointer-events: none;
                transition: transform 0.1s ease-out;
            `;
            mapContainer.appendChild(carElement);

            // ì´ˆê¸° ì°¨ëŸ‰ ìœ„ì¹˜ ì„¤ì • (ì§€ë„ ì¤‘ì•™)
            const centerPos = map.getCenter();
            mapCarPosition = { lat: centerPos.lat, lng: centerPos.lng };
            mapCarAngle = 0; // ë¶ìª½ ë°©í–¥ìœ¼ë¡œ ì‹œì‘

            // ì§€ë„ë¥¼ ìµœëŒ€ í™•ëŒ€í•˜ê³  í”Œë ˆì´ì–´ ì°¨ëŸ‰ì„ ì¤‘ì•™ì— ìœ„ì¹˜
            map.setView(seoulPath[0], 19); // ë” í™•ëŒ€ëœ ë ˆë²¨
            map.setMaxZoom(18); // ì‹¤ì œ ì§€ì›ë˜ëŠ” ìµœëŒ€ ì¤Œ ë ˆë²¨

            // ì¤Œ ë ˆë²¨ í‘œì‹œê¸° ì´ˆê¸°í™” ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('zoomLevel').textContent = 'ì¤Œ: ' + map.getZoom();
            document.getElementById('zoomLevel').style.display = 'inline-block';

            // ì¤Œ ë ˆë²¨ ë³€ê²½ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            map.on('zoomend', function() {
                const currentZoom = map.getZoom();
                document.getElementById('zoomLevel').textContent = 'ì¤Œ: ' + currentZoom;
            });
        }

        // ì§€ë„ ëª¨ë“œìš© ì°¨ëŸ‰ ìœ„ì¹˜ ì´ˆê¸°í™”
        let mapCarPosition = { lat: 37.5665, lng: 126.9780 }; // ì„œìš¸ ì‹œì²­ ì‹œì‘ì 
        let mapCarAngle = 0; // ì°¨ëŸ‰ ë°©í–¥ (ë¶ìª½ì´ 0ë„)

        // ì§€ë„ ì¢Œí‘œë¥¼ ì‹¤ì œ ê±°ë¦¬ë¡œ ë³€í™˜ (km/h ê³„ì‚°ìš©)
        function calculateRealSpeed(moveDistance) {
            // ì„œìš¸ ê·¼ì²˜ ìœ„ë„ 37.5Â°ì—ì„œì˜ ì‹¤ì œ ê±°ë¦¬ ë³€í™˜
            // ê²½ë„ 1Â° = 88.8km, ìœ„ë„ 1Â° = 111.1km
            // í˜„ì¬ moveDistanceëŠ” ê²½ë„ ë³€í™”ëŸ‰ (ë™ì„œ ì´ë™ì´ ì£¼)
            const metersPerLngDegree = 88800; // ê²½ë„ 1Â° = 88.8km = 88800m
            const metersMoved = Math.abs(moveDistance) * metersPerLngDegree;

            // í”„ë ˆì„ë‹¹ ì´ë™ê±°ë¦¬, 60 FPS ê¸°ì¤€ìœ¼ë¡œ ì‹œê°„ë‹¹ ì†ë„ ê³„ì‚°
            const framesPerSecond = 60;
            const metersPerHour = metersMoved * framesPerSecond * 3600;

            // ì‹¤ì œ ì¸¡ì •ê°’ 1575 km/hì— ë§ê²Œ ë³´ì • (1575 / 11508.48 â‰ˆ 0.1368)
            const speedMultiplier = 0.1368;
            return (metersPerHour / 1000) * speedMultiplier; // km/hë¡œ ë³€í™˜
        }

        // ì§€ë„ ëª¨ë“œì—ì„œ ì°¨ëŸ‰ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (1ì¸ì¹­ ìš´ì „)
        function updateMapPositions() {
            if (!gameState.mapMode || !map || !gameState.running) return;

            // 1ì¸ì¹­ ëª¨ë“œ: ì°¨ëŸ‰ì€ í•­ìƒ ì§€ë„ ì¤‘ì•™ì— ê³ ì •, ì§€ë„ê°€ ì›€ì§ì„
            const centerLatLng = map.getCenter();
            mapCarPosition = { lat: centerLatLng.lat, lng: centerLatLng.lng };

            // í‚¤ë³´ë“œ ì…ë ¥ì— ë”°ë¼ ê°€ì†/ê°ì† ì ìš©
            let turnAmount = 0;

            // ì „ì§„/í›„ì§„ ê°€ì†ë„ ì ìš©
            if (keys.up) {
                // ì „ì§„: ì†ë„ë¥¼ ì–‘ìˆ˜ë¡œ ì¦ê°€
                currentMapSpeed = Math.min(currentMapSpeed + acceleration, 0.0006); // ìµœê³ ì†ë„ 500 km/h
            } else if (keys.down) {
                // í›„ì§„: ì†ë„ë¥¼ ìŒìˆ˜ë¡œ ê°ì†Œ
                currentMapSpeed = Math.max(currentMapSpeed - acceleration, -0.0003); // í›„ì§„ ìµœê³ ì†ë„
            } else {
                // í‚¤ë¥¼ ë–¼ë©´ ê°ì† ì ìš©
                if (currentMapSpeed > 0) {
                    currentMapSpeed = Math.max(currentMapSpeed - deceleration, 0);
                } else if (currentMapSpeed < 0) {
                    currentMapSpeed = Math.min(currentMapSpeed + deceleration, 0);
                }
            }

            // íšŒì „ì€ ì¦‰ì‹œ ì ìš©
            if (keys.left) turnAmount = -0.025; // ì¢ŒíšŒì „ (ë” ì„¸ë°€í•˜ê²Œ)
            if (keys.right) turnAmount = 0.025; // ìš°íšŒì „ (ë” ì„¸ë°€í•˜ê²Œ)

            const moveDistance = currentMapSpeed;

            if (moveDistance !== 0 || turnAmount !== 0) {
                // ë°©í–¥ ì—…ë°ì´íŠ¸
                mapCarAngle += turnAmount;

                // í˜„ì¬ ì§€ë„ ì¤‘ì‹¬ì—ì„œ ìƒëŒ€ì  ì´ë™ ê³„ì‚°
                const radAngle = mapCarAngle;
                const deltaLat = Math.cos(radAngle) * moveDistance;
                const deltaLng = Math.sin(radAngle) * moveDistance;

                // ìƒˆë¡œìš´ ì§€ë„ ì¤‘ì‹¬ ê³„ì‚°
                const newCenter = L.latLng(
                    centerLatLng.lat + deltaLat,
                    centerLatLng.lng + deltaLng
                );

                // ì§€ë„ ì¤‘ì‹¬ ì´ë™ (ì°¨ëŸ‰ì´ ì¤‘ì•™ì— ìœ ì§€ë¨)
                map.setView(newCenter, map.getZoom());

                // ì°¨ëŸ‰ì€ í™”ë©´ ì¤‘ì•™ì— ê³ ì •ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¶ˆí•„ìš”

                // ì°¨ëŸ‰ íšŒì „ ì ìš© (ë¶ìª½ì´ 0ë„ ê¸°ì¤€)
                const rotationDegrees = (mapCarAngle * 180 / Math.PI) + 90;
                const carElement = document.getElementById('fixedCar');
                if (carElement) {
                    carElement.style.transform = `translate(-50%, -50%) rotate(${rotationDegrees}deg)`;
                }

                // ì‹¤ì œ ì†ë„ ê³„ì‚° ë° í‘œì‹œ (km/h)
                const realSpeedKmh = calculateRealSpeed(moveDistance);
                document.getElementById('speedKmh').textContent = realSpeedKmh.toFixed(1);
            } else {
                // ì •ì§€ ì‹œ ì†ë„ 0ìœ¼ë¡œ í‘œì‹œ
                document.getElementById('speedKmh').textContent = '0.0';
                // ì°¨ëŸ‰ì€ í•­ìƒ í™”ë©´ ì¤‘ì•™ì— ê³ ì •ë˜ì–´ ìˆìŒ
                // ë³„ë„ ì²˜ë¦¬ ë¶ˆí•„ìš”
            }
        }

        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (í”Œë ˆì´ì–´ ì°¨ëŸ‰ì„ í•­ìƒ í™”ë©´ ì¤‘ì•™ì— ìœ„ì¹˜)
        function updateCamera() {
            if (!gameState.firstPersonMode) return;

            const screenCenterX = canvas.width / 2;
            const screenCenterY = canvas.height / 2;

            // í”Œë ˆì´ì–´ ì°¨ëŸ‰ì´ í•­ìƒ í™”ë©´ ì¤‘ì•™ì— ì˜¤ë„ë¡ ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì„¤ì •
            cameraOffsetX = gameState.car.x - screenCenterX;
            cameraOffsetY = gameState.car.y - screenCenterY;

            // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ì´ ë„ˆë¬´ ì»¤ì§€ë©´ ì¢Œí‘œê³„ë¥¼ ì¬ì„¤ì • (ë¶€ë™ì†Œìˆ˜ì  ì •ë°€ë„ ìœ ì§€)
            const maxOffsetBeforeReset = 10000; // 10000px ì´ìƒì´ë©´ ë¦¬ì…‹
            if (Math.abs(cameraOffsetX) > maxOffsetBeforeReset || Math.abs(cameraOffsetY) > maxOffsetBeforeReset) {
                console.log(`ì¢Œí‘œê³„ ì¬ì„¤ì •: ì˜¤í”„ì…‹ (${cameraOffsetX.toFixed(1)}, ${cameraOffsetY.toFixed(1)})`);

                // ëª¨ë“  ê°ì²´ë“¤ì˜ ì¢Œí‘œë¥¼ ì¹´ë©”ë¼ ì˜¤í”„ì…‹ë§Œí¼ ì´ë™ì‹œì¼œ ì¢Œí‘œê³„ ì¬ì„¤ì •
                const resetOffsetX = Math.round(cameraOffsetX);
                const resetOffsetY = Math.round(cameraOffsetY);

                // í”Œë ˆì´ì–´ ì°¨ëŸ‰ ì¢Œí‘œ ì¬ì„¤ì •
                gameState.car.x -= resetOffsetX;
                gameState.car.y -= resetOffsetY;

                // AI ì°¨ëŸ‰ ì¢Œí‘œ ì¬ì„¤ì •
                gameState.aiCars.forEach(aiCar => {
                    aiCar.x -= resetOffsetX;
                    aiCar.y -= resetOffsetY;
                });

                // íŠ¸ë™ ì¢Œí‘œ ì¬ì„¤ì •
                for (let i = 0; i < trackPath.length; i++) {
                    trackPath[i].x -= resetOffsetX;
                    trackPath[i].y -= resetOffsetY;
                }

                // ì¶©ëŒ íš¨ê³¼ ì¢Œí‘œ ì¬ì„¤ì •
                collisionEffects.forEach(effect => {
                    effect.x -= resetOffsetX;
                    effect.y -= resetOffsetY;
                });

                // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ë¦¬ì…‹
                cameraOffsetX = 0;
                cameraOffsetY = 0;

                console.log(`ì¬ì„¤ì • ì™„ë£Œ: ì°¨ëŸ‰ (${gameState.car.x.toFixed(1)}, ${gameState.car.y.toFixed(1)})`);
            }
        }

        // ì›”ë“œ ì¢Œí‘œë¥¼ í™”ë©´ ì¢Œí‘œë¡œ ë³€í™˜
        function worldToScreen(worldX, worldY) {
            if (!gameState.firstPersonMode) {
                return { x: worldX, y: worldY };
            }
            return {
                x: worldX - cameraOffsetX,
                y: worldY - cameraOffsetY
            };
        }

        function startGame() {
            if (!gameState.running) {
                gameState.running = true;
                gameState.startTime = Date.now();
                initAICars();

                // ì§€ë„ ëª¨ë“œì¸ ê²½ìš° ì°¨ëŸ‰ ìœ„ì¹˜ ì´ˆê¸°í™”
                if (gameState.mapMode && map) {
                    const centerPos = map.getCenter();
                    mapCarPosition = { lat: centerPos.lat, lng: centerPos.lng };
                    mapCarAngle = 0; // ë¶ìª½ ë°©í–¥ìœ¼ë¡œ ì‹œì‘
                    currentMapSpeed = 0; // ì†ë„ ì´ˆê¸°í™”

                    // ì°¨ëŸ‰ íšŒì „ ì´ˆê¸°í™”
                    const carElement = document.getElementById('fixedCar');
                    if (carElement) {
                        carElement.style.transform = `translate(-50%, -50%) rotate(90deg)`;
                    }
                }

                gameLoop();
            }
        }
        
        function resetGame() {
            gameState.running = false;
            gameState.car = {
                x: 720,
                y: 430,
                angle: Math.PI,
                speed: 0,
                maxSpeed: 3,
                acceleration: 0.1,
                friction: 0.05,
                turnSpeed: 0.028,
                collisionCooldown: 0,
                name: 'í”Œë ˆì´ì–´',
                color: '#e74c3c',
                lap: 0,
                passedCheckpoint: false
            };
            gameState.timer = 0;
            gameState.lap = 0;
            gameState.passedCheckpoint = false;
            gameState.aiCars = [];

            // ì§€ë„ ëª¨ë“œì¸ ê²½ìš° ì°¨ëŸ‰ ìœ„ì¹˜ ë¦¬ì…‹
            if (gameState.mapMode && map) {
                const centerPos = map.getCenter();
                mapCarPosition = { lat: centerPos.lat, lng: centerPos.lng };
                mapCarAngle = 0; // ë¶ìª½ ë°©í–¥ìœ¼ë¡œ ë¦¬ì…‹
                currentMapSpeed = 0; // ì†ë„ ë¦¬ì…‹

                // ì°¨ëŸ‰ íšŒì „ ë¦¬ì…‹
                const carElement = document.getElementById('fixedCar');
                if (carElement) {
                    carElement.style.transform = `translate(-50%, -50%) rotate(90deg)`;
                }
            }

            updateUI();
        }
        
        function updateCar() {
            const car = gameState.car;
            
            // ì¶©ëŒ ì¿¨ë‹¤ìš´ ê°ì†Œ
            if (car.collisionCooldown > 0) {
                car.collisionCooldown--;
            }
            
            // ì´ì „ ìœ„ì¹˜ ì €ì¥
            const prevX = car.x;
            const prevY = car.y;
            const prevSpeed = car.speed;
            
            // ê°€ì†/ê°ì†
            if (keys.up) {
                car.speed = Math.min(car.speed + car.acceleration, car.maxSpeed);
            } else if (keys.down) {
                car.speed = Math.max(car.speed - car.acceleration, -car.maxSpeed / 2);
            } else {
                // ë§ˆì°°ë ¥
                if (car.speed > 0) {
                    car.speed = Math.max(0, car.speed - car.friction);
                } else if (car.speed < 0) {
                    car.speed = Math.min(0, car.speed + car.friction);
                }
            }
            
            // íšŒì „
            if (keys.left && Math.abs(car.speed) > 0.5) {
                car.angle -= car.turnSpeed;
            }
            if (keys.right && Math.abs(car.speed) > 0.5) {
                car.angle += car.turnSpeed;
            }
            
            // ì´ë™
            car.x += Math.cos(car.angle) * car.speed;
            car.y += Math.sin(car.angle) * car.speed;
            
            // ì¶©ëŒ ê°ì§€ (ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ì¶©ëŒ ë¬´ì‹œ)
            if (checkCollision(car.x, car.y) && car.collisionCooldown <= 0) {
                // íŠ¸ë™ ê²½ê³„ë¡œë¶€í„°ì˜ ë°˜ë°œë ¥ ê³„ì‚°
                const nearestPoint = findNearestTrackPoint(car.x, car.y);
                const bounceAngle = Math.atan2(car.y - nearestPoint.y, car.x - nearestPoint.x);

                // ê°•í•œ íŠ•ê¹€ íš¨ê³¼
                const bounceStrength = Math.abs(prevSpeed) * 1.5;
                car.x = prevX + Math.cos(bounceAngle) * bounceStrength;
                car.y = prevY + Math.sin(bounceAngle) * bounceStrength;

                // ì†ë„ ë°˜ì „ ë° ê°ì†Œ
                car.speed = -prevSpeed * 0.6;

                // ì°¨ëŸ‰ ë°©í–¥ë„ ì•½ê°„ ë³€ê²½
                car.angle += (Math.random() - 0.5) * 0.4;

                // 1ì´ˆ ë™ì•ˆ ì¶”ê°€ ì¶©ëŒ ë¬´ì‹œ (60í”„ë ˆì„)
                car.collisionCooldown = 60;

                // ì¶©ëŒ íš¨ê³¼ í‘œì‹œ
                showCollisionEffect(car.x, car.y);
            }
            
            // ì²´í¬í¬ì¸íŠ¸ í™•ì¸
            checkCheckpoint();
        }
        
        function checkCollision(x, y) {
            // íŠ¸ë™ ì¤‘ì‹¬ì„ ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬ ê³„ì‚°
            let minDistance = Infinity;
            
            for (let i = 0; i < trackPath.length; i++) {
                const p1 = trackPath[i];
                const p2 = trackPath[(i + 1) % trackPath.length];
                
                const distance = distanceToSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                minDistance = Math.min(minDistance, distance);
            }
            
            // íŠ¸ë™ í­ì˜ ì ˆë°˜ë³´ë‹¤ ë©€ë¦¬ ìˆìœ¼ë©´ ì¶©ëŒ
            return minDistance > trackWidth / 2;
        }
        
        function distanceToSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;
            
            if (lengthSquared === 0) {
                return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            }
            
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));
            
            const projX = x1 + t * dx;
            const projY = y1 + t * dy;
            
            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }
        
        let collisionEffects = [];
        
        function showCollisionEffect(x, y) {
            collisionEffects.push({
                x: x,
                y: y,
                life: 20,
                maxLife: 20
            });
        }
        
        function checkCheckpoint() {
            const car = gameState.car;
            
            // ì¤‘ê°„ ì²´í¬í¬ì¸íŠ¸ (ì™¼ìª½ í•˜ë‹¨ ë¶€ê·¼)
            if (!car.passedCheckpoint && 
                car.x > 150 && car.x < 250 && 
                car.y > 550 && car.y < 650) {
                car.passedCheckpoint = true;
                gameState.passedCheckpoint = true;
            }
            
            // ê²°ìŠ¹ì„  (ì˜¤ë¥¸ìª½ ì¤‘ê°„ ë¶€ê·¼)
            if (car.passedCheckpoint && 
                car.x > 680 && car.x < 750 && 
                car.y > 400 && car.y < 460) {
                car.lap++;
                gameState.lap = car.lap;
                car.passedCheckpoint = false;
                gameState.passedCheckpoint = false;
                
                if (car.lap >= gameState.maxLaps) {
                    gameState.running = false;
                    const rankings = calculateRankings();
                    const playerRank = rankings.findIndex(c => c.name === 'í”Œë ˆì´ì–´') + 1;
                    alert(`ğŸ ì™„ì£¼! ${playerRank}ìœ„ë¡œ í”¼ë‹ˆì‹œ!\nê¸°ë¡: ${gameState.timer.toFixed(1)}ì´ˆ`);
                }
            }
        }
        
        function drawTrack() {
            // ë°°ê²½
            ctx.fillStyle = '#e8e8e8';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // íŠ¸ë™ ê·¸ë¦¬ê¸° (íšŒìƒ‰)
            ctx.strokeStyle = '#6b6b6b';
            ctx.lineWidth = trackWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.setLineDash([]);
            ctx.beginPath();
            for (let i = 0; i < trackPath.length; i++) {
                const point = trackPath[i];
                const screenPos = worldToScreen(point.x, point.y);
                if (i === 0) ctx.moveTo(screenPos.x, screenPos.y);
                else ctx.lineTo(screenPos.x, screenPos.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // íŠ¸ë™ ì™¸ê³½ (ê²€ì€ìƒ‰ í…Œë‘ë¦¬)
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = trackWidth + 12;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.setLineDash([15, 15]);
            ctx.beginPath();
            for (let i = 0; i < trackPath.length; i++) {
                const point = trackPath[i];
                const screenPos = worldToScreen(point.x, point.y);
                if (i === 0) ctx.moveTo(screenPos.x, screenPos.y);
                else ctx.lineTo(screenPos.x, screenPos.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // íŠ¸ë™ ì¤‘ì‹¬ì„  (í•˜ì–€ ì ì„ )
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.setLineDash([15, 15]);
            ctx.beginPath();
            for (let i = 0; i < trackPath.length; i++) {
                const point = trackPath[i];
                const screenPos = worldToScreen(point.x, point.y);
                if (i === 0) ctx.moveTo(screenPos.x, screenPos.y);
                else ctx.lineTo(screenPos.x, screenPos.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ê²°ìŠ¹ì„ 
            const finishX = 720;
            const finishY = 430;
            const finishScreenPos = worldToScreen(finishX, finishY);
            ctx.fillStyle = '#000';
            for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 2; j++) {
                    if ((i + j) % 2 === 0) {
                        ctx.fillStyle = '#000';
                    } else {
                        ctx.fillStyle = '#fff';
                    }
                    ctx.fillRect(finishScreenPos.x - 20 + j * 10, finishScreenPos.y - 40 + i * 10, 10, 10);
                }
            }

            // íŠ¸ë™ ë°©í–¥ í™”ì‚´í‘œ í‘œì‹œ
            drawDirectionArrows();
        }

        // íŠ¸ë™ ë°©í–¥ í™”ì‚´í‘œë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜
        function drawDirectionArrows() {
            ctx.fillStyle = '#ffff00'; // ë…¸ë€ìƒ‰ìœ¼ë¡œ ë” ì˜ ë³´ì´ê²Œ
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3; // ì„  êµµê¸°ë„ í‚¤ì›€

            // ì‹œì‘ì ì— í° ë°©í–¥ í™”ì‚´í‘œ í‘œì‹œ
            if (trackPath.length > 1) {
                const startPoint = trackPath[0];
                const nextPoint = trackPath[1];
                const angle = Math.atan2(nextPoint.y - startPoint.y, nextPoint.x - startPoint.x);
                const arrowPos = worldToScreen(startPoint.x + 50, startPoint.y);

                ctx.save();
                ctx.translate(arrowPos.x, arrowPos.y); // ì‹œì‘ì ì—ì„œ ì•½ê°„ ë–¨ì–´ì§„ ê³³ì—
                ctx.rotate(angle);

                // í° ì‹œì‘ í™”ì‚´í‘œ (2ë°° í¬ê¸°)
                ctx.fillStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì‹œì‘ì  ê°•ì¡°
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 6; // ì„  êµµê¸°ë„ 2ë°°

                // í™”ì‚´í‘œ ëª¸ì²´
                ctx.beginPath();
                ctx.moveTo(-30, 0);
                ctx.lineTo(30, 0);
                ctx.stroke();

                // í™”ì‚´í‘œ ë¨¸ë¦¬
                ctx.beginPath();
                ctx.moveTo(30, 0);
                ctx.lineTo(10, -16);
                ctx.lineTo(10, 16);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }

            // íŠ¸ë™ì„ ë”°ë¼ ë°©í–¥ í™”ì‚´í‘œ í‘œì‹œ (ì¼ì • ê°„ê²©ìœ¼ë¡œ, 2ë°° í¬ê¸°)
            const arrowSpacing = Math.max(4, Math.floor(trackPath.length / 12)); // ê°„ê²©ë„ ì•½ê°„ ë„“í˜

            for (let i = 1; i < trackPath.length - 1; i += arrowSpacing) {
                const currentPoint = trackPath[i];
                const nextPoint = trackPath[i + 1] || trackPath[0];

                // ë‘ ì  ì‚¬ì´ì˜ ì¤‘ê°„ ì§€ì  ê³„ì‚°
                const midX = (currentPoint.x + nextPoint.x) / 2;
                const midY = (currentPoint.y + nextPoint.y) / 2;
                const arrowPos = worldToScreen(midX, midY);

                // ë°©í–¥ ë²¡í„° ê³„ì‚°
                const dx = nextPoint.x - currentPoint.x;
                const dy = nextPoint.y - currentPoint.y;
                const angle = Math.atan2(dy, dx);

                // í™”ì‚´í‘œ ê·¸ë¦¬ê¸°
                ctx.save();
                ctx.translate(arrowPos.x, arrowPos.y);
                ctx.rotate(angle);

                // ë°©í–¥ í™”ì‚´í‘œ (2ë°° í¬ê¸°)
                ctx.fillStyle = '#ffff00'; // ë…¸ë€ìƒ‰
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2; // ì„  êµµê¸°ë„ í‚¤ì›€

                // í™”ì‚´í‘œ ëª¸ì²´
                ctx.beginPath();
                ctx.moveTo(-12, 0);
                ctx.lineTo(12, 0);
                ctx.stroke();

                // í™”ì‚´í‘œ ë¨¸ë¦¬
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(4, -6);
                ctx.lineTo(4, 6);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                ctx.restore();
            }
        }
        
        function drawCar() {
            const car = gameState.car;

            ctx.save();
            if (gameState.firstPersonMode) {
                // 1ì¸ì¹­ ëª¨ë“œ: í”Œë ˆì´ì–´ ì°¨ëŸ‰ì„ í™”ë©´ ì¤‘ì•™ì— ê³ ì •
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(car.angle);
            } else {
                // 3ì¸ì¹­ ëª¨ë“œ: ê¸°ì¡´ ë°©ì‹ëŒ€ë¡œ ì›”ë“œ ì¢Œí‘œ ì‚¬ìš©
                const screenPos = worldToScreen(car.x, car.y);
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(car.angle);
            }

            // ìë™ì°¨ ëª¸ì²´ (20% ê°ì†Œ)
            ctx.fillStyle = '#e74c3c';
            ctx.fillRect(-8.82, -5.88, 17.64, 11.76);

            // ìë™ì°¨ ì°½ë¬¸ (20% ê°ì†Œ)
            ctx.fillStyle = '#3498db';
            ctx.fillRect(-2.94, -4.116, 5.88, 8.232);

            // ë°”í€´ (20% ê°ì†Œ)
            ctx.fillStyle = '#000';
            ctx.fillRect(-7.056, -7.056, 4.704, 2.94);
            ctx.fillRect(-7.056, 4.116, 4.704, 2.94);
            ctx.fillRect(2.352, -7.056, 4.704, 2.94);
            ctx.fillRect(2.352, 4.116, 4.704, 2.94);

            // í—¤ë“œë¼ì´íŠ¸ (í”Œë ˆì´ì–´ ì°¨ëŸ‰ ì „ë©´ì— ë¶ˆì¼œì§„ ë¼ì´íŠ¸, 20% ê°ì†Œ)
            ctx.fillStyle = '#ffff99';
            ctx.beginPath();
            ctx.arc(8.82, -3.92, 1.568, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(8.82, 3.92, 1.568, 0, Math.PI * 2);
            ctx.fill();

            // í—¤ë“œë¼ì´íŠ¸ ë¹› íš¨ê³¼ (20% ê°ì†Œ)
            const gradient = ctx.createRadialGradient(11.76, 0, 0, 11.76, 0, 9.8);
            gradient.addColorStop(0, 'rgba(255, 255, 153, 0.6)');
            gradient.addColorStop(1, 'rgba(255, 255, 153, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(11.76, 0, 9.8, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        
        function drawAICar(aiCar) {
            ctx.save();
            const screenPos = worldToScreen(aiCar.x, aiCar.y);
            ctx.translate(screenPos.x, screenPos.y);
            ctx.rotate(aiCar.angle);

            // ìë™ì°¨ ëª¸ì²´ (20% ê°ì†Œ)
            ctx.fillStyle = aiCar.color;
            ctx.fillRect(-8.82, -5.88, 17.64, 11.76);

            // ìë™ì°¨ ì°½ë¬¸ (20% ê°ì†Œ)
            ctx.fillStyle = '#34495e';
            ctx.fillRect(-2.94, -4.116, 5.88, 8.232);

            // ë°”í€´ (20% ê°ì†Œ)
            ctx.fillStyle = '#000';
            ctx.fillRect(-7.056, -7.056, 4.704, 2.94);
            ctx.fillRect(-7.056, 4.116, 4.704, 2.94);
            ctx.fillRect(2.352, -7.056, 4.704, 2.94);
            ctx.fillRect(2.352, 4.116, 4.704, 2.94);

            // í—¤ë“œë¼ì´íŠ¸ (AI ì°¨ëŸ‰ ì „ë©´ì— ëœë¤ ìƒ‰ìƒ ë¼ì´íŠ¸)
            ctx.fillStyle = aiCar.headlightColor;
            ctx.beginPath();
            ctx.arc(11.025, -4.9, 1.96, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(11.025, 4.9, 1.96, 0, Math.PI * 2);
            ctx.fill();

            // í—¤ë“œë¼ì´íŠ¸ ë¹› íš¨ê³¼
            const gradient = ctx.createRadialGradient(14.7, 0, 0, 14.7, 0, 12.25);
            gradient.addColorStop(0, aiCar.headlightColor + '66'); // ìƒ‰ìƒì— íˆ¬ëª…ë„ ì¶”ê°€
            gradient.addColorStop(1, aiCar.headlightColor + '00');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(14.7, 0, 12.25, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
        }
        
        function updateAICars() {
            gameState.aiCars.forEach(aiCar => {
                // ì´ì „ ìœ„ì¹˜ ì €ì¥
                const prevX = aiCar.x;
                const prevY = aiCar.y;
                const prevAngle = aiCar.angle;
                const prevSpeed = aiCar.speed;
                
                // ë³µêµ¬ ì‹œê°„ ê°ì†Œ
                if (aiCar.recoveryTime > 0) {
                    aiCar.recoveryTime--;
                }
                
                // ì¶©ëŒ ì¿¨ë‹¤ìš´ ê°ì†Œ
                if (aiCar.collisionCooldown > 0) {
                    aiCar.collisionCooldown--;
                }
                
                // í˜„ì¬ íŠ¸ë™ ì¶©ëŒ ìƒíƒœ í™•ì¸
                const isOffTrack = checkCollision(aiCar.x, aiCar.y);
                
                // íŠ¸ë™ ì´íƒˆ ì‹œ ì¦‰ì‹œ ë³µêµ¬ ëª¨ë“œ
                if (isOffTrack) {
                    aiCar.recoveryTime = Math.max(aiCar.recoveryTime, 40);
                }
                
                // ëª©í‘œ ì§€ì  ì„¤ì • (ë³µêµ¬ ëª¨ë“œì—ì„œëŠ” í›¨ì”¬ ë” ë¨¼ ì§€ì )
                const lookAhead = aiCar.recoveryTime > 0 ? 15 : 6;
                const targetIndex = (aiCar.pathIndex + lookAhead) % trackPath.length;
                const target = trackPath[targetIndex];
                
                // ê°€ì¥ ê°€ê¹Œìš´ íŠ¸ë™ ì§€ì  ì°¾ê¸°
                const nearestTrackPoint = findNearestTrackPoint(aiCar.x, aiCar.y);
                const distToNearestTrack = Math.sqrt(
                    (nearestTrackPoint.x - aiCar.x) ** 2 + 
                    (nearestTrackPoint.y - aiCar.y) ** 2
                );
                
                // ë³µêµ¬ ëª¨ë“œ: íŠ¸ë™ì—ì„œ ë©€ë¦¬ ìˆìœ¼ë©´ íŠ¸ë™ìœ¼ë¡œ ë¨¼ì € í–¥í•¨
                let targetX, targetY;
                if (aiCar.recoveryTime > 0 && distToNearestTrack > 20) {
                    targetX = nearestTrackPoint.x;
                    targetY = nearestTrackPoint.y;
                } else {
                    targetX = target.x;
                    targetY = target.y;
                }
                
                // ëª©í‘œ ë°©í–¥ ê³„ì‚°
                const dx = targetX - aiCar.x;
                const dy = targetY - aiCar.y;
                const targetAngle = Math.atan2(dy, dx);
                
                // ê°ë„ ì°¨ì´ ê³„ì‚° (-Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”)
                let angleDiff = targetAngle - aiCar.angle;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                
                // íšŒì „ ì†ë„ ì¡°ì • (ë³µêµ¬ ì¤‘ì—ëŠ” í›¨ì”¬ ë” ë¹ ë¥´ê²Œ)
                let turnMultiplier = 1;
                if (aiCar.recoveryTime > 0) {
                    turnMultiplier = isOffTrack ? 2.5 : 1.8;
                }
                
                // ë¶€ë“œëŸ¬ìš´ íšŒì „
                if (Math.abs(angleDiff) > 0.03) {
                    const turnAmount = Math.min(Math.abs(angleDiff), aiCar.turnSpeed * turnMultiplier);
                    aiCar.angle += Math.sign(angleDiff) * turnAmount;
                }
                
                // ì†ë„ ì¡°ì ˆ
                let targetSpeed;
                if (isOffTrack) {
                    // íŠ¸ë™ ì´íƒˆ ì‹œ ì†ë„ í¬ê²Œ ê°ì†Œ
                    targetSpeed = aiCar.maxSpeed * 0.3;
                } else if (aiCar.recoveryTime > 0) {
                    // ë³µêµ¬ ì¤‘
                    targetSpeed = aiCar.maxSpeed * 0.7;
                } else if (Math.abs(angleDiff) > 0.5) {
                    // ê¸‰ì»¤ë¸Œ
                    targetSpeed = aiCar.maxSpeed * 0.6;
                } else {
                    // ì •ìƒ ì£¼í–‰
                    targetSpeed = aiCar.maxSpeed;
                }
                
                // ê°€ì†/ê°ì†
                if (aiCar.speed < targetSpeed) {
                    const accelMultiplier = aiCar.recoveryTime > 0 ? 1.5 : 1;
                    aiCar.speed = Math.min(aiCar.speed + aiCar.acceleration * accelMultiplier, targetSpeed);
                } else {
                    aiCar.speed = Math.max(aiCar.speed - aiCar.friction * 2, targetSpeed);
                }
                
                // ì´ë™
                const moveDistance = Math.abs(aiCar.speed);
                aiCar.x += Math.cos(aiCar.angle) * aiCar.speed;
                aiCar.y += Math.sin(aiCar.angle) * aiCar.speed;
                
                // ì´ë™ í›„ íŠ¸ë™ ì¶©ëŒ ì²´í¬ (ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ì¶©ëŒ ë¬´ì‹œ)
                if (checkCollision(aiCar.x, aiCar.y) && aiCar.collisionCooldown <= 0) {
                    // íŠ¸ë™ ê²½ê³„ë¡œë¶€í„°ì˜ ë°˜ë°œë ¥ ê³„ì‚°
                    const bounceAngle = Math.atan2(aiCar.y - nearestTrackPoint.y, aiCar.x - nearestTrackPoint.x);

                    // ê°•í•œ íŠ•ê¹€ íš¨ê³¼
                    const bounceStrength = Math.abs(prevSpeed) * 1.2;
                    aiCar.x = prevX + Math.cos(bounceAngle) * bounceStrength;
                    aiCar.y = prevY + Math.sin(bounceAngle) * bounceStrength;

                    // ì†ë„ ë°˜ì „ ë° ê°ì†Œ
                    aiCar.speed = -prevSpeed * 0.5;

                    // ì°¨ëŸ‰ ë°©í–¥ ë³€ê²½
                    aiCar.angle += (Math.random() - 0.5) * 0.4;

                    // 1ì´ˆ ë™ì•ˆ ì¶”ê°€ ì¶©ëŒ ë¬´ì‹œ (60í”„ë ˆì„)
                    aiCar.collisionCooldown = 60;

                    // ì¶©ëŒ í›„ ë‹¤ì‹œ íŠ¸ë™ ë°–ì´ë©´ ê°•ì œ íŠ¸ë™ ì¤‘ì‹¬ í–¥í•˜ê¸°
                    if (checkCollision(aiCar.x, aiCar.y)) {
                        aiCar.x = prevX;
                        aiCar.y = prevY;
                        const angleToTrack = Math.atan2(
                            nearestTrackPoint.y - aiCar.y,
                            nearestTrackPoint.x - aiCar.x
                        );
                        aiCar.angle = angleToTrack;
                        aiCar.speed *= 0.3;
                    }

                    aiCar.recoveryTime = 50;
                    showCollisionEffect(aiCar.x, aiCar.y);
                }
                
                // ê²½ë¡œ í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸
                const distToTarget = Math.sqrt(
                    (target.x - aiCar.x) ** 2 + 
                    (target.y - aiCar.y) ** 2
                );
                if (distToTarget < 50) {
                    aiCar.pathIndex = (aiCar.pathIndex + 1) % trackPath.length;
                }
                
                // AI ì²´í¬í¬ì¸íŠ¸ í™•ì¸
                checkAICheckpoint(aiCar);
            });
            
            // AI ì°¨ëŸ‰ ê°„ ì¶©ëŒ ì²´í¬
            for (let i = 0; i < gameState.aiCars.length; i++) {
                for (let j = i + 1; j < gameState.aiCars.length; j++) {
                    checkCarCollision(gameState.aiCars[i], gameState.aiCars[j]);
                }
                // í”Œë ˆì´ì–´ì™€ AI ì°¨ëŸ‰ ì¶©ëŒ
                checkCarCollision(gameState.car, gameState.aiCars[i]);
            }
        }
        
        function findNearestTrackPoint(x, y) {
            let nearestPoint = trackPath[0];
            let minDist = Infinity;
            
            for (let i = 0; i < trackPath.length; i++) {
                const point = trackPath[i];
                const dist = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
                if (dist < minDist) {
                    minDist = dist;
                    nearestPoint = point;
                }
            }
            
            return nearestPoint;
        }
        
        function checkCarCollision(car1, car2) {
            // ì¿¨ë‹¤ìš´ ì¤‘ì´ë©´ ì¶©ëŒ ë¬´ì‹œ
            if (car1.collisionCooldown > 0 || car2.collisionCooldown > 0) {
                return;
            }
            
            const dx = car1.x - car2.x;
            const dy = car1.y - car2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // ì°¨ëŸ‰ í¬ê¸°ë¥¼ ê³ ë ¤í•œ ì¶©ëŒ ë°˜ê²½ (20% ê°ì†Œ)
            const collisionRadius = 7.35;
            
            if (distance < collisionRadius && distance > 0) {
                // ì¶©ëŒ ë°©í–¥ ê³„ì‚°
                const angle = Math.atan2(dy, dx);
                
                // ê°•í•œ íŠ•ê¹€ íš¨ê³¼
                const pushForce = (collisionRadius - distance) * 0.8;
                const pushX = Math.cos(angle) * pushForce;
                const pushY = Math.sin(angle) * pushForce;
                
                // ì°¨ëŸ‰ ê°•í•˜ê²Œ ë¶„ë¦¬
                car1.x += pushX;
                car1.y += pushY;
                car2.x -= pushX;
                car2.y -= pushY;
                
                // ì†ë„ êµí™˜ ë° íŠ•ê¹€ (ë” ê°•í•œ íš¨ê³¼)
                const relativeVelocity = car1.speed - car2.speed;
                const impactStrength = 1.2; // íŠ•ê¹€ ê°•ë„
                
                car1.speed = (car2.speed + relativeVelocity * 0.3) * impactStrength;
                car2.speed = (car1.speed - relativeVelocity * 0.3) * impactStrength;
                
                // ì¶©ëŒ ê°ë„ë¡œ ì°¨ëŸ‰ ë°©í–¥ ë³€ê²½
                car1.angle += (Math.random() - 0.5) * 0.3;
                car2.angle += (Math.random() - 0.5) * 0.3;
                
                // ì¶©ëŒ ì¿¨ë‹¤ìš´ ì„¤ì • (ì•½ 1ì´ˆ = 60í”„ë ˆì„)
                car1.collisionCooldown = 60;
                car2.collisionCooldown = 60;
                
                // AI ì°¨ëŸ‰ì´ë©´ ë³µêµ¬ ëª¨ë“œ í™œì„±í™”
                if (car1.recoveryTime !== undefined) {
                    car1.recoveryTime = 20;
                }
                if (car2.recoveryTime !== undefined) {
                    car2.recoveryTime = 20;
                }
                
                // ì¶©ëŒ íš¨ê³¼
                showCollisionEffect((car1.x + car2.x) / 2, (car1.y + car2.y) / 2);
            }
        }
        
        function checkAICheckpoint(aiCar) {
            // ì¤‘ê°„ ì²´í¬í¬ì¸íŠ¸
            if (!aiCar.passedCheckpoint && 
                aiCar.x > 150 && aiCar.x < 250 && 
                aiCar.y > 550 && aiCar.y < 650) {
                aiCar.passedCheckpoint = true;
            }
            
            // ê²°ìŠ¹ì„ 
            if (aiCar.passedCheckpoint && 
                aiCar.x > 680 && aiCar.x < 750 && 
                aiCar.y > 400 && aiCar.y < 460) {
                aiCar.lap++;
                aiCar.passedCheckpoint = false;
            }
        }
        
        function updateUI() {
            document.getElementById('timer').textContent = gameState.timer.toFixed(1);
            document.getElementById('lap').textContent = gameState.car.lap;
            document.getElementById('speed').textContent = Math.abs(gameState.car.speed).toFixed(1);

            // ì§€ë„ ëª¨ë“œê°€ ì•„ë‹ ë•ŒëŠ” km/h í‘œì‹œë¥¼ 0ìœ¼ë¡œ
            if (!gameState.mapMode) {
                document.getElementById('speedKmh').textContent = '0.0';
            }

            updateRankings();
        }
        
        function calculateRankings() {
            const allCars = [gameState.car, ...gameState.aiCars];
            
            // ê° ì°¨ëŸ‰ì˜ ì§„í–‰ë„ ê³„ì‚°
            const carsWithProgress = allCars.map(car => {
                // ë© ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ìš°ì„ 
                // ê°™ì€ ë©ì´ë©´ pathIndexê°€ ë†’ì„ìˆ˜ë¡ ìš°ì„  (AIë§Œ í•´ë‹¹)
                // í”Œë ˆì´ì–´ëŠ” í˜„ì¬ ìœ„ì¹˜ë¡œ ì§„í–‰ë„ ê³„ì‚°
                let progress;
                if (car.pathIndex !== undefined) {
                    // AI ì°¨ëŸ‰
                    progress = car.lap * trackPath.length + car.pathIndex;
                } else {
                    // í”Œë ˆì´ì–´: ê°€ì¥ ê°€ê¹Œìš´ ê²½ë¡œ í¬ì¸íŠ¸ ì°¾ê¸°
                    let closestIndex = 0;
                    let minDist = Infinity;
                    for (let i = 0; i < trackPath.length; i++) {
                        const dist = Math.sqrt(
                            (trackPath[i].x - car.x) ** 2 + 
                            (trackPath[i].y - car.y) ** 2
                        );
                        if (dist < minDist) {
                            minDist = dist;
                            closestIndex = i;
                        }
                    }
                    progress = car.lap * trackPath.length + closestIndex;
                }
                
                return {
                    name: car.name,
                    color: car.color,
                    lap: car.lap,
                    progress: progress
                };
            });
            
            // ì§„í–‰ë„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬
            carsWithProgress.sort((a, b) => b.progress - a.progress);
            
            return carsWithProgress;
        }
        
        function updateRankings() {
            const rankings = calculateRankings();
            const rankingList = document.getElementById('rankingList');
            
            rankingList.innerHTML = rankings.map((car, index) => {
                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : 'ğŸ';
                const isPlayer = car.name === 'í”Œë ˆì´ì–´';
                const style = isPlayer ? 'font-weight: bold; background: #fff3cd;' : '';
                
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; border-radius: 4px; ${style}">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 20px;">${medal}</span>
                            <span style="font-size: 18px;">${index + 1}ìœ„</span>
                            <span style="width: 15px; height: 15px; background: ${car.color}; border-radius: 50%; display: inline-block;"></span>
                            <span>${car.name}</span>
                        </div>
                        <div style="font-weight: bold; color: #666;">
                            ${car.lap}/${gameState.maxLaps} ë©
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function gameLoop() {
            if (!gameState.running) return;

            gameState.timer = (Date.now() - gameState.startTime) / 1000;

            if (gameState.mapMode) {
                // ì§€ë„ ëª¨ë“œ
                updateMapPositions();
            } else {
                // ì¼ë°˜ íŠ¸ë™ ëª¨ë“œ
                updateCar();
                updateAICars();
                updateCamera();

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawTrack();
                drawCollisionEffects();

                // AI ì°¨ëŸ‰ ë¨¼ì € ê·¸ë¦¬ê¸°
                gameState.aiCars.forEach(aiCar => drawAICar(aiCar));

                // í”Œë ˆì´ì–´ ì°¨ëŸ‰ ìœ„ì— ê·¸ë¦¬ê¸°
                drawCar();
            }

            updateUI();

            requestAnimationFrame(gameLoop);
        }
        
        function drawCollisionEffects() {
            collisionEffects = collisionEffects.filter(effect => {
                effect.life--;
                
                const alpha = effect.life / effect.maxLife;
                const radius = 20 * (1 - alpha);
                
                const effectScreenPos = worldToScreen(effect.x, effect.y);

                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(effectScreenPos.x, effectScreenPos.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // ì¶©ëŒ íŒŒí¸ íš¨ê³¼
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const distance = radius * 1.5;
                    ctx.fillStyle = '#ff6b6b';
                    ctx.beginPath();
                    ctx.arc(
                        effectScreenPos.x + Math.cos(angle) * distance,
                        effectScreenPos.y + Math.sin(angle) * distance,
                        2, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                ctx.restore();
                
                return effect.life > 0;
            });
        }
        
        // ì´ˆê¸° í™”ë©´ ê·¸ë¦¬ê¸°
        drawTrack();
        drawCar();
        initAICars();
        gameState.aiCars.forEach(aiCar => drawAICar(aiCar));
        updateUI();
    </script>
</body>
</html>