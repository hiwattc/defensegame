<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë°©ì–´ ì „íˆ¬ ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        #gameContainer {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            width: 1400px;
            height: 800px;
            position: relative;
        }
        #gameCanvas {
            display: block;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
        }
        #canvasWrapper {
            width: 100%;
            height: 750px;
            overflow: hidden;
            position: relative;
            background: #000;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 240px;
            height: 140px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #4facfe;
            border-radius: 10px;
            z-index: 10;
            cursor: pointer;
        }
        #minimapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            padding: 15px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }
        .team-info {
            display: flex;
            gap: 20px;
        }
        .stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #startBtn {
            padding: 10px 30px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        #startBtn:hover {
            transform: scale(1.05);
        }
        #startBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .selection-box {
            position: absolute;
            border: 2px dashed #4facfe;
            background: rgba(79, 172, 254, 0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="info">
            <div class="team-info">
                <div class="stat">ğŸ”µ ì•„êµ°: <span id="blueCount">12</span></div>
                <div class="stat">ğŸ¯ ìŠ¤í…Œì´ì§€: <span id="stage">1</span></div>
            </div>
            <button id="startBtn">ì „íˆ¬ ì‹œì‘</button>
            <div class="team-info">
                <div class="stat">ğŸ”´ ì êµ°: <span id="redCount">12</span></div>
                <div class="stat">âŒ¨ï¸ í™”ì‚´í‘œ í‚¤ë¡œ í™”ë©´ ì´ë™</div>
            </div>
        </div>
        <div id="canvasWrapper">
            <canvas id="gameCanvas" width="4800" height="2800"></canvas>
            <div id="minimap">
                <canvas id="minimapCanvas" width="240" height="140"></canvas>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const blueCountEl = document.getElementById('blueCount');
        const redCountEl = document.getElementById('redCount');
        const stageEl = document.getElementById('stage');

        // ì¹´ë©”ë¼ ìœ„ì¹˜
        let cameraX = 0;
        let cameraY = 0;
        const cameraSpeed = 20;
        
        // ë¯¸ë‹ˆë§µ ìŠ¤ì¼€ì¼
        const minimapScale = minimapCanvas.width / canvas.width;

        let gameStarted = false;
        let units = [];
        let particles = [];
        let selectedUnits = [];
        let selectionStart = null;
        let selectionEnd = null;
        let lastFrameTime = 0;
        const targetFPS = 60;
        const frameTime = 1000 / targetFPS;
        let currentStage = 1;
        let enemyCount = 12;

        // ë²„í”„ ì§€í˜• ìƒì„±
        const buffZones = [];
        function generateBuffZones() {
            const leftSide = canvas.width * 0.25;
            const rightSide = canvas.width * 0.75;
            const centerZone = canvas.width * 0.5;
            
            // ì™¼ìª½ ì§„ì˜ ë²„í”„ì¡´
            // ì—°ë‘ìƒ‰ (1.5ë°°) - 2ê°œ
            for(let i = 0; i < 2; i++) {
                buffZones.push({
                    x: 100 + Math.random() * 150,
                    y: 150 + i * 250,
                    type: 'green',
                    radius: 70,
                    multiplier: 1.5
                });
            }
            // íŒŒë‘ìƒ‰ (2ë°°) - 1ê°œ
            buffZones.push({
                x: leftSide - 50,
                y: canvas.height / 2,
                type: 'blue',
                radius: 75,
                multiplier: 2.0
            });
            
            // ì˜¤ë¥¸ìª½ ì§„ì˜ ë²„í”„ì¡´ (ëŒ€ì¹­)
            // ì—°ë‘ìƒ‰ (1.5ë°°) - 2ê°œ
            for(let i = 0; i < 2; i++) {
                buffZones.push({
                    x: canvas.width - 100 - Math.random() * 150,
                    y: 150 + i * 250,
                    type: 'green',
                    radius: 70,
                    multiplier: 1.5
                });
            }
            // íŒŒë‘ìƒ‰ (2ë°°) - 1ê°œ
            buffZones.push({
                x: rightSide + 50,
                y: canvas.height / 2,
                type: 'blue',
                radius: 75,
                multiplier: 2.0
            });
            
            // ì¤‘ì•™ ê²©ì „ì§€ ë²„í”„ì¡´
            // ë¹¨ê°•ìƒ‰ (3ë°°) - 2ê°œ (ì¤‘ì•™ ìƒí•˜)
            buffZones.push({
                x: centerZone,
                y: canvas.height * 0.35,
                type: 'red',
                radius: 80,
                multiplier: 3.0
            });
            buffZones.push({
                x: centerZone,
                y: canvas.height * 0.65,
                type: 'red',
                radius: 80,
                multiplier: 3.0
            });
            
            // ì¤‘ì•™ íŒŒë‘ìƒ‰ (2ë°°) - 1ê°œ
            buffZones.push({
                x: centerZone,
                y: canvas.height / 2,
                type: 'blue',
                radius: 70,
                multiplier: 2.0
            });
        }

        class Unit {
            constructor(x, y, team, type) {
                this.x = x;
                this.y = y;
                this.team = team;
                this.type = 'archer'; // ëª¨ë‘ ê¶ìˆ˜ë¡œ ë³€ê²½
                this.hp = 80;
                this.maxHp = this.hp;
                this.speed = 1.3;
                this.range = 300;
                this.damage = 18;
                this.attackCooldown = 0;
                this.attackSpeed = 50;
                this.emoji = this.getEmoji();
                this.targetX = x;
                this.targetY = y;
                this.selected = false;
                this.angle = team === 'blue' ? 0 : Math.PI;
                this.baseRange = 300; // ê¸°ë³¸ ì‚¬ê±°ë¦¬
                this.currentRangeMultiplier = 1.0;
                this.targetBuffZone = null; // ëª©í‘œ ë²„í”„ì¡´
                this.buffZoneCheckCooldown = 0;
            }

            getEmoji() {
                if(this.team === 'blue') {
                    return 'ğŸ±';
                } else {
                    return 'ğŸº';
                }
            }

            update() {
                if(this.hp <= 0) return;

                // ë²„í”„ì¡´ ì²´í¬ ë° ì‚¬ê±°ë¦¬ ì—…ë°ì´íŠ¸
                this.currentRangeMultiplier = 1.0;
                for(let zone of buffZones) {
                    const dx = this.x - zone.x;
                    const dy = this.y - zone.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist <= zone.radius) {
                        this.currentRangeMultiplier = Math.max(this.currentRangeMultiplier, zone.multiplier);
                    }
                }
                this.range = this.baseRange * this.currentRangeMultiplier;

                // ëª…ì¤‘ íš¨ê³¼ ì²˜ë¦¬ (í”„ë ˆì„ ê¸°ë°˜)
                if(this.hitEffectDelay !== undefined) {
                    this.hitEffectDelay--;
                    if(this.hitEffectDelay <= 0) {
                        createHitEffect(this.attacker, this);
                        if(this.hp <= 0) {
                            createDeathEffect(this);
                        }
                        delete this.hitEffectDelay;
                        delete this.attacker;
                    }
                }

                // ìë™ ì „íˆ¬ ëª¨ë“œ (ì êµ°ë§Œ) - ê³µê²©ì  AI
                if(gameStarted && this.team === 'red') {
                    this.buffZoneCheckCooldown--;
                    
                    const enemy = this.findNearestEnemy();
                    
                    // ë²„í”„ì¡´ì´ ì—†ê±°ë‚˜ ì²´í¬ ì¿¨ë‹¤ìš´ì´ë©´ ìƒˆë¡œìš´ ë²„í”„ì¡´ íƒìƒ‰
                    if(!this.targetBuffZone || this.buffZoneCheckCooldown <= 0) {
                        const inBuffZone = buffZones.some(zone => {
                            const dx = this.x - zone.x;
                            const dy = this.y - zone.y;
                            return Math.sqrt(dx*dx + dy*dy) <= zone.radius;
                        });
                        
                        // ë²„í”„ì¡´ ë°–ì— ìˆìœ¼ë©´ ê°€ì¥ ì¢‹ì€ ë²„í”„ì¡´ ì°¾ê¸°
                        if(!inBuffZone) {
                            this.targetBuffZone = this.findBestBuffZone();
                            this.buffZoneCheckCooldown = 180; // 3ì´ˆë§ˆë‹¤ ì¬í‰ê°€
                        } else {
                            this.targetBuffZone = null;
                            this.buffZoneCheckCooldown = 60;
                        }
                    }
                    
                    if(enemy) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        this.angle = Math.atan2(dy, dx);

                        // ìš°ì„ ìˆœìœ„: 1. ì‚¬ê±°ë¦¬ ë‚´ ì  ê³µê²©, 2. ë²„í”„ì¡´ìœ¼ë¡œ ì´ë™í•˜ë©° ì ‘ê·¼, 3. ì ì—ê²Œ ì§ì§„
                        if(dist <= this.range) {
                            // ì‚¬ê±°ë¦¬ ë‚´ë©´ ê³µê²©ë§Œ
                            this.attack(enemy);
                        } else if(this.targetBuffZone && this.currentRangeMultiplier < 2.0) {
                            // ë²„í”„ì¡´ìœ¼ë¡œ ì´ë™ (ë‚®ì€ ë°°ìœ¨ì¼ ë•Œë§Œ)
                            const zoneDx = this.targetBuffZone.x - this.x;
                            const zoneDy = this.targetBuffZone.y - this.y;
                            const zoneDist = Math.sqrt(zoneDx*zoneDx + zoneDy*zoneDy);
                            
                            if(zoneDist > this.targetBuffZone.radius) {
                                this.targetX = this.x + (zoneDx/zoneDist) * this.speed * 1.5;
                                this.targetY = this.y + (zoneDy/zoneDist) * this.speed * 1.5;
                            }
                        } else {
                            // ì ì—ê²Œ ì ê·¹ì ìœ¼ë¡œ ì ‘ê·¼
                            this.targetX = this.x + (dx/dist) * this.speed * 1.8;
                            this.targetY = this.y + (dy/dist) * this.speed * 1.8;
                        }
                    } else if(this.targetBuffZone) {
                        // ì ì´ ì—†ìœ¼ë©´ ë²„í”„ì¡´ìœ¼ë¡œ
                        const zoneDx = this.targetBuffZone.x - this.x;
                        const zoneDy = this.targetBuffZone.y - this.y;
                        const zoneDist = Math.sqrt(zoneDx*zoneDx + zoneDy*zoneDy);
                        
                        if(zoneDist > this.targetBuffZone.radius) {
                            this.targetX = this.x + (zoneDx/zoneDist) * this.speed;
                            this.targetY = this.y + (zoneDy/zoneDist) * this.speed;
                        }
                    }
                }
                
                // ì•„êµ°ì€ ìˆ˜ë™ ì¡°ì‘ + ì‚¬ê±°ë¦¬ ë‚´ ì  ìë™ ê³µê²©
                if(gameStarted && this.team === 'blue') {
                    const enemy = this.findNearestEnemy();
                    if(enemy) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        this.angle = Math.atan2(dy, dx);

                        // ì‚¬ê±°ë¦¬ ë‚´ì— ìˆìœ¼ë©´ ê³µê²©ë§Œ
                        if(dist <= this.range) {
                            this.attack(enemy);
                        }
                    }
                }

                // ì´ë™
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if(dist > 2) {
                    this.x += (dx/dist) * this.speed;
                    this.y += (dy/dist) * this.speed;
                }

                if(this.attackCooldown > 0) {
                    this.attackCooldown--;
                }
            }

            findNearestEnemy() {
                let nearest = null;
                let minDist = Infinity;
                const maxSearchDist = this.range * 2; // ê²€ìƒ‰ ë²”ìœ„ í™•ëŒ€

                for(let unit of units) {
                    if(unit.team !== this.team && unit.hp > 0) {
                        const dx = unit.x - this.x;
                        const dy = unit.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if(dist < maxSearchDist && dist < minDist) {
                            minDist = dist;
                            nearest = unit;
                        }
                    }
                }
                return nearest;
            }

            findBestBuffZone() {
                let bestZone = null;
                let bestScore = -Infinity;

                for(let zone of buffZones) {
                    const dx = zone.x - this.x;
                    const dy = zone.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    // ê±°ë¦¬ê°€ ê°€ê¹Œìš¸ìˆ˜ë¡, ë°°ìœ¨ì´ ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ
                    const score = zone.multiplier * 1000 - dist;
                    
                    if(score > bestScore && dist > 50) {
                        bestScore = score;
                        bestZone = zone;
                    }
                }
                return bestZone;
            }

            attack(target) {
                if(this.attackCooldown <= 0 && target.hp > 0) {
                    // í™œ ë°œì‚¬ íš¨ê³¼
                    createAttackEffect(this, target);
                    
                    // ì¦‰ì‹œ ë°ë¯¸ì§€ ì ìš© (setTimeout ì œê±°ë¡œ ì„±ëŠ¥ ê°œì„ )
                    target.hp -= this.damage;
                    
                    // ëª…ì¤‘ íš¨ê³¼ëŠ” ì•½ê°„ì˜ ì§€ì—°ìœ¼ë¡œ
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const hitDelay = Math.min(Math.floor(dist / 20), 15); // ìµœëŒ€ 15í”„ë ˆì„
                    
                    // í”„ë ˆì„ ì¹´ìš´í„°ë¡œ ì²˜ë¦¬ (setTimeout ëŒ€ì‹ )
                    target.hitEffectDelay = hitDelay;
                    target.attacker = this;
                    
                    this.attackCooldown = this.attackSpeed;
                }
            }

            draw() {
                if(this.hp <= 0) return;

                // ì„ íƒ í‘œì‹œ
                if(this.selected) {
                    ctx.strokeStyle = '#4facfe';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // ë²„í”„ íš¨ê³¼ í‘œì‹œ
                if(this.currentRangeMultiplier > 1.0) {
                    let glowColor = '';
                    if(this.currentRangeMultiplier >= 3.0) glowColor = 'rgba(255, 100, 100, 0.4)';
                    else if(this.currentRangeMultiplier >= 2.0) glowColor = 'rgba(100, 150, 255, 0.4)';
                    else glowColor = 'rgba(150, 255, 150, 0.4)';
                    
                    ctx.fillStyle = glowColor;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 30, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ìœ ë‹› ì´ëª¨í‹°ì½˜
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();

                // HP ë°”
                const barWidth = 40;
                const barHeight = 5;
                const hpPercent = this.hp / this.maxHp;
                
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(this.x - barWidth/2, this.y - 30, barWidth, barHeight);
                
                ctx.fillStyle = this.team === 'blue' ? '#4facfe' : '#f5576c';
                ctx.fillRect(this.x - barWidth/2, this.y - 30, barWidth * hpPercent, barHeight);
            }
        }

        class Particle {
            constructor(x, y, color, vx, vy, life, type = 'normal', target = null) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = life;
                this.maxLife = life;
                this.size = Math.random() * 4 + 2;
                this.type = type;
                this.rotation = Math.random() * Math.PI * 2;
                this.target = target; // í™”ì‚´ì˜ ëª©í‘œ
                this.hit = false; // ëª…ì¤‘ ì—¬ë¶€
            }

            update() {
                // í™”ì‚´ì´ ëª©í‘œì— ëª…ì¤‘í–ˆëŠ”ì§€ ì²´í¬
                if(this.type === 'arrow' && this.target && !this.hit) {
                    const dx = this.x - this.target.x;
                    const dy = this.y - this.target.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    // ëª©í‘œì— ê°€ê¹Œì´ ë„ë‹¬í•˜ë©´ ëª…ì¤‘
                    if(dist < 20) {
                        this.hit = true;
                        this.life = 0; // ì¦‰ì‹œ ì œê±°
                        return;
                    }
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                if(this.type === 'arrow') {
                    // í™”ì‚´ì€ ì¤‘ë ¥ ì˜í–¥ ì ìŒ
                    this.vy += 0.05;
                    this.rotation = Math.atan2(this.vy, this.vx);
                } else {
                    this.vy += 0.2;
                }
                
                this.life--;
            }

            draw() {
                const alpha = this.life / this.maxLife;
                
                if(this.type === 'arrow') {
                    // í™”ì‚´ ê·¸ë¦¬ê¸° - ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë” ì˜ ë³´ì´ê²Œ
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    
                    // í™”ì‚´ ëª¸í†µ (ë” ë‘ê»ê³  ì„ ëª…í•˜ê²Œ)
                    ctx.strokeStyle = `rgba(255, 50, 50, ${alpha})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(10, 0);
                    ctx.stroke();
                    
                    // í™”ì‚´ì´‰ (ë” í¬ê²Œ)
                    ctx.lineWidth = 2.5;
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(6, -4);
                    ctx.moveTo(10, 0);
                    ctx.lineTo(6, 4);
                    ctx.stroke();
                    
                    // í™”ì‚´ ê¹ƒí„¸
                    ctx.strokeStyle = `rgba(255, 100, 100, ${alpha * 0.7})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-13, -3);
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-13, 3);
                    ctx.stroke();
                    
                    ctx.restore();
                } else {
                    // ì¼ë°˜ íŒŒí‹°í´
                    ctx.fillStyle = this.color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function createAttackEffect(attacker, target) {
            // í™”ì‚´ ë°œì‚¬ íš¨ê³¼ - ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ì˜ ë³´ì´ê²Œ
            const dx = target.x - attacker.x;
            const dy = target.y - attacker.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            const speed = 20; // ì†ë„ ì¦ê°€
            
            // ë©”ì¸ í™”ì‚´ë§Œ - ë¹¨ê°„ìƒ‰
            particles.push(new Particle(
                attacker.x,
                attacker.y,
                'rgb(255, 50, 50)', // ì„ ëª…í•œ ë¹¨ê°„ìƒ‰
                (dx / dist) * speed,
                (dy / dist) * speed,
                Math.floor(dist / speed),
                'arrow',
                target // ëª©í‘œ ì „ë‹¬
            ));
        }

        function createHitEffect(attacker, target) {
            // í™”ì‚´ ëª…ì¤‘ íš¨ê³¼ - íŒŒí‹°í´ ìˆ˜ ê°ì†Œ
            for(let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                particles.push(new Particle(
                    target.x,
                    target.y,
                    attacker.team === 'blue' ? 'rgb(79, 172, 254)' : 'rgb(245, 87, 108)',
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    15,
                    'normal'
                ));
            }
        }

        function createDeathEffect(unit) {
            for(let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    unit.x,
                    unit.y,
                    'rgb(150, 150, 150)',
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    30
                ));
            }
        }

        function initUnits() {
            units = [];
            
            // ì•„êµ° (ì™¼ìª½) - í•­ìƒ 12ëª…
            for(let i = 0; i < 12; i++) {
                units.push(new Unit(
                    80 + (i % 3) * 60,
                    150 + Math.floor(i / 3) * 100,
                    'blue',
                    'archer'
                ));
            }

            // ì êµ° (ì˜¤ë¥¸ìª½) - ìŠ¤í…Œì´ì§€ë§ˆë‹¤ 1ëª…ì”© ì¦ê°€
            const rows = Math.ceil(enemyCount / 3);
            for(let i = 0; i < enemyCount; i++) {
                units.push(new Unit(
                    canvas.width - 80 - (i % 3) * 60,
                    150 + Math.floor(i / 3) * (500 / rows),
                    'red',
                    'archer'
                ));
            }
        }

        function drawBuffZones() {
            buffZones.forEach(zone => {
                // ì™¸ê³½ì„ 
                ctx.strokeStyle = zone.type === 'green' ? 'rgba(150, 255, 150, 0.8)' : 
                                  zone.type === 'blue' ? 'rgba(100, 150, 255, 0.8)' : 
                                  'rgba(255, 100, 100, 0.8)';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ë‚´ë¶€ ì±„ìš°ê¸°
                ctx.fillStyle = zone.type === 'green' ? 'rgba(150, 255, 150, 0.15)' : 
                                zone.type === 'blue' ? 'rgba(100, 150, 255, 0.15)' : 
                                'rgba(255, 100, 100, 0.15)';
                ctx.beginPath();
                ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ë°°ìˆ˜ í‘œì‹œ
                ctx.fillStyle = zone.type === 'green' ? '#66ff66' : 
                                zone.type === 'blue' ? '#6699ff' : 
                                '#ff6666';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`Ã—${zone.multiplier}`, zone.x, zone.y);
            });
        }
        
        function drawMinimap() {
            // ë¯¸ë‹ˆë§µ ë°°ê²½
            minimapCtx.fillStyle = '#87CEEB';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // ë²„í”„ì¡´ ê·¸ë¦¬ê¸°
            buffZones.forEach(zone => {
                const x = zone.x * minimapScale;
                const y = zone.y * minimapScale;
                const r = zone.radius * minimapScale;
                
                minimapCtx.fillStyle = zone.type === 'green' ? 'rgba(150, 255, 150, 0.3)' : 
                                       zone.type === 'blue' ? 'rgba(100, 150, 255, 0.3)' : 
                                       'rgba(255, 100, 100, 0.3)';
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, r, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            // ìœ ë‹› ê·¸ë¦¬ê¸°
            units.forEach(u => {
                if(u.hp <= 0) return;
                
                const x = u.x * minimapScale;
                const y = u.y * minimapScale;
                
                minimapCtx.fillStyle = u.team === 'blue' ? '#4facfe' : '#f5576c';
                minimapCtx.beginPath();
                minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
                minimapCtx.fill();
            });
            
            // ì¹´ë©”ë¼ ë·°í¬íŠ¸ í‘œì‹œ
            const viewX = cameraX * minimapScale;
            const viewY = cameraY * minimapScale;
            const viewW = canvasWrapper.offsetWidth * minimapScale;
            const viewH = canvasWrapper.offsetHeight * minimapScale;
            
            minimapCtx.strokeStyle = '#ffffff';
            minimapCtx.lineWidth = 2;
            minimapCtx.strokeRect(viewX, viewY, viewW, viewH);
        }

        function updateCounts() {
            const blueAlive = units.filter(u => u.team === 'blue' && u.hp > 0).length;
            const redAlive = units.filter(u => u.team === 'red' && u.hp > 0).length;
            blueCountEl.textContent = blueAlive;
            redCountEl.textContent = redAlive;
            stageEl.textContent = currentStage;

            if(gameStarted && (blueAlive === 0 || redAlive === 0)) {
                gameStarted = false;
                startBtn.disabled = false;
                
                if(blueAlive > 0) {
                    // ì•„êµ° ìŠ¹ë¦¬ - ë‹¤ìŒ ìŠ¤í…Œì´ì§€
                    currentStage++;
                    enemyCount++;
                    startBtn.textContent = `ğŸ‰ ìŠ¹ë¦¬! ìŠ¤í…Œì´ì§€ ${currentStage} ì‹œì‘`;
                    
                    // 3ì´ˆ í›„ ìë™ìœ¼ë¡œ ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ì‹œì‘
                    setTimeout(() => {
                        if(!gameStarted) {
                            startBtn.textContent = 'ì „íˆ¬ ì‹œì‘';
                        }
                    }, 3000);
                } else {
                    // ì•„êµ° íŒ¨ë°° - ê²Œì„ ì˜¤ë²„
                    startBtn.textContent = `ğŸ’€ íŒ¨ë°°! ìŠ¤í…Œì´ì§€ ${currentStage}ì—ì„œ ì „ë©¸`;
                }
            }
        }

        function gameLoop(currentTime) {
            // FPS ì œí•œ
            if(currentTime - lastFrameTime < frameTime) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastFrameTime = currentTime;

            // ì¹´ë©”ë¼ ìœ„ì¹˜ ì ìš©
            canvas.style.transform = `translate(${-cameraX}px, ${-cameraY}px)`;

            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawBuffZones();

            // íŒŒí‹°í´ ìµœëŒ€ ê°œìˆ˜ ì œí•œ (ë” ì—„ê²©í•˜ê²Œ)
            if(particles.length > 100) {
                particles = particles.slice(-100);
            }

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸° ìµœì í™”
            for(let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw();
                if(particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // ìœ ë‹› ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for(let i = units.length - 1; i >= 0; i--) {
                const u = units[i];
                if(u.hp > 0) {
                    u.update();
                    u.draw();
                } else if(gameStarted) {
                    // ì „íˆ¬ ì¤‘ì—ë§Œ ì£½ì€ ìœ ë‹› ì œê±°
                    units.splice(i, 1);
                }
            }

            // ì„ íƒ ë°•ìŠ¤ ê·¸ë¦¬ê¸°
            if(selectionStart && selectionEnd) {
                ctx.strokeStyle = '#4facfe';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    selectionStart.x,
                    selectionStart.y,
                    selectionEnd.x - selectionStart.x,
                    selectionEnd.y - selectionStart.y
                );
                ctx.setLineDash([]);
            }

            updateCounts();
            drawMinimap(); // ë¯¸ë‹ˆë§µ ì—…ë°ì´íŠ¸
            requestAnimationFrame(gameLoop);
        }

        // ë¯¸ë‹ˆë§µ í´ë¦­ìœ¼ë¡œ ì¹´ë©”ë¼ ì´ë™
        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            // ë¯¸ë‹ˆë§µ ì¢Œí‘œë¥¼ ì‹¤ì œ ë§µ ì¢Œí‘œë¡œ ë³€í™˜
            const targetX = (clickX / minimapCanvas.width) * canvas.width;
            const targetY = (clickY / minimapCanvas.height) * canvas.height;
            
            // ì¹´ë©”ë¼ë¥¼ í´ë¦­ ìœ„ì¹˜ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
            const maxX = canvas.width - canvasWrapper.offsetWidth;
            const maxY = canvas.height - canvasWrapper.offsetHeight;
            
            cameraX = Math.max(0, Math.min(maxX, targetX - canvasWrapper.offsetWidth / 2));
            cameraY = Math.max(0, Math.min(maxY, targetY - canvasWrapper.offsetHeight / 2));
        });

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸ - í™”ì‚´í‘œë¡œ í™”ë©´ ì´ë™
        document.addEventListener('keydown', (e) => {
            const maxX = canvas.width - canvasWrapper.offsetWidth;
            const maxY = canvas.height - canvasWrapper.offsetHeight;
            
            switch(e.key) {
                case 'ArrowLeft':
                    cameraX = Math.max(0, cameraX - cameraSpeed);
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    cameraX = Math.min(maxX, cameraX + cameraSpeed);
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                    cameraY = Math.max(0, cameraY - cameraSpeed);
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    cameraY = Math.min(maxY, cameraY + cameraSpeed);
                    e.preventDefault();
                    break;
            }
        });

        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        let isDragging = false;
        let dragStartTime = 0;
        const clickThreshold = 200; // 200ms ì´ë‚´ë©´ í´ë¦­ìœ¼ë¡œ ê°„ì£¼

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + cameraX;
            const y = e.clientY - rect.top + cameraY;

            // ìš°í´ë¦­ ì²˜ë¦¬
            if(e.button === 2) {
                e.preventDefault();
                
                // ì„ íƒëœ ìœ ë‹› ì´ë™
                let hasSelected = false;
                units.forEach(u => {
                    if(u.selected && u.team === 'blue' && u.hp > 0) {
                        u.targetX = x + (Math.random() - 0.5) * 50;
                        u.targetY = y + (Math.random() - 0.5) * 50;
                        hasSelected = true;
                    }
                });

                // ì´ë™ íš¨ê³¼
                if(hasSelected) {
                    for(let i = 0; i < 10; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 2 + 1;
                        particles.push(new Particle(
                            x,
                            y,
                            'rgb(255, 255, 100)',
                            Math.cos(angle) * speed,
                            Math.sin(angle) * speed,
                            20
                        ));
                    }
                }
                return;
            }

            // ì¢Œí´ë¦­ - ì„ íƒ ì‹œì‘
            dragStartTime = Date.now();
            selectionStart = {x, y};
            isDragging = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            if(!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + cameraX;
            const y = e.clientY - rect.top + cameraY;

            selectionEnd = {x, y};
        });

        canvas.addEventListener('mouseup', (e) => {
            if(!isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left + cameraX;
            const y = e.clientY - rect.top + cameraY;
            
            const clickDuration = Date.now() - dragStartTime;
            const dragDistance = Math.sqrt(
                Math.pow(x - selectionStart.x, 2) + 
                Math.pow(y - selectionStart.y, 2)
            );

            // í´ë¦­ìœ¼ë¡œ ê°„ì£¼ (ì§§ì€ ì‹œê°„ + ì§§ì€ ê±°ë¦¬)
            if(clickDuration < clickThreshold && dragDistance < 10) {
                // í´ë¦­í•œ ìœ„ì¹˜ì˜ ì•„êµ° ìœ ë‹› ì°¾ê¸°
                let clickedUnit = null;
                for(let u of units) {
                    if(u.team === 'blue' && u.hp > 0) {
                        const dist = Math.sqrt(
                            Math.pow(u.x - x, 2) + 
                            Math.pow(u.y - y, 2)
                        );
                        if(dist < 25) {
                            clickedUnit = u;
                            break;
                        }
                    }
                }

                if(clickedUnit) {
                    // Shift í‚¤ë¥¼ ëˆ„ë¥´ê³  ìˆìœ¼ë©´ ë‹¤ì¤‘ ì„ íƒ
                    if(!e.shiftKey) {
                        units.forEach(u => u.selected = false);
                    }
                    clickedUnit.selected = !clickedUnit.selected;
                } else {
                    // ë¹ˆ ê³µê°„ í´ë¦­ì‹œ ì„ íƒ í•´ì œ
                    if(!e.shiftKey) {
                        units.forEach(u => u.selected = false);
                    }
                }
            } else {
                // ë“œë˜ê·¸ë¡œ ê°„ì£¼
                const minX = Math.min(selectionStart.x, x);
                const maxX = Math.max(selectionStart.x, x);
                const minY = Math.min(selectionStart.y, y);
                const maxY = Math.max(selectionStart.y, y);

                // Shift í‚¤ë¥¼ ëˆ„ë¥´ì§€ ì•Šì•˜ìœ¼ë©´ ê¸°ì¡´ ì„ íƒ í•´ì œ
                if(!e.shiftKey) {
                    units.forEach(u => u.selected = false);
                }

                // ë°•ìŠ¤ ì•ˆì˜ ì•„êµ° ìœ ë‹› ì„ íƒ
                units.forEach(u => {
                    if(u.team === 'blue' && u.hp > 0 &&
                       u.x >= minX && u.x <= maxX &&
                       u.y >= minY && u.y <= maxY) {
                        u.selected = true;
                    }
                });
            }

            isDragging = false;
            selectionStart = null;
            selectionEnd = null;
        });

        // ìš°í´ë¦­ ë©”ë‰´ ë°©ì§€
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            return false;
        });

        startBtn.addEventListener('click', () => {
            if(!gameStarted) {
                gameStarted = true;
                startBtn.disabled = true;
                startBtn.textContent = `ì „íˆ¬ ì¤‘... (ìŠ¤í…Œì´ì§€ ${currentStage})`;
                
                // ìƒˆ ìŠ¤í…Œì´ì§€ë©´ ìœ ë‹› ì´ˆê¸°í™”
                const blueAlive = units.filter(u => u.team === 'blue' && u.hp > 0).length;
                if(blueAlive === 0 || units.filter(u => u.team === 'red').length === 0) {
                    initUnits();
                }
                
                // ì êµ°ë§Œ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
                units.forEach(u => {
                    if(u.team === 'red') {
                        u.targetX = canvas.width / 2 + (Math.random() - 0.5) * 200;
                        u.targetY = canvas.height / 2 + (Math.random() - 0.5) * 200;
                    }
                });
            }
        });

        generateBuffZones();
        initUnits();
        gameLoop();
    </script>
</body>
</html>