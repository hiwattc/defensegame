import React, { useEffect, useRef, useState } from â€˜reactâ€™;

const StarCraftRTS = () => {
const canvasRef = useRef(null);
const gameRef = useRef(null);
const [playerMinerals, setPlayerMinerals] = useState(50);
const [enemyMinerals, setEnemyMinerals] = useState(50);
const [playerScvs, setPlayerScvs] = useState(1);
const [playerMarines, setPlayerMarines] = useState(0);
const [enemyScvs, setEnemyScvs] = useState(1);
const [enemyMarines, setEnemyMarines] = useState(0);
const [miningRate, setMiningRate] = useState(8);
const [enemyKills, setEnemyKills] = useState(0);
const [level, setLevel] = useState(1);
const [gameOver, setGameOver] = useState({ show: false, victory: false, stats: â€˜â€™ });
const [playerSupply, setPlayerSupply] = useState(0);
const [playerSupplyMax, setPlayerSupplyMax] = useState(10);
const [enemySupply, setEnemySupply] = useState(0);
const [enemySupplyMax, setEnemySupplyMax] = useState(10);

useEffect(() => {
const canvas = canvasRef.current;
if (!canvas) return;

```
const ctx = canvas.getContext('2d');
const width = 1200;
const height = 700;

class Game {
  constructor() {
    this.width = width;
    this.height = height;
    this.level = 1;
    this.enemyKills = 0;
    this.playerMinerals = 50;
    this.enemyMinerals = 50;
    this.playerSupply = 0;
    this.playerSupplyMax = 10;
    this.enemySupply = 0;
    this.enemySupplyMax = 10;
    this.units = [];
    this.selectedUnits = [];
    this.isDragging = false;
    this.dragStart = null;
    this.dragEnd = null;
    this.playerBase = { x: 150, y: 150, hp: 500, maxHp: 500, owner: 'player' };
    this.enemyBase = { x: 1050, y: 550, hp: 500, maxHp: 500, owner: 'enemy' };
    this.playerMinerals_patches = [
      { x: 250, y: 100, amount: 9999 },
      { x: 300, y: 120, amount: 9999 }
    ];
    this.enemyMinerals_patches = [
      { x: 950, y: 600, amount: 9999 },
      { x: 900, y: 580, amount: 9999 }
    ];
    this.gameOver = false;
    this.init();
    this.lastMineralUpdate = Date.now();
    this.lastEnemyProduction = Date.now();
  }

  init() {
    this.createUnit('scv', 200, 200, 'player');
    for (let i = 0; i < this.level; i++) {
      this.createUnit('scv', 1000, 500, 'enemy');
    }
  }

  createUnit(type, x, y, owner) {
    const unit = {
      type,
      x,
      y,
      owner,
      selected: false,
      targetX: x,
      targetY: y,
      hp: type === 'scv' ? 60 : 40,
      maxHp: type === 'scv' ? 60 : 40,
      speed: type === 'scv' ? 2 : 2.5,
      range: type === 'marine' ? 100 : 10,
      damage: type === 'marine' ? 6 : 5,
      attackCooldown: 0,
      mining: false,
      miningTarget: null,
      attackTarget: null,
      returning: false,
      supply: 1
    };
    this.units.push(unit);
    
    if (owner === 'player') {
      this.playerSupply += 1;
    } else {
      this.enemySupply += 1;
    }
    
    return unit;
  }

  produceUnit(type) {
    if (this.gameOver) return;
    const cost = 50;
    
    if (this.playerSupply >= this.playerSupplyMax) {
      return;
    }
    
    if (this.playerMinerals >= cost) {
      this.playerMinerals -= cost;
      const spawnX = this.playerBase.x + (Math.random() - 0.5) * 60;
      const spawnY = this.playerBase.y + (Math.random() - 0.5) * 60;
      this.createUnit(type, spawnX, spawnY, 'player');
      this.updateUI();
    }
  }

  buildSupply(owner) {
    const cost = 100;
    if (owner === 'player') {
      if (this.playerMinerals >= cost) {
        this.playerMinerals -= cost;
        this.playerSupplyMax += 10;
        this.updateUI();
      }
    } else {
      if (this.enemyMinerals >= cost) {
        this.enemyMinerals -= cost;
        this.enemySupplyMax += 10;
        this.updateUI();
      }
    }
  }

  attackCommand() {
    if (this.gameOver) return;
    this.units.forEach(unit => {
      if (unit.owner === 'player' && unit.type === 'marine') {
        unit.targetX = this.enemyBase.x;
        unit.targetY = this.enemyBase.y;
        unit.mining = false;
      }
    });
  }

  handleMouseDown(e) {
    if (this.gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = this.width / rect.width;
    const scaleY = this.height / rect.height;
    this.isDragging = true;
    this.dragStart = {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  }

  handleMouseMove(e) {
    if (this.isDragging && this.dragStart) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = this.width / rect.width;
      const scaleY = this.height / rect.height;
      this.dragEnd = {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    }
  }

  handleMouseUp() {
    if (this.isDragging && this.dragStart && this.dragEnd) {
      this.selectUnits();
    }
    this.isDragging = false;
    this.dragStart = null;
    this.dragEnd = null;
  }

  handleRightClick(e) {
    e.preventDefault();
    if (this.gameOver) return;
    const rect = canvas.getBoundingClientRect();
    const scaleX = this.width / rect.width;
    const scaleY = this.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    this.selectedUnits.forEach(unit => {
      if (unit.owner === 'player') {
        unit.targetX = x;
        unit.targetY = y;
        unit.mining = false;
        unit.attackTarget = null;
      }
    });
  }

  selectUnits() {
    const minX = Math.min(this.dragStart.x, this.dragEnd.x);
    const maxX = Math.max(this.dragStart.x, this.dragEnd.x);
    const minY = Math.min(this.dragStart.y, this.dragEnd.y);
    const maxY = Math.max(this.dragStart.y, this.dragEnd.y);
    this.selectedUnits = [];
    this.units.forEach(unit => {
      unit.selected = false;
      if (unit.owner === 'player' &&
          unit.x >= minX && unit.x <= maxX &&
          unit.y >= minY && unit.y <= maxY) {
        unit.selected = true;
        this.selectedUnits.push(unit);
      }
    });
  }

  update() {
    const now = Date.now();
    if (now - this.lastMineralUpdate > 1000) {
      const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
      const enemyScvs = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
      this.playerMinerals += playerScvs * 8;
      this.enemyMinerals += enemyScvs * 8;
      this.lastMineralUpdate = now;
      this.updateUI();
    }

    if (now - this.lastEnemyProduction > 5000) {
      this.enemyAI();
      this.lastEnemyProduction = now;
    }

    this.units.forEach(unit => {
      this.updateUnit(unit);
    });

    this.units.forEach(unit => {
      if (unit.type === 'scv') {
        this.scvBehavior(unit);
      }
    });

    this.units.forEach(unit => {
      if (unit.type === 'marine') {
        this.marineBehavior(unit);
      }
    });

    this.units = this.units.filter(unit => {
      if (unit.hp <= 0) {
        if (unit.owner === 'enemy') {
          this.enemyKills++;
          this.updateUI();
        }
        
        // ì¸êµ¬ìˆ˜ ê°ì†Œ
        if (unit.owner === 'player') {
          this.playerSupply -= unit.supply;
        } else {
          this.enemySupply -= unit.supply;
        }
        
        return false;
      }
      return true;
    });

    this.checkGameOver();
  }

  updateUnit(unit) {
    const dx = unit.targetX - unit.x;
    const dy = unit.targetY - unit.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance > 5) {
      let moveX = (dx / distance) * unit.speed;
      let moveY = (dy / distance) * unit.speed;
      const avoidance = this.calculateAvoidance(unit);
      moveX += avoidance.x;
      moveY += avoidance.y;
      unit.x += moveX;
      unit.y += moveY;
      unit.x = Math.max(20, Math.min(this.width - 20, unit.x));
      unit.y = Math.max(20, Math.min(this.height - 20, unit.y));
    }
    if (unit.attackCooldown > 0) {
      unit.attackCooldown--;
    }
  }

  calculateAvoidance(unit) {
    let avoidX = 0;
    let avoidY = 0;
    const minDist = 18;
    this.units.forEach(other => {
      if (other !== unit) {
        const dx = unit.x - other.x;
        const dy = unit.y - other.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist && dist > 0) {
          avoidX += (dx / dist) * 0.5;
          avoidY += (dy / dist) * 0.5;
        }
      }
    });
    return { x: avoidX, y: avoidY };
  }

  scvBehavior(unit) {
    if (unit.attackTarget) return;
    const mineralPatches = unit.owner === 'player' ? this.playerMinerals_patches : this.enemyMinerals_patches;
    if (!unit.mining && !unit.returning) {
      const nearest = this.findNearest(unit, mineralPatches);
      if (nearest) {
        unit.miningTarget = nearest;
        unit.targetX = nearest.x;
        unit.targetY = nearest.y;
        unit.mining = true;
      }
    }
    if (unit.mining && unit.miningTarget) {
      const dist = this.distance(unit, unit.miningTarget);
      if (dist < 30) {
        unit.returning = true;
        unit.mining = false;
        const base = unit.owner === 'player' ? this.playerBase : this.enemyBase;
        unit.targetX = base.x;
        unit.targetY = base.y;
      }
    }
    if (unit.returning) {
      const base = unit.owner === 'player' ? this.playerBase : this.enemyBase;
      const dist = this.distance(unit, base);
      if (dist < 40) {
        unit.returning = false;
      }
    }
  }

  marineBehavior(unit) {
    let nearestEnemy = null;
    let nearestDist = Infinity;
    const targets = unit.owner === 'player' ? 
      [...this.units.filter(u => u.owner === 'enemy'), this.enemyBase] :
      [...this.units.filter(u => u.owner === 'player'), this.playerBase];
    targets.forEach(target => {
      const dist = this.distance(unit, target);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearestEnemy = target;
      }
    });
    if (nearestEnemy && nearestDist < unit.range) {
      if (unit.attackCooldown === 0) {
        if (nearestEnemy.hp !== undefined) {
          nearestEnemy.hp -= unit.damage;
        }
        unit.attackCooldown = 15;
      }
      unit.attackTarget = nearestEnemy;
    } else if (nearestEnemy && nearestDist < 300) {
      unit.targetX = nearestEnemy.x;
      unit.targetY = nearestEnemy.y;
      unit.attackTarget = nearestEnemy;
    } else {
      unit.attackTarget = null;
      if (unit.owner === 'enemy') {
        const dist = this.distance(unit, this.playerBase);
        if (dist > 50) {
          unit.targetX = this.playerBase.x;
          unit.targetY = this.playerBase.y;
        }
      }
    }
  }

  enemyAI() {
    const enemyScvCount = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
    const enemyMarineCount = this.units.filter(u => u.owner === 'enemy' && u.type === 'marine').length;
    const playerMarineCount = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
    
    // ì„œí”Œë¼ì´ ë¶€ì¡±í•˜ë©´ ê±´ì„¤
    if (this.enemySupply >= this.enemySupplyMax - 2 && this.enemyMinerals >= 100) {
      this.buildSupply('enemy');
    }
    
    if (this.enemySupply >= this.enemySupplyMax) {
      return;
    }
    
    if (enemyScvCount < 6 && this.enemyMinerals >= 50) {
      this.enemyMinerals -= 50;
      this.createUnit('scv', this.enemyBase.x + Math.random() * 40 - 20, 
                            this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
    } else if (this.enemyMinerals >= 50 && enemyMarineCount < playerMarineCount * 2 + 5) {
      this.enemyMinerals -= 50;
      this.createUnit('marine', this.enemyBase.x + Math.random() * 40 - 20, 
                               this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
    }
    
    this.updateUI();
  }

  findNearest(unit, targets) {
    let nearest = null;
    let minDist = Infinity;
    targets.forEach(target => {
      const dist = this.distance(unit, target);
      if (dist < minDist) {
        minDist = dist;
        nearest = target;
      }
    });
    return nearest;
  }

  distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  checkGameOver() {
    if (this.playerBase.hp <= 0) {
      this.endGame(false);
    } else if (this.enemyBase.hp <= 0) {
      this.endGame(true);
    }
  }

  endGame(victory) {
    this.gameOver = true;
    if (victory) {
      setGameOver({
        show: true,
        victory: true,
        stats: `ë ˆë²¨ ${this.level} í´ë¦¬ì–´! ì  ì²˜ì¹˜: ${this.enemyKills}`
      });
      setTimeout(() => {
        this.level++;
        this.restart();
      }, 3000);
    } else {
      setGameOver({
        show: true,
        victory: false,
        stats: `ë ˆë²¨ ${this.level}ì—ì„œ íŒ¨ë°°. ì  ì²˜ì¹˜: ${this.enemyKills}`
      });
    }
  }

  restart() {
    this.units = [];
    this.selectedUnits = [];
    this.playerMinerals = 50;
    this.enemyMinerals = 50;
    this.enemyKills = 0;
    this.playerSupply = 0;
    this.playerSupplyMax = 10;
    this.enemySupply = 0;
    this.enemySupplyMax = 10;
    this.playerBase.hp = this.playerBase.maxHp;
    this.enemyBase.hp = this.enemyBase.maxHp;
    this.gameOver = false;
    setGameOver({ show: false, victory: false, stats: '' });
    this.init();
    this.updateUI();
  }

  render() {
    ctx.clearRect(0, 0, this.width, this.height);
    
    ctx.fillStyle = '#2d4a2d';
    ctx.beginPath();
    ctx.ellipse(150, 150, 120, 100, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#4a2d2d';
    ctx.beginPath();
    ctx.ellipse(1050, 550, 120, 100, 0, 0, Math.PI * 2);
    ctx.fill();
    
    this.playerMinerals_patches.forEach(mineral => {
      ctx.fillStyle = '#4488ff';
      ctx.beginPath();
      ctx.arc(mineral.x, mineral.y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#6699ff';
      ctx.lineWidth = 2;
      ctx.stroke();
    });
    
    this.enemyMinerals_patches.forEach(mineral => {
      ctx.fillStyle = '#4488ff';
      ctx.beginPath();
      ctx.arc(mineral.x, mineral.y, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#6699ff';
      ctx.lineWidth = 2;
      ctx.stroke();
    });
    
    this.drawBase(this.playerBase, '#00ff00');
    this.drawBase(this.enemyBase, '#ff4444');
    
    this.units.forEach(unit => {
      this.drawUnit(unit);
    });
    
    if (this.isDragging && this.dragStart && this.dragEnd) {
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.strokeRect(
        this.dragStart.x,
        this.dragStart.y,
        this.dragEnd.x - this.dragStart.x,
        this.dragEnd.y - this.dragStart.y
      );
      ctx.setLineDash([]);
    }
  }

  drawBase(base, color) {
    ctx.fillStyle = color;
    ctx.fillRect(base.x - 30, base.y - 25, 60, 50);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(base.x - 30, base.y - 25, 60, 50);
    
    const hpPercent = base.hp / base.maxHp;
    ctx.fillStyle = '#333';
    ctx.fillRect(base.x - 30, base.y - 35, 60, 6);
    ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
    ctx.fillRect(base.x - 30, base.y - 35, 60 * hpPercent, 6);
    
    ctx.fillStyle = '#fff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${Math.floor(base.hp)}/${base.maxHp}`, base.x, base.y - 38);
  }

  drawUnit(unit) {
    const color = unit.owner === 'player' ? '#00ff00' : '#ff4444';
    
    if (unit.type === 'scv') {
      ctx.fillStyle = color;
      ctx.fillRect(unit.x - 8, unit.y - 8, 16, 16);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(unit.x - 8, unit.y - 8, 16, 16);
    } else {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    
    if (unit.selected) {
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(unit.x, unit.y, 12, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    const hpPercent = unit.hp / unit.maxHp;
    ctx.fillStyle = '#333';
    ctx.fillRect(unit.x - 10, unit.y - 15, 20, 3);
    ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
    ctx.fillRect(unit.x - 10, unit.y - 15, 20 * hpPercent, 3);
    
    if (unit.attackTarget && unit.attackCooldown > 10) {
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(unit.x, unit.y);
      ctx.lineTo(unit.attackTarget.x, unit.attackTarget.y);
      ctx.stroke();
      
      ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
      ctx.beginPath();
      ctx.arc(unit.attackTarget.x, unit.attackTarget.y, 10, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  updateUI() {
    const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
    const playerMarines = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
    const enemyScvs = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
    const enemyMarines = this.units.filter(u => u.owner === 'enemy' && u.type === 'marine').length;
    
    setPlayerMinerals(Math.floor(this.playerMinerals));
    setEnemyMinerals(Math.floor(this.enemyMinerals));
    setPlayerScvs(playerScvs);
    setPlayerMarines(playerMarines);
    setEnemyScvs(enemyScvs);
    setEnemyMarines(enemyMarines);
    setMiningRate(playerScvs * 8);
    setEnemyKills(this.enemyKills);
    setLevel(this.level);
    setPlayerSupply(this.playerSupply);
    setPlayerSupplyMax(this.playerSupplyMax);
    setEnemySupply(this.enemySupply);
    setEnemySupplyMax(this.enemySupplyMax);
  }
}

const game = new Game();
gameRef.current = game;

const gameLoop = () => {
  if (!game.gameOver) {
    game.update();
  }
  game.render();
  requestAnimationFrame(gameLoop);
};
gameLoop();

const handleMouseDown = (e) => game.handleMouseDown(e);
const handleMouseMove = (e) => game.handleMouseMove(e);
const handleMouseUp = () => game.handleMouseUp();
const handleContextMenu = (e) => game.handleRightClick(e);

canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('contextmenu', handleContextMenu);

return () => {
  canvas.removeEventListener('mousedown', handleMouseDown);
  canvas.removeEventListener('mousemove', handleMouseMove);
  canvas.removeEventListener('mouseup', handleMouseUp);
  canvas.removeEventListener('contextmenu', handleContextMenu);
};
```

}, []);

const handleProduceScv = () => {
if (gameRef.current) gameRef.current.produceUnit(â€˜scvâ€™);
};

const handleProduceMarine = () => {
if (gameRef.current) gameRef.current.produceUnit(â€˜marineâ€™);
};

const handleAttack = () => {
if (gameRef.current) gameRef.current.attackCommand();
};

const handleBuildSupply = () => {
if (gameRef.current) gameRef.current.buildSupply(â€˜playerâ€™);
};

const handleRestart = () => {
if (gameRef.current) gameRef.current.restart();
};

return (
<div className="w-full max-w-6xl mx-auto p-4 bg-black text-white">
<canvas
ref={canvasRef}
width={1200}
height={700}
className="w-full border-4 border-gray-600 bg-gray-900 cursor-crosshair"
/>

```
  <div className="mt-4 bg-gradient-to-b from-gray-800 to-gray-900 p-3 border-2 border-gray-600 rounded">
    {/* ì»´íŒ©íŠ¸ ìƒíƒœ í‘œì‹œ */}
    <div className="flex flex-wrap gap-3 mb-3 text-sm">
      {/* ì•„êµ° */}
      <div className="flex items-center gap-3 bg-black bg-opacity-50 px-3 py-2 border border-green-600 rounded">
        <span className="text-green-400 text-lg">ğŸ‘¥</span>
        <span className={`font-bold ${playerSupply >= playerSupplyMax ? 'text-red-400' : 'text-green-400'}`}>
          {playerSupply}/{playerSupplyMax}
        </span>
        <span className="text-gray-500">|</span>
        <span className="text-green-400 text-lg">ğŸ’</span>
        <span className="text-green-400 font-bold">{playerMinerals}</span>
        <span className="text-gray-500">|</span>
        <span className="text-green-400 text-lg">âš™ï¸</span>
        <span className="text-green-400">{playerScvs}</span>
        <span className="text-gray-500">|</span>
        <span className="text-green-400 text-lg">ğŸ¯</span>
        <span className="text-green-400">{playerMarines}</span>
        <span className="text-gray-500">|</span>
        <span className="text-green-400 text-lg">â›ï¸</span>
        <span className="text-green-400">+{miningRate}/s</span>
      </div>
      
      {/* ì êµ° */}
      <div className="flex items-center gap-3 bg-black bg-opacity-50 px-3 py-2 border border-red-600 rounded">
        <span className="text-red-400 text-lg">ğŸ‘¥</span>
        <span className="text-red-400 font-bold">{enemySupply}/{enemySupplyMax}</span>
        <span className="text-gray-500">|</span>
        <span className="text-red-400 text-lg">ğŸ’</span>
        <span className="text-red-400 font-bold">{enemyMinerals}</span>
        <span className="text-gray-500">|</span>
        <span className="text-red-400 text-lg">âš™ï¸</span>
        <span className="text-red-400">{enemyScvs}</span>
        <span className="text-gray-500">|</span>
        <span className="text-red-400 text-lg">ğŸ¯</span>
        <span className="text-red-400">{enemyMarines}</span>
      </div>
      
      {/* í†µê³„ */}
      <div className="flex items-center gap-3 bg-black bg-opacity-50 px-3 py-2 border border-yellow-600 rounded">
        <span className="text-yellow-400 text-lg">ğŸ’€</span>
        <span className="text-yellow-400">{enemyKills}</span>
        <span className="text-gray-500">|</span>
        <span className="text-yellow-400 text-lg">â­</span>
        <span className="text-yellow-400 font-bold">Lv.{level}</span>
      </div>
    </div>
    
    {/* ë ˆë²¨ ì„ íƒ */}
    <div className="mb-3 bg-black bg-opacity-50 p-2 border border-gray-600 rounded">
      <div className="text-xs text-gray-400 mb-1">ë ˆë²¨ ë°”ë¡œê°€ê¸°:</div>
      <div className="flex flex-wrap gap-1">
        {[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20].map(lv => (
          <button
            key={lv}
            onClick={() => {
              if (gameRef.current) {
                gameRef.current.level = lv;
                gameRef.current.restart();
              }
            }}
            className={`px-2 py-1 text-xs rounded transition ${
              level === lv 
                ? 'bg-yellow-600 text-white border border-yellow-400' 
                : 'bg-gray-700 text-gray-300 border border-gray-600 hover:bg-gray-600'
            }`}
          >
            {lv}
          </button>
        ))}
      </div>
    </div>
    
    {/* ë²„íŠ¼ */}
    <div className="flex flex-wrap gap-2">
      <button
        onClick={handleBuildSupply}
        className="px-4 py-2 bg-gradient-to-b from-blue-600 to-blue-800 text-white border-2 border-blue-500 rounded hover:from-blue-500 hover:to-blue-700 transition text-sm flex items-center gap-2"
      >
        <span className="text-lg">ğŸ—ï¸</span>
        <span>ì„œí”Œë¼ì´ (100)</span>
      </button>
      <button
        onClick={handleProduceScv}
        className="px-4 py-2 bg-gradient-to-b from-gray-600 to-gray-800 text-white border-2 border-gray-500 rounded hover:from-gray-500 hover:to-gray-700 transition text-sm flex items-center gap-2"
      >
        <span className="text-lg">âš™ï¸</span>
        <span>SCV (50)</span>
      </button>
      <button
        onClick={handleProduceMarine}
        className="px-4 py-2 bg-gradient-to-b from-gray-600 to-gray-800 text-white border-2 border-gray-500 rounded hover:from-gray-500 hover:to-gray-700 transition text-sm flex items-center gap-2"
      >
        <span className="text-lg">ğŸ¯</span>
        <span>ë§ˆë¦° (50)</span>
      </button>
      <button
        onClick={handleAttack}
        className="px-4 py-2 bg-gradient-to-b from-red-600 to-red-800 text-white border-2 border-red-500 rounded hover:from-red-500 hover:to-red-700 transition text-sm flex items-center gap-2"
      >
        <span className="text-lg">âš”ï¸</span>
        <span>ì „ì²´ ê³µê²©!</span>
      </button>
    </div>
  </div>
  
  {gameOver.show && (
    <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-95 z-50">
      <div className="bg-gray-900 p-10 border-4 border-gray-600 rounded-lg text-center">
        <h2 className={`text-4xl font-bold mb-4 ${gameOver.victory ? 'text-green-400' : 'text-red-400'}`}>
          {gameOver.victory ? 'ìŠ¹ë¦¬!' : 'íŒ¨ë°°...'}
        </h2>
        <p className="text-xl mb-6">{gameOver.stats}</p>
        {!gameOver.victory && (
          <button
            onClick={handleRestart}
            className="px-8 py-4 bg-gradient-to-b from-gray-600 to-gray-800 text-white border-2 border-gray-500 rounded hover:from-gray-500 hover:to-gray-700 transition text-lg"
          >
            ë‹¤ì‹œ ì‹œì‘
          </button>
        )}
      </div>
    </div>
  )}
</div>
```

);
};

export default StarCraftRTS;