<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤íƒ€í¬ë˜í”„íŠ¸ ìŠ¤íƒ€ì¼ RTS ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        #gameContainer {
            max-width: 1200px;
            width: 100%;
        }
        
        #gameCanvas {
            border: 3px solid #444;
            background: #1a1a1a;
            display: block;
            width: 100%;
            max-width: 1200px;
            height: auto;
            cursor: crosshair;
        }
        
        #levelSelect {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .level-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }
        
        .level-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .level-btn {
            padding: 8px 14px;
            font-size: 13px;
            cursor: pointer;
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            color: #fff;
            border: 1px solid #555;
            border-radius: 3px;
            transition: all 0.2s;
            min-width: 44px;
            min-height: 36px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .level-btn:hover {
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            border-color: #777;
        }
        
        .level-btn.active {
            background: linear-gradient(to bottom, #ffa500, #ff8c00);
            border-color: #ffb84d;
            font-weight: bold;
        }
        
        #ui {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            margin-top: 10px;
            border-radius: 5px;
        }
        
        .stats-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            border-radius: 5px;
        }
        
        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .stat-box.player {
            border: 1px solid #00ff00;
        }
        
        .stat-box.enemy {
            border: 1px solid #ff4444;
        }
        
        .stat-box.info {
            border: 1px solid #ffaa00;
        }
        
        .stat-icon {
            font-size: 18px;
        }
        
        .stat-value {
            font-weight: bold;
        }
        
        .stat-value.player {
            color: #00ff00;
        }
        
        .stat-value.enemy {
            color: #ff4444;
        }
        
        .stat-value.warning {
            color: #ff4444;
        }
        
        .stat-separator {
            color: #555;
        }
        
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            cursor: pointer;
            background: linear-gradient(to bottom, #4a4a4a, #2a2a2a);
            color: #fff;
            border: 2px solid #666;
            border-radius: 5px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            min-height: 44px; /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ë¥¼ ìœ„í•œ ìµœì†Œ í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸° */
            -webkit-tap-highlight-color: transparent; /* iOS í„°ì¹˜ í•˜ì´ë¼ì´íŠ¸ ì œê±° */
            position: relative; /* ì¿¨íƒ€ì„ ì˜¤ë²„ë ˆì´ë¥¼ ìœ„í•œ ìƒëŒ€ ìœ„ì¹˜ */
        }
        
        button:hover {
            background: linear-gradient(to bottom, #5a5a5a, #3a3a3a);
            border-color: #888;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(1px);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 12px;
            pointer-events: none;
        }

        .cooldown-overlay.active {
            display: flex;
        }

        .cooldown-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }
        
        .btn-supply {
            background: linear-gradient(to bottom, #4488ff, #2266dd);
            border-color: #5599ff;
        }
        
        .btn-supply:hover {
            background: linear-gradient(to bottom, #5599ff, #3377ee);
        }
        
        .btn-attack {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
            border-color: #ff6666;
        }
        
        .btn-attack:hover {
            background: linear-gradient(to bottom, #ff5555, #dd0000);
        }
        
        .btn-retreat {
            background: linear-gradient(to bottom, #ffaa00, #dd8800);
            border-color: #ffbb22;
        }
        
        .btn-retreat:hover {
            background: linear-gradient(to bottom, #ffbb22, #ee9900);
        }
        
        .btn-hold {
            background: linear-gradient(to bottom, #aa44ff, #8822dd);
            border-color: #bb55ff;
        }
        
        .btn-hold:hover {
            background: linear-gradient(to bottom, #bb55ff, #9933ee);
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #666;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        .victory { color: #00ff00; }
        .defeat { color: #ff4444; }
        
        @media (max-width: 768px) {
            .stat-box {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .stat-icon {
                font-size: 16px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .level-btn {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 35px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- ë ˆë²¨ ì„ íƒ (ìƒë‹¨) -->
        <div id="levelSelect">
            <div class="level-title">â­ ë ˆë²¨ ë°”ë¡œê°€ê¸°</div>
            <div class="level-buttons" id="levelButtons"></div>
        </div>

        <!-- ìƒíƒœ ì •ë³´ (ìƒë‹¨ìœ¼ë¡œ ì´ë™) -->
        <div class="stats-row">
            <div class="stat-box player">
                <span class="stat-icon">ğŸ‘¥</span>
                <span class="stat-value player" id="playerSupply">0/10</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ’</span>
                <span class="stat-value player" id="playerMinerals">50</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">âš™ï¸</span>
                <span class="stat-value player" id="playerScvs">1</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ¯</span>
                <span class="stat-value player" id="playerMarines">0</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">â›ï¸</span>
                <span class="stat-value player" id="miningRate">+8/s</span>
            </div>

            <div class="stat-box enemy">
                <span class="stat-icon">ğŸ‘¥</span>
                <span class="stat-value enemy" id="enemySupply">0/10</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ’</span>
                <span class="stat-value enemy" id="enemyMinerals">50</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">âš™ï¸</span>
                <span class="stat-value enemy" id="enemyScvs">1</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ¯</span>
                <span class="stat-value enemy" id="enemyMarines">0</span>
            </div>

            <div class="stat-box info">
                <span class="stat-icon">ğŸ’€</span>
                <span class="stat-value" id="enemyKills">0</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">â­</span>
                <span class="stat-value" id="level">Lv.1</span>
            </div>
        </div>

        <canvas id="gameCanvas" width="1200" height="700"></canvas>

        <div id="ui">
            <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
            <div class="controls">
                <button class="btn-supply" onclick="game.buildSupply('player')">
                    <span>ğŸ—ï¸</span>
                    <span>ì„œí”Œë¼ì´ (100)</span>
                    <div class="cooldown-overlay" id="supplyCooldownOverlay"></div>
                </button>
                <button onclick="game.produceUnit('scv')">
                    <span>âš™ï¸</span>
                    <span>SCV (50)</span>
                    <div class="cooldown-overlay" id="scvCooldownOverlay"></div>
                </button>
                <button onclick="game.produceUnit('marine')">
                    <span>ğŸ¯</span>
                    <span>ë§ˆë¦° (50)</span>
                    <div class="cooldown-overlay" id="marineCooldownOverlay"></div>
                </button>
                <button class="btn-attack" onclick="game.attackCommand()">
                    <span>âš”ï¸</span>
                    <span>ì „ì²´ ê³µê²©!</span>
                </button>
                <button class="btn-retreat" onclick="game.retreatCommand()">
                    <span>ğŸƒ</span>
                    <span>ì „ì²´ íšŒêµ°!</span>
                </button>
                <button class="btn-hold" onclick="game.holdCommand()">
                    <span>ğŸ›‘</span>
                    <span>ë©ˆì¶¤!</span>
                </button>
            </div>
        </div>
        
        <div id="gameOver">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverStats"></p>
            <button onclick="game.restart()" style="margin-top: 20px;">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 1200;
                this.height = 700;
                
                this.level = 1;
                this.enemyKills = 0;
                this.playerMinerals = 50;
                this.enemyMinerals = 50;
                this.playerSupply = 0;
                this.playerSupplyMax = 10;
                this.enemySupply = 0;
                this.enemySupplyMax = 10;
                
                this.units = [];
                this.selectedUnits = [];
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
                
                this.playerBase = { x: 150, y: 150, hp: 500, maxHp: 500, owner: 'player' };
                this.enemyBase = { x: 1050, y: 550, hp: 500, maxHp: 500, owner: 'enemy' };
                
                this.playerMinerals_patches = [
                    { x: 250, y: 100, amount: 9999 },
                    { x: 300, y: 120, amount: 9999 }
                ];
                
                this.enemyMinerals_patches = [
                    { x: 950, y: 600, amount: 9999 },
                    { x: 900, y: 580, amount: 9999 }
                ];
                
                this.gameOver = false;

                // ì¿¨íƒ€ì„ ê´€ë ¨ ë³€ìˆ˜ë“¤
                this.supplyCooldown = 0; // ì„œí”Œë¼ì´ ì¿¨íƒ€ì„ (5ì´ˆ)
                this.supplyCooldownMax = 300; // 5ì´ˆ * 60fps
                this.scvCooldown = 0; // SCV ìƒì‚° ì¿¨íƒ€ì„ (1ì´ˆ)
                this.scvCooldownMax = 60; // 1ì´ˆ * 60fps
                this.marineCooldown = 0; // ë§ˆë¦° ìƒì‚° ì¿¨íƒ€ì„ (1ì´ˆ)
                this.marineCooldownMax = 60; // 1ì´ˆ * 60fps

                this.init();
                this.createLevelButtons();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            createLevelButtons() {
                const container = document.getElementById('levelButtons');
                for (let i = 1; i <= 10; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.textContent = i;
                    btn.onclick = () => this.jumpToLevel(i);
                    container.appendChild(btn);
                }
                this.updateLevelButtons();
            }
            
            updateLevelButtons() {
                const buttons = document.querySelectorAll('.level-btn');
                buttons.forEach((btn, index) => {
                    btn.classList.toggle('active', index + 1 === this.level);
                });
            }
            
            jumpToLevel(level) {
                this.level = level;
                this.restart();
            }
            
            init() {
                this.createUnit('scv', 200, 200, 'player');
                for (let i = 0; i < this.level; i++) {
                    this.createUnit('scv', 1000, 500, 'enemy');
                }
                this.lastMineralUpdate = Date.now();
                this.lastEnemyProduction = Date.now();
                this.updateUI();
            }
            
            createUnit(type, x, y, owner) {
                const unit = {
                    type,
                    x,
                    y,
                    owner,
                    selected: false,
                    targetX: x,
                    targetY: y,
                    hp: type === 'scv' ? 60 : 40,
                    maxHp: type === 'scv' ? 60 : 40,
                    speed: type === 'scv' ? 2 : 2.5,
                    range: type === 'marine' ? 100 : 10,
                    damage: type === 'marine' ? 6 : 5,
                    attackCooldown: 0,
                    mining: false,
                    miningTarget: null,
                    attackTarget: null,
                    returning: false,
                    supply: 1,
                    isHolding: false
                };
                this.units.push(unit);
                
                if (owner === 'player') {
                    this.playerSupply += 1;
                } else {
                    this.enemySupply += 1;
                }
                
                return unit;
            }
            
            produceUnit(type) {
                if (this.gameOver) return;
                const cost = 50;

                // ì¿¨íƒ€ì„ ì²´í¬
                if (type === 'scv' && this.scvCooldown > 0) return;
                if (type === 'marine' && this.marineCooldown > 0) return;

                if (this.playerSupply >= this.playerSupplyMax) {
                    return;
                }

                if (this.playerMinerals >= cost) {
                    this.playerMinerals -= cost;
                    const spawnX = this.playerBase.x + (Math.random() - 0.5) * 60;
                    const spawnY = this.playerBase.y + (Math.random() - 0.5) * 60;
                    this.createUnit(type, spawnX, spawnY, 'player');

                    // ì¿¨íƒ€ì„ ì‹œì‘
                    if (type === 'scv') {
                        this.scvCooldown = this.scvCooldownMax;
                    } else if (type === 'marine') {
                        this.marineCooldown = this.marineCooldownMax;
                    }

                    this.updateUI();
                }
            }
            
            buildSupply(owner) {
                const cost = 100;
                if (owner === 'player') {
                    if (this.supplyCooldown > 0) return; // ì¿¨íƒ€ì„ ì¤‘ì´ë©´ ë¦¬í„´
                    if (this.playerMinerals >= cost) {
                        this.playerMinerals -= cost;
                        this.playerSupplyMax += 10;
                        this.supplyCooldown = this.supplyCooldownMax; // ì¿¨íƒ€ì„ ì‹œì‘
                        this.updateUI();
                    }
                } else {
                    if (this.enemyMinerals >= cost) {
                        this.enemyMinerals -= cost;
                        this.enemySupplyMax += 10;
                        this.updateUI();
                    }
                }
            }
            
            attackCommand() {
                if (this.gameOver) return;
                this.units.forEach(unit => {
                    if (unit.owner === 'player' && unit.type === 'marine') {
                        unit.targetX = this.enemyBase.x;
                        unit.targetY = this.enemyBase.y;
                        unit.mining = false;
                        unit.isHolding = false;
                    }
                });
            }
            
            retreatCommand() {
                if (this.gameOver) return;
                this.units.forEach(unit => {
                    if (unit.owner === 'player') {
                        unit.targetX = this.playerBase.x + (Math.random() - 0.5) * 100;
                        unit.targetY = this.playerBase.y + (Math.random() - 0.5) * 100;
                        unit.mining = false;
                        unit.attackTarget = null;
                        unit.isHolding = false;
                    }
                });
            }
            
            holdCommand() {
                if (this.gameOver) return;
                this.units.forEach(unit => {
                    if (unit.owner === 'player' && unit.type === 'marine') {
                        unit.targetX = unit.x;
                        unit.targetY = unit.y;
                        unit.isHolding = true;
                    }
                });
            }
            
            setupEventListeners() {
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));

                // í„°ì¹˜ ì´ë²¤íŠ¸
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.handlePointerDown(e);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    this.handlePointerMove(e);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handlePointerUp(e);
                });
            }
            
            getPointerPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.width / rect.width;
                const scaleY = this.height / rect.height;

                // í„°ì¹˜ ì´ë²¤íŠ¸ì¸ì§€ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ì¸ì§€ í™•ì¸
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            handlePointerDown(e) {
                if (this.gameOver) return;
                this.isDragging = true;
                this.dragStart = this.getPointerPosition(e);
            }

            handlePointerMove(e) {
                if (this.isDragging && this.dragStart) {
                    this.dragEnd = this.getPointerPosition(e);
                }
            }

            handlePointerUp(e) {
                if (this.isDragging && this.dragStart && this.dragEnd) {
                    this.selectUnits();
                }
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
            }
            
            handleRightClick(e) {
                e.preventDefault();
                if (this.gameOver) return;
                const pos = this.getPointerPosition(e);
                this.selectedUnits.forEach(unit => {
                    if (unit.owner === 'player') {
                        unit.targetX = pos.x;
                        unit.targetY = pos.y;
                        unit.mining = false;
                        unit.attackTarget = null;
                        unit.isHolding = false;
                    }
                });
            }
            
            selectUnits() {
                const minX = Math.min(this.dragStart.x, this.dragEnd.x);
                const maxX = Math.max(this.dragStart.x, this.dragEnd.x);
                const minY = Math.min(this.dragStart.y, this.dragEnd.y);
                const maxY = Math.max(this.dragStart.y, this.dragEnd.y);
                this.selectedUnits = [];
                this.units.forEach(unit => {
                    unit.selected = false;
                    if (unit.owner === 'player' &&
                        unit.x >= minX && unit.x <= maxX &&
                        unit.y >= minY && unit.y <= maxY) {
                        unit.selected = true;
                        this.selectedUnits.push(unit);
                    }
                });
            }
            
            gameLoop() {
                if (!this.gameOver) {
                    this.update();
                }
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                const now = Date.now();
                if (now - this.lastMineralUpdate > 1000) {
                    const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
                    const enemyScvs = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
                    this.playerMinerals += playerScvs * 8;
                    this.enemyMinerals += enemyScvs * 8;
                    this.lastMineralUpdate = now;
                    this.updateUI();
                }
                
                if (now - this.lastEnemyProduction > 5000) {
                    this.enemyAI();
                    this.lastEnemyProduction = now;
                }
                
                if (now - (this.lastEnemyQuickCheck || 0) > 3000) {
                    this.enemyQuickProduction();
                    this.lastEnemyQuickCheck = now;
                }
                
                // ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
                if (this.supplyCooldown > 0) this.supplyCooldown--;
                if (this.scvCooldown > 0) this.scvCooldown--;
                if (this.marineCooldown > 0) this.marineCooldown--;

                this.units.forEach(unit => {
                    this.updateUnit(unit);
                });
                
                this.units.forEach(unit => {
                    if (unit.type === 'scv') {
                        this.scvBehavior(unit);
                    }
                });
                
                this.units.forEach(unit => {
                    if (unit.type === 'marine') {
                        this.marineBehavior(unit);
                    }
                });
                
                this.units = this.units.filter(unit => {
                    if (unit.hp <= 0) {
                        if (unit.owner === 'enemy') {
                            this.enemyKills++;
                            this.updateUI();
                        }
                        if (unit.owner === 'player') {
                            this.playerSupply -= unit.supply;
                        } else {
                            this.enemySupply -= unit.supply;
                        }
                        return false;
                    }
                    return true;
                });
                
                this.checkGameOver();
            }
            
            updateUnit(unit) {
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) {
                    let moveX = (dx / distance) * unit.speed;
                    let moveY = (dy / distance) * unit.speed;
                    const avoidance = this.calculateAvoidance(unit);
                    moveX += avoidance.x;
                    moveY += avoidance.y;
                    unit.x += moveX;
                    unit.y += moveY;
                    unit.x = Math.max(20, Math.min(this.width - 20, unit.x));
                    unit.y = Math.max(20, Math.min(this.height - 20, unit.y));
                }
                if (unit.attackCooldown > 0) {
                    unit.attackCooldown--;
                }
            }
            
            calculateAvoidance(unit) {
                let avoidX = 0;
                let avoidY = 0;
                const minDist = 18;
                this.units.forEach(other => {
                    if (other !== unit) {
                        const dx = unit.x - other.x;
                        const dy = unit.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist && dist > 0) {
                            avoidX += (dx / dist) * 0.5;
                            avoidY += (dy / dist) * 0.5;
                        }
                    }
                });
                return { x: avoidX, y: avoidY };
            }
            
            scvBehavior(unit) {
                if (unit.attackTarget) return;
                const mineralPatches = unit.owner === 'player' ? this.playerMinerals_patches : this.enemyMinerals_patches;
                if (!unit.mining && !unit.returning) {
                    const nearest = this.findNearest(unit, mineralPatches);
                    if (nearest) {
                        unit.miningTarget = nearest;
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.mining = true;
                    }
                }
                if (unit.mining && unit.miningTarget) {
                    const dist = this.distance(unit, unit.miningTarget);
                    if (dist < 30) {
                        unit.returning = true;
                        unit.mining = false;
                        const base = unit.owner === 'player' ? this.playerBase : this.enemyBase;
                        unit.targetX = base.x;
                        unit.targetY = base.y;
                    }
                }
                if (unit.returning) {
                    const base = unit.owner === 'player' ? this.playerBase : this.enemyBase;
                    const dist = this.distance(unit, base);
                    if (dist < 40) {
                        unit.returning = false;
                    }
                }
            }
            
            marineBehavior(unit) {
                if (unit.isHolding) {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    const targets = unit.owner === 'player' ? 
                        [...this.units.filter(u => u.owner === 'enemy'), this.enemyBase] :
                        [...this.units.filter(u => u.owner === 'player'), this.playerBase];
                    targets.forEach(target => {
                        const dist = this.distance(unit, target);
                        if (dist < nearestDist && dist < unit.range) {
                            nearestDist = dist;
                            nearestEnemy = target;
                        }
                    });
                    if (nearestEnemy && nearestDist < unit.range) {
                        if (unit.attackCooldown === 0) {
                            if (nearestEnemy.hp !== undefined) {
                                nearestEnemy.hp -= unit.damage;
                            }
                            unit.attackCooldown = 15;
                        }
                        unit.attackTarget = nearestEnemy;
                    } else {
                        unit.attackTarget = null;
                    }
                    return;
                }
                
                if (unit.owner === 'enemy') {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    const targets = [...this.units.filter(u => u.owner === 'player'), this.playerBase];
                    targets.forEach(target => {
                        const dist = this.distance(unit, target);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = target;
                        }
                    });
                    if (nearestEnemy && nearestDist < unit.range) {
                        if (unit.attackCooldown === 0) {
                            if (nearestEnemy.hp !== undefined) {
                                nearestEnemy.hp -= unit.damage;
                            }
                            unit.attackCooldown = 15;
                        }
                        unit.attackTarget = nearestEnemy;
                    } else if (nearestEnemy && nearestDist < 300) {
                        unit.targetX = nearestEnemy.x;
                        unit.targetY = nearestEnemy.y;
                        unit.attackTarget = nearestEnemy;
                    } else {
                        unit.attackTarget = null;
                        const dist = this.distance(unit, this.playerBase);
                        if (dist > 50) {
                            unit.targetX = this.playerBase.x;
                            unit.targetY = this.playerBase.y;
                        }
                    }
                }
            }
            
            enemyAI() {
                const enemyScvCount = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
                const enemyMarineCount = this.units.filter(u => u.owner === 'enemy' && u.type === 'marine').length;
                const playerMarineCount = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
                const baseTargetMarines = Math.floor(playerMarineCount * 0.6) + this.level + 2;
                const targetMarineCount = Math.max(baseTargetMarines, 5);
                
                if (this.enemySupply >= this.enemySupplyMax - 2) {
                    if (this.enemyMinerals >= 100) {
                        this.buildSupply('enemy');
                    }
                    return;
                }
                
                if (this.enemyMinerals >= 200) {
                    if (enemyMarineCount < targetMarineCount * 1.5) {
                        this.enemyMinerals -= 50;
                        this.createUnit('marine', this.enemyBase.x + Math.random() * 40 - 20, 
                                                 this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                        this.updateUI();
                        return;
                    }
                    if (enemyScvCount < 8) {
                        this.enemyMinerals -= 50;
                        this.createUnit('scv', this.enemyBase.x + Math.random() * 40 - 20, 
                                              this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                        this.updateUI();
                        return;
                    }
                }
                
                if (enemyScvCount < 4 && this.enemyMinerals >= 50) {
                    this.enemyMinerals -= 50;
                    this.createUnit('scv', this.enemyBase.x + Math.random() * 40 - 20, 
                                          this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                    this.updateUI();
                    return;
                }
                
                if (enemyMarineCount < targetMarineCount && this.enemyMinerals >= 50) {
                    this.enemyMinerals -= 50;
                    this.createUnit('marine', this.enemyBase.x + Math.random() * 40 - 20, 
                                             this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                    this.updateUI();
                    return;
                }
                
                if (enemyScvCount < 7 && this.enemyMinerals >= 50) {
                    this.enemyMinerals -= 50;
                    this.createUnit('scv', this.enemyBase.x + Math.random() * 40 - 20, 
                                          this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                    this.updateUI();
                    return;
                }
                
                if (this.enemyMinerals >= 100 && enemyMarineCount < targetMarineCount + 5) {
                    this.enemyMinerals -= 50;
                    this.createUnit('marine', this.enemyBase.x + Math.random() * 40 - 20, 
                                             this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                    this.updateUI();
                }
            }
            
            enemyQuickProduction() {
                const enemyMarineCount = this.units.filter(u => u.owner === 'enemy' && u.type === 'marine').length;
                const playerMarineCount = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
                
                if (this.enemySupply >= this.enemySupplyMax) {
                    return;
                }
                
                if (enemyMarineCount < playerMarineCount && this.enemyMinerals >= 50) {
                    this.enemyMinerals -= 50;
                    this.createUnit('marine', this.enemyBase.x + Math.random() * 40 - 20, 
                                             this.enemyBase.y + Math.random() * 40 - 20, 'enemy');
                    this.updateUI();
                }
            }
            
            findNearest(unit, targets) {
                let nearest = null;
                let minDist = Infinity;
                targets.forEach(target => {
                    const dist = this.distance(unit, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                });
                return nearest;
            }
            
            distance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            checkGameOver() {
                if (this.playerBase.hp <= 0) {
                    this.endGame(false);
                } else if (this.enemyBase.hp <= 0) {
                    this.endGame(true);
                }
            }
            
            endGame(victory) {
                this.gameOver = true;
                const gameOverDiv = document.getElementById('gameOver');
                const title = document.getElementById('gameOverTitle');
                const stats = document.getElementById('gameOverStats');
                
                if (victory) {
                    title.textContent = 'ìŠ¹ë¦¬!';
                    title.className = 'victory';
                    stats.textContent = `ë ˆë²¨ ${this.level} í´ë¦¬ì–´! ì  ì²˜ì¹˜: ${this.enemyKills}`;
                    setTimeout(() => {
                        this.level++;
                        this.restart();
                    }, 3000);
                } else {
                    title.textContent = 'íŒ¨ë°°...';
                    title.className = 'defeat';
                    stats.textContent = `ë ˆë²¨ ${this.level}ì—ì„œ íŒ¨ë°°. ì  ì²˜ì¹˜: ${this.enemyKills}`;
                    gameOverDiv.style.display = 'block';
                }
            }
            
            restart() {
                this.units = [];
                this.selectedUnits = [];
                this.playerMinerals = 50;
                this.enemyMinerals = 50;
                this.enemyKills = 0;
                this.playerSupply = 0;
                this.playerSupplyMax = 10;
                this.enemySupply = 0;
                this.enemySupplyMax = 10;
                this.playerBase.hp = this.playerBase.maxHp;
                this.enemyBase.hp = this.enemyBase.maxHp;
                this.gameOver = false;
                document.getElementById('gameOver').style.display = 'none';

                // ì¿¨íƒ€ì„ ì´ˆê¸°í™”
                this.supplyCooldown = 0;
                this.scvCooldown = 0;
                this.marineCooldown = 0;

                this.init();
                this.updateLevelButtons();
                this.updateUI();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                this.ctx.fillStyle = '#2d4a2d';
                this.ctx.beginPath();
                this.ctx.ellipse(150, 150, 120, 100, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.ctx.fillStyle = '#4a2d2d';
                this.ctx.beginPath();
                this.ctx.ellipse(1050, 550, 120, 100, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                this.playerMinerals_patches.forEach(mineral => {
                    this.ctx.fillStyle = '#4488ff';
                    this.ctx.beginPath();
                    this.ctx.arc(mineral.x, mineral.y, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#6699ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                this.enemyMinerals_patches.forEach(mineral => {
                    this.ctx.fillStyle = '#4488ff';
                    this.ctx.beginPath();
                    this.ctx.arc(mineral.x, mineral.y, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#6699ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                });
                
                this.drawBase(this.playerBase, '#00ff00');
                this.drawBase(this.enemyBase, '#ff4444');
                
                this.units.forEach(unit => {
                    this.drawUnit(unit);
                });
                
                if (this.isDragging && this.dragStart && this.dragEnd) {
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(
                        this.dragStart.x,
                        this.dragStart.y,
                        this.dragEnd.x - this.dragStart.x,
                        this.dragEnd.y - this.dragStart.y
                    );
                    this.ctx.setLineDash([]);
                }
            }
            
            drawBase(base, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(base.x - 30, base.y - 25, 60, 50);
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(base.x - 30, base.y - 25, 60, 50);
                
                const hpPercent = base.hp / base.maxHp;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(base.x - 30, base.y - 35, 60, 6);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                this.ctx.fillRect(base.x - 30, base.y - 35, 60 * hpPercent, 6);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${Math.floor(base.hp)}/${base.maxHp}`, base.x, base.y - 38);
            }
            
            drawUnit(unit) {
                const color = unit.owner === 'player' ? '#00ff00' : '#ff4444';
                
                if (unit.type === 'scv') {
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(unit.x - 8, unit.y - 8, 16, 16);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(unit.x - 8, unit.y - 8, 16, 16);
                } else {
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(unit.x, unit.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                if (unit.selected) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(unit.x, unit.y, 12, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                const hpPercent = unit.hp / unit.maxHp;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(unit.x - 10, unit.y - 15, 20, 3);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                this.ctx.fillRect(unit.x - 10, unit.y - 15, 20 * hpPercent, 3);
                
                if (unit.attackTarget && unit.attackCooldown > 10) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(unit.x, unit.y);
                    this.ctx.lineTo(unit.attackTarget.x, unit.attackTarget.y);
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(unit.attackTarget.x, unit.attackTarget.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            updateUI() {
                const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
                const playerMarines = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
                const enemyScvs = this.units.filter(u => u.owner === 'enemy' && u.type === 'scv').length;
                const enemyMarines = this.units.filter(u => u.owner === 'enemy' && u.type === 'marine').length;
                
                document.getElementById('playerMinerals').textContent = Math.floor(this.playerMinerals);
                document.getElementById('enemyMinerals').textContent = Math.floor(this.enemyMinerals);
                document.getElementById('playerScvs').textContent = playerScvs;
                document.getElementById('playerMarines').textContent = playerMarines;
                document.getElementById('enemyScvs').textContent = enemyScvs;
                document.getElementById('enemyMarines').textContent = enemyMarines;
                document.getElementById('miningRate').textContent = `+${playerScvs * 8}/s`;
                document.getElementById('enemyKills').textContent = this.enemyKills;
                document.getElementById('level').textContent = `Lv.${this.level}`;
                
                const playerSupplyEl = document.getElementById('playerSupply');
                playerSupplyEl.textContent = `${this.playerSupply}/${this.playerSupplyMax}`;
                playerSupplyEl.className = `stat-value ${this.playerSupply >= this.playerSupplyMax ? 'warning' : 'player'}`;
                
                document.getElementById('enemySupply').textContent = `${this.enemySupply}/${this.enemySupplyMax}`;

                // ì¿¨íƒ€ì„ ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
                this.updateCooldownOverlays();
            }

            updateCooldownOverlays() {
                // ì„œí”Œë¼ì´ ì¿¨íƒ€ì„
                const supplyOverlay = document.getElementById('supplyCooldownOverlay');
                if (this.supplyCooldown > 0) {
                    supplyOverlay.classList.add('active');
                    supplyOverlay.textContent = Math.ceil(this.supplyCooldown / 60) + 's';
                } else {
                    supplyOverlay.classList.remove('active');
                }

                // SCV ì¿¨íƒ€ì„
                const scvOverlay = document.getElementById('scvCooldownOverlay');
                if (this.scvCooldown > 0) {
                    scvOverlay.classList.add('active');
                    scvOverlay.textContent = Math.ceil(this.scvCooldown / 60) + 's';
                } else {
                    scvOverlay.classList.remove('active');
                }

                // ë§ˆë¦° ì¿¨íƒ€ì„
                const marineOverlay = document.getElementById('marineCooldownOverlay');
                if (this.marineCooldown > 0) {
                    marineOverlay.classList.add('active');
                    marineOverlay.textContent = Math.ceil(this.marineCooldown / 60) + 's';
                } else {
                    marineOverlay.classList.remove('active');
                }
            }
        }

        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>