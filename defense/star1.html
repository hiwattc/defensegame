<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìŠ¤íƒ€í¬ë˜í”„íŠ¸ ìŠ¤íƒ€ì¼ RTS ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        
        #gameContainer {
            max-width: 1200px;
            width: 100%;
        }
        
        #gameCanvas {
            border: 3px solid #444;
            background: #1a1a1a;
            display: block;
            width: 100%;
            max-width: 1200px;
            height: auto;
            cursor: crosshair;
        }
        
        #levelSelect, #enemyCountSelect {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        
        .level-title {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }

        .level-title:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .toggle-icon {
            font-size: 10px;
            transition: transform 0.3s;
        }

        .level-buttons {
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.3s ease-in-out;
        }

        .level-buttons.collapsed {
            max-height: 0;
        }

        #levelSelect.collapsed .toggle-icon {
            transform: rotate(180deg);
        }
        
        .level-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .level-btn {
            padding: 8px 14px;
            font-size: 13px;
            cursor: pointer;
            background: linear-gradient(to bottom, #3a3a3a, #2a2a2a);
            color: #fff;
            border: 1px solid #555;
            border-radius: 3px;
            transition: all 0.2s;
            min-width: 44px;
            min-height: 36px;
            -webkit-tap-highlight-color: transparent;
        }
        
        .level-btn:hover {
            background: linear-gradient(to bottom, #4a4a4a, #3a3a3a);
            border-color: #777;
        }
        
        .level-btn.active {
            background: linear-gradient(to bottom, #ffa500, #ff8c00);
            border-color: #ffb84d;
            font-weight: bold;
        }
        
        #ui {
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            margin-top: 10px;
            border-radius: 5px;
        }
        
        .stats-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            background: linear-gradient(to bottom, #2a2a2a, #1a1a1a);
            padding: 12px;
            border: 2px solid #444;
            border-radius: 5px;
        }
        
        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
        }
        
        .stat-box.player {
            border: 1px solid #00ff00;
        }
        
        .stat-box.enemy {
            border: 1px solid #ff4444;
        }
        
        .stat-box.info {
            border: 1px solid #ffaa00;
        }
        
        .stat-icon {
            font-size: 18px;
        }
        
        .stat-value {
            font-weight: bold;
        }
        
        .stat-value.player {
            color: #00ff00;
        }
        
        .stat-value.enemy {
            color: #ff4444;
        }
        
        .stat-value.warning {
            color: #ff4444;
        }
        
        .stat-separator {
            color: #555;
        }
        
        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 24px;
            font-size: 14px;
            cursor: pointer;
            background: linear-gradient(to bottom, #4a4a4a, #2a2a2a);
            color: #fff;
            border: 2px solid #666;
            border-radius: 5px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            min-height: 44px; /* í„°ì¹˜ ë””ë°”ì´ìŠ¤ë¥¼ ìœ„í•œ ìµœì†Œ í„°ì¹˜ íƒ€ê²Ÿ í¬ê¸° */
            -webkit-tap-highlight-color: transparent; /* iOS í„°ì¹˜ í•˜ì´ë¼ì´íŠ¸ ì œê±° */
            position: relative; /* ì¿¨íƒ€ì„ ì˜¤ë²„ë ˆì´ë¥¼ ìœ„í•œ ìƒëŒ€ ìœ„ì¹˜ */
        }
        
        button:hover {
            background: linear-gradient(to bottom, #5a5a5a, #3a3a3a);
            border-color: #888;
            transform: translateY(-1px);
        }
        
        button:active {
            transform: translateY(1px);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-weight: bold;
            font-size: 12px;
            pointer-events: none;
        }

        .cooldown-overlay.active {
            display: flex;
        }

        .cooldown-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }
        
        .btn-supply {
            background: linear-gradient(to bottom, #4488ff, #2266dd);
            border-color: #5599ff;
        }
        
        .btn-supply:hover {
            background: linear-gradient(to bottom, #5599ff, #3377ee);
        }
        
        .btn-attack {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
            border-color: #ff6666;
        }
        
        .btn-attack:hover {
            background: linear-gradient(to bottom, #ff5555, #dd0000);
        }
        
        .btn-retreat {
            background: linear-gradient(to bottom, #ffaa00, #dd8800);
            border-color: #ffbb22;
        }
        
        .btn-retreat:hover {
            background: linear-gradient(to bottom, #ffbb22, #ee9900);
        }
        
        .btn-hold {
            background: linear-gradient(to bottom, #aa44ff, #8822dd);
            border-color: #bb55ff;
        }
        
        .btn-hold:hover {
            background: linear-gradient(to bottom, #bb55ff, #9933ee);
        }
        
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border: 3px solid #666;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 1000;
        }
        
        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        .victory { color: #00ff00; }
        .defeat { color: #ff4444; }
        
        @media (max-width: 768px) {
            .stat-box {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .stat-icon {
                font-size: 16px;
            }
            
            button {
                padding: 8px 16px;
                font-size: 13px;
            }
            
            .level-btn {
                padding: 5px 10px;
                font-size: 12px;
                min-width: 35px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- ë ˆë²¨ ì„ íƒ (ìƒë‹¨) -->
        <div id="levelSelect">
            <div class="level-title" onclick="game.toggleLevelSelect()">
                <span>â­ ë ˆë²¨ ë°”ë¡œê°€ê¸°</span>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="level-buttons" id="levelButtons"></div>
        </div>

        <!-- ì êµ° ìˆ˜ ì„ íƒ -->
        <div id="enemyCountSelect">
            <div class="level-title">
                <span>ğŸ‘¾ ì êµ° ìˆ˜ ì„ íƒ</span>
            </div>
            <div class="level-buttons" id="enemyCountButtons"></div>
        </div>

        <!-- ìƒíƒœ ì •ë³´ (ìƒë‹¨ìœ¼ë¡œ ì´ë™) -->
        <div class="stats-row">
            <div class="stat-box player">
                <span class="stat-icon">ğŸ‘¥</span>
                <span class="stat-value player" id="playerSupply">0/10</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ’</span>
                <span class="stat-value player" id="playerMinerals">50</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">âš™ï¸</span>
                <span class="stat-value player" id="playerScvs">1</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ¯</span>
                <span class="stat-value player" id="playerMarines">0</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">â›ï¸</span>
                <span class="stat-value player" id="miningRate">+8/s</span>
            </div>

            <div class="stat-box enemy">
                <span class="stat-icon">ğŸ‘¥</span>
                <span class="stat-value enemy" id="enemySupply">0/10</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ’</span>
                <span class="stat-value enemy" id="enemyMinerals">50</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">âš™ï¸</span>
                <span class="stat-value enemy" id="enemyScvs">1</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">ğŸ¯</span>
                <span class="stat-value enemy" id="enemyMarines">0</span>
            </div>

            <div class="stat-box info">
                <span class="stat-icon">ğŸ’€</span>
                <span class="stat-value" id="enemyKills">0</span>
                <span class="stat-separator">|</span>
                <span class="stat-icon">â­</span>
                <span class="stat-value" id="level">Lv.1</span>
            </div>
        </div>

        <canvas id="gameCanvas" width="1200" height="700"></canvas>

        <div id="ui">
            <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
            <div class="controls">
                <button class="btn-supply" onclick="game.buildSupply('player')">
                    <span>ğŸ—ï¸</span>
                    <span>ì„œí”Œë¼ì´ (100)</span>
                    <div class="cooldown-overlay" id="supplyCooldownOverlay"></div>
                </button>
                <button onclick="game.produceUnit('scv')">
                    <span>âš™ï¸</span>
                    <span>SCV (50)</span>
                    <div class="cooldown-overlay" id="scvCooldownOverlay"></div>
                </button>
                <button onclick="game.produceUnit('marine')">
                    <span>ğŸ¯</span>
                    <span>ë§ˆë¦° (50)</span>
                    <div class="cooldown-overlay" id="marineCooldownOverlay"></div>
                </button>
                <button class="btn-attack" onclick="game.attackCommand()">
                    <span>âš”ï¸</span>
                    <span>ì „ì²´ ê³µê²©!</span>
                </button>
                <button class="btn-retreat" onclick="game.retreatCommand()">
                    <span>ğŸƒ</span>
                    <span>ì „ì²´ íšŒêµ°!</span>
                </button>
                <button class="btn-hold" onclick="game.holdCommand()">
                    <span>ğŸ›‘</span>
                    <span>ë©ˆì¶¤!</span>
                </button>
            </div>
        </div>
        
        <div id="gameOver">
            <h2 id="gameOverTitle"></h2>
            <p id="gameOverStats"></p>
            <button onclick="game.restart()" style="margin-top: 20px;">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = 1200;
                this.height = 700;
                
                this.level = 1;
                this.enemyKills = 0;
                this.enemyCount = 1; // ì êµ° ìˆ˜ (1~3)
                this.playerMinerals = 50;
                this.playerSupply = 0;
                this.playerSupplyMax = 10;
                
                this.units = [];
                this.selectedUnits = [];
                this.supplies = []; // íƒ€ì›Œ ë°°ì—´
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
                
                this.playerBase = { x: 150, y: 150, hp: 500, maxHp: 500, owner: 'player' };
                
                // ì êµ°ì„ ë°°ì—´ë¡œ ê´€ë¦¬
                this.enemyBases = [];
                this.enemyMinerals = [];
                this.enemySupply = [];
                this.enemySupplyMax = [];
                this.enemyMinerals_patches = [];
                
                // í”Œë ˆì´ì–´ ë¯¸ë„¤ë„ì€ init()ì—ì„œ ëœë¤í•˜ê²Œ ë°°ì¹˜ë¨
                this.playerMinerals_patches = [];
                
                this.gameOver = false;

                // ì¿¨íƒ€ì„ ê´€ë ¨ ë³€ìˆ˜ë“¤
                this.supplyCooldown = 0; // ì„œí”Œë¼ì´ ì¿¨íƒ€ì„ (0.5ì´ˆ)
                this.supplyCooldownMax = 30; // 0.5ì´ˆ * 60fps
                this.scvCooldown = 0; // SCV ìƒì‚° ì¿¨íƒ€ì„ (0.1ì´ˆ)
                this.scvCooldownMax = 6; // 0.1ì´ˆ * 60fps
                this.marineCooldown = 0; // ë§ˆë¦° ìƒì‚° ì¿¨íƒ€ì„ (0.1ì´ˆ)
                this.marineCooldownMax = 6; // 0.1ì´ˆ * 60fps

                // ë ˆë²¨ ì„ íƒ ì ‘í˜ ìƒíƒœ
                this.levelSelectCollapsed = false;

                // ê³µê²©/íšŒêµ° ë²„íŠ¼ ìƒíƒœ ì¶”ì 
                this.isAttacking = false;
                this.isRetreating = false;

                this.init();
                this.createLevelButtons();
                this.createEnemyCountButtons();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            createLevelButtons() {
                const container = document.getElementById('levelButtons');
                for (let i = 1; i <= 10; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.textContent = i;
                    btn.onclick = () => this.jumpToLevel(i);
                    container.appendChild(btn);
                }
                this.updateLevelButtons();
            }

            createEnemyCountButtons() {
                const container = document.getElementById('enemyCountButtons');
                for (let i = 1; i <= 3; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'level-btn';
                    btn.textContent = `${i}ëª…`;
                    btn.onclick = () => this.setEnemyCount(i);
                    container.appendChild(btn);
                }
                this.updateEnemyCountButtons();
            }

            updateEnemyCountButtons() {
                const buttons = document.querySelectorAll('#enemyCountButtons .level-btn');
                buttons.forEach((btn, index) => {
                    btn.classList.toggle('active', index + 1 === this.enemyCount);
                });
            }

            setEnemyCount(count) {
                this.enemyCount = count;
                this.updateEnemyCountButtons();
                this.restart();
            }
            
            updateLevelButtons() {
                const buttons = document.querySelectorAll('.level-btn');
                buttons.forEach((btn, index) => {
                    btn.classList.toggle('active', index + 1 === this.level);
                });
            }

            toggleLevelSelect() {
                this.levelSelectCollapsed = !this.levelSelectCollapsed;
                const levelSelect = document.getElementById('levelSelect');
                const levelButtons = document.getElementById('levelButtons');
                if (this.levelSelectCollapsed) {
                    levelSelect.classList.add('collapsed');
                    levelButtons.classList.add('collapsed');
                } else {
                    levelSelect.classList.remove('collapsed');
                    levelButtons.classList.remove('collapsed');
                }
            }

            jumpToLevel(level) {
                this.level = level;
                this.restart();
            }
            
            init() {
                // í”Œë ˆì´ì–´ ë¯¸ë„¤ë„ íŒ¨ì¹˜ 1ê°œë¥¼ ë™ì‹¬ì› í…Œë‘ë¦¬ì— ëœë¤ ë°°ì¹˜
                const playerMineralAngle = Math.random() * Math.PI * 2;
                const playerMineralRadius = 100 + Math.random() * 50; // 100~150 ê±°ë¦¬
                this.playerMinerals_patches = [
                    { 
                        x: this.playerBase.x + Math.cos(playerMineralAngle) * playerMineralRadius, 
                        y: this.playerBase.y + Math.sin(playerMineralAngle) * playerMineralRadius, 
                        amount: 9999 
                    }
                ];
                
                // ì êµ° ì´ˆê¸°í™”
                this.initializeEnemies();
                
                this.createUnit('scv', 200, 200, 'player');
                
                // ê° ì êµ°ë§ˆë‹¤ ì´ˆê¸° SCV ìƒì„±
                for (let i = 0; i < this.enemyCount; i++) {
                    const base = this.enemyBases[i];
                    for (let j = 0; j < this.level; j++) {
                        this.createUnit('scv', base.x + (Math.random() - 0.5) * 40, 
                                              base.y + (Math.random() - 0.5) * 40, `enemy${i}`);
                    }
                }
                
                this.lastMineralUpdate = Date.now();
                this.lastEnemyProduction = [];
                for (let i = 0; i < this.enemyCount; i++) {
                    this.lastEnemyProduction[i] = Date.now();
                }
                this.lastEnemyQuickCheck = [];
                for (let i = 0; i < this.enemyCount; i++) {
                    this.lastEnemyQuickCheck[i] = Date.now();
                }
                this.updateUI();
            }

            initializeEnemies() {
                // ì êµ° ê¸°ì§€ ìœ„ì¹˜ ì„¤ì • (ë§µì— ì ì ˆíˆ ë°°ì¹˜)
                const enemyPositions = [
                    { x: 1050, y: 550 },  // ìš°í•˜ë‹¨
                    { x: 1050, y: 150 },  // ìš°ìƒë‹¨
                    { x: 600, y: 550 }    // ì¤‘í•˜ë‹¨
                ];

                this.enemyBases = [];
                this.enemyMinerals = [];
                this.enemySupply = [];
                this.enemySupplyMax = [];
                this.enemyMinerals_patches = [];

                for (let i = 0; i < this.enemyCount; i++) {
                    const pos = enemyPositions[i];
                    this.enemyBases.push({ 
                        x: pos.x, 
                        y: pos.y, 
                        hp: 500, 
                        maxHp: 500, 
                        owner: `enemy${i}`,
                        index: i
                    });
                    this.enemyMinerals.push(50);
                    this.enemySupply.push(0);
                    this.enemySupplyMax.push(10);
                    
                    // ê° ì êµ°ë§ˆë‹¤ ë¯¸ë„¤ë„ íŒ¨ì¹˜ 1ê°œë¥¼ ë™ì‹¬ì› í…Œë‘ë¦¬ì— ëœë¤ ë°°ì¹˜
                    const enemyMineralAngle = Math.random() * Math.PI * 2;
                    const enemyMineralRadius = 100 + Math.random() * 50; // 100~150 ê±°ë¦¬
                    this.enemyMinerals_patches.push([
                        { 
                            x: pos.x + Math.cos(enemyMineralAngle) * enemyMineralRadius, 
                            y: pos.y + Math.sin(enemyMineralAngle) * enemyMineralRadius, 
                            amount: 9999 
                        }
                    ]);
                }
            }
            
            createUnit(type, x, y, owner) {
                const unit = {
                    type,
                    x,
                    y,
                    owner,
                    selected: false,
                    targetX: x,
                    targetY: y,
                    hp: type === 'scv' ? 60 : 40,
                    maxHp: type === 'scv' ? 60 : 40,
                    speed: type === 'scv' ? 2 : 2.5,
                    range: type === 'marine' ? 100 : 10,
                    damage: type === 'marine' ? 6 : 5,
                    attackCooldown: 0,
                    mining: false,
                    miningTarget: null,
                    attackTarget: null,
                    returning: false,
                    supply: 1,
                    isHolding: type === 'marine' && owner === 'player', // í”Œë ˆì´ì–´ ë§ˆë¦°ì€ ìƒì„± ì‹œ ìë™ìœ¼ë¡œ ë©ˆì¶¤ ìƒíƒœ
                    isMovingToTarget: false
                };
                this.units.push(unit);
                
                if (owner === 'player') {
                    this.playerSupply += 1;
                } else {
                    // enemy0, enemy1, enemy2 í˜•ì‹ì—ì„œ ì¸ë±ìŠ¤ ì¶”ì¶œ
                    const enemyIndex = parseInt(owner.replace('enemy', ''));
                    if (!isNaN(enemyIndex) && this.enemySupply[enemyIndex] !== undefined) {
                        this.enemySupply[enemyIndex] += 1;
                    }
                }
                
                return unit;
            }
            
            produceUnit(type) {
                if (this.gameOver) return;
                const cost = 50;

                // ì¿¨íƒ€ì„ ì²´í¬
                if (type === 'scv' && this.scvCooldown > 0) return;
                if (type === 'marine' && this.marineCooldown > 0) return;

                if (this.playerSupply >= this.playerSupplyMax) {
                    return;
                }

                if (this.playerMinerals >= cost) {
                    this.playerMinerals -= cost;
                    const spawnX = this.playerBase.x + (Math.random() - 0.5) * 60;
                    const spawnY = this.playerBase.y + (Math.random() - 0.5) * 60;
                    this.createUnit(type, spawnX, spawnY, 'player');

                    // ì¿¨íƒ€ì„ ì‹œì‘
                    if (type === 'scv') {
                        this.scvCooldown = this.scvCooldownMax;
                    } else if (type === 'marine') {
                        this.marineCooldown = this.marineCooldownMax;
                    }

                    this.updateUI();
                }
            }
            
            buildSupply(owner) {
                const cost = 100;
                if (owner === 'player') {
                    if (this.supplyCooldown > 0) return; // ì¿¨íƒ€ì„ ì¤‘ì´ë©´ ë¦¬í„´
                    if (this.playerMinerals >= cost) {
                        this.playerMinerals -= cost;
                        this.playerSupplyMax += 10;
                        this.supplyCooldown = this.supplyCooldownMax; // ì¿¨íƒ€ì„ ì‹œì‘
                        this.updateUI();
                    }
                } else {
                    // enemy0, enemy1, enemy2 í˜•ì‹ì—ì„œ ì¸ë±ìŠ¤ ì¶”ì¶œ
                    const enemyIndex = parseInt(owner.replace('enemy', ''));
                    if (!isNaN(enemyIndex) && this.enemyMinerals[enemyIndex] !== undefined) {
                        if (this.enemyMinerals[enemyIndex] >= cost) {
                            this.enemyMinerals[enemyIndex] -= cost;
                            this.enemySupplyMax[enemyIndex] += 10;
                            this.updateUI();
                        }
                    }
                }
            }
            
            attackCommand() {
                if (this.gameOver) return;
                
                // ì´ë¯¸ ê³µê²© ì¤‘ì´ë©´ ë©ˆì¶¤ ëª…ë ¹ ì‹¤í–‰
                if (this.isAttacking) {
                    this.holdCommand();
                    this.isAttacking = false;
                    return;
                }
                
                this.isAttacking = true;
                this.isRetreating = false;
                
                // ëª¨ë“  ë§ˆë¦°ì„ ì„ íƒ ìƒíƒœë¡œ ì„¤ì •
                this.selectedUnits = [];
                this.units.forEach(unit => {
                    if (unit.owner === 'player' && unit.type === 'marine') {
                        unit.selected = true;
                        this.selectedUnits.push(unit);
                        
                        // ê°€ì¥ ê°€ê¹Œìš´ ì êµ° ê¸°ì§€ë¥¼ íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì •
                        let nearestEnemyBase = null;
                        let nearestDist = Infinity;
                        this.enemyBases.forEach(base => {
                            const dist = this.distance(unit, base);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestEnemyBase = base;
                            }
                        });
                        if (nearestEnemyBase) {
                            unit.targetX = nearestEnemyBase.x;
                            unit.targetY = nearestEnemyBase.y;
                        }
                        unit.mining = false;
                        unit.isHolding = false;
                        unit.isMovingToTarget = true; // íƒ€ê²Ÿ ì´ë™ ì¤‘ í”Œë˜ê·¸
                    }
                });
            }
            
            retreatCommand() {
                if (this.gameOver) return;
                
                // ì´ë¯¸ íšŒêµ° ì¤‘ì´ë©´ ë©ˆì¶¤ ëª…ë ¹ ì‹¤í–‰
                if (this.isRetreating) {
                    this.holdCommand();
                    this.isRetreating = false;
                    return;
                }
                
                this.isRetreating = true;
                this.isAttacking = false;
                
                // ëª¨ë“  ë§ˆë¦°ì„ ì„ íƒ ìƒíƒœë¡œ ì„¤ì •
                this.selectedUnits = [];
                this.units.forEach(unit => {
                    if (unit.owner === 'player' && unit.type === 'marine') {
                        unit.selected = true;
                        this.selectedUnits.push(unit);
                    }
                    if (unit.owner === 'player') {
                        unit.targetX = this.playerBase.x + (Math.random() - 0.5) * 100;
                        unit.targetY = this.playerBase.y + (Math.random() - 0.5) * 100;
                        unit.mining = false;
                        unit.attackTarget = null;
                        unit.isHolding = false;
                        unit.isMovingToTarget = true; // íƒ€ê²Ÿ ì´ë™ ì¤‘ í”Œë˜ê·¸
                    }
                });
            }
            
            holdCommand() {
                if (this.gameOver) return;
                this.isAttacking = false;
                this.isRetreating = false;
                this.units.forEach(unit => {
                    if (unit.owner === 'player' && unit.type === 'marine') {
                        unit.targetX = unit.x;
                        unit.targetY = unit.y;
                        unit.isHolding = true;
                        unit.isMovingToTarget = false;
                    }
                });
            }
            
            setupEventListeners() {
                // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
                this.canvas.addEventListener('mousedown', (e) => this.handlePointerDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handlePointerMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handlePointerUp(e));
                this.canvas.addEventListener('contextmenu', (e) => this.handleRightClick(e));

                // í„°ì¹˜ ì´ë²¤íŠ¸
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // ë‘ ì†ê°€ë½ í„°ì¹˜ ê°ì§€
                    if (e.touches.length === 2) {
                        // ë‘ ì†ê°€ë½ì˜ ì¤‘ê°„ ì§€ì  ê³„ì‚°
                        const rect = this.canvas.getBoundingClientRect();
                        const scaleX = this.width / rect.width;
                        const scaleY = this.height / rect.height;
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const midX = ((touch1.clientX + touch2.clientX) / 2 - rect.left) * scaleX;
                        const midY = ((touch1.clientY + touch2.clientY) / 2 - rect.top) * scaleY;
                        
                        // ìœ ë‹›ì´ ì„ íƒëœ ê²½ìš° ì´ë™ ëª…ë ¹
                        if (this.selectedUnits.length > 0) {
                            this.selectedUnits.forEach(unit => {
                                if (unit.owner === 'player') {
                                    unit.targetX = midX;
                                    unit.targetY = midY;
                                    unit.mining = false;
                                    unit.attackTarget = null;
                                    unit.isHolding = false;
                                    if (unit.type === 'marine') {
                                        unit.isMovingToTarget = true;
                                    }
                                }
                            });
                            this.isAttacking = false;
                            this.isRetreating = false;
                        } else {
                            // ìœ ë‹›ì´ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš° ì„œí”Œë¼ì´ ìƒì„±
                            this.createSupply(midX, midY);
                        }
                        return;
                    }
                    this.handleTouchStart(e);
                });
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    // ë‘ ì†ê°€ë½ í„°ì¹˜ ì¤‘ì´ë©´ ì„œí”Œë¼ì´ ìƒì„±í•˜ì§€ ì•ŠìŒ
                    if (e.touches.length === 2) {
                        return;
                    }
                    this.handleTouchMove(e);
                });
                this.canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    // ë‘ ì†ê°€ë½ í„°ì¹˜ê°€ ëë‚˜ë©´ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
                    if (e.touches.length >= 2) {
                        return;
                    }
                    this.handleTouchEnd(e);
                });
            }
            
            getPointerPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.width / rect.width;
                const scaleY = this.height / rect.height;

                // í„°ì¹˜ ì´ë²¤íŠ¸ì¸ì§€ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ì¸ì§€ í™•ì¸
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            handlePointerDown(e) {
                if (this.gameOver) return;
                this.isDragging = true;
                this.dragStart = this.getPointerPosition(e);
            }

            handlePointerMove(e) {
                if (this.isDragging && this.dragStart) {
                    this.dragEnd = this.getPointerPosition(e);
                }
            }

            handlePointerUp(e) {
                if (this.isDragging && this.dragStart && this.dragEnd) {
                    this.selectUnits();
                }
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
            }

            handleTouchStart(e) {
                // í„°ì¹˜ ì‹œì‘ ì‹œì  ê¸°ë¡
                this.touchStartTime = Date.now();
                this.touchStartPos = this.getPointerPosition(e);
                this.isDragging = false;
                this.hasMoved = false;
            }

            handleTouchMove(e) {
                if (!this.touchStartPos) return;

                const currentPos = this.getPointerPosition(e);
                const moveThreshold = 10;

                // ë“œë˜ê·¸ë¡œ ê°„ì£¼ë˜ëŠ” ìµœì†Œ ì´ë™ ê±°ë¦¬ ì²´í¬
                if (!this.isDragging &&
                    (Math.abs(currentPos.x - this.touchStartPos.x) > moveThreshold ||
                     Math.abs(currentPos.y - this.touchStartPos.y) > moveThreshold)) {
                    // ë“œë˜ê·¸ ì‹œì‘
                    this.isDragging = true;
                    this.dragStart = this.touchStartPos;
                }

                if (this.isDragging) {
                    this.dragEnd = currentPos;
                }
            }

            handleTouchEnd(e) {
                const touchDuration = Date.now() - this.touchStartTime;
                const currentPos = this.getPointerPosition(e);

                if (this.isDragging && this.dragStart && this.dragEnd) {
                    // ë“œë˜ê·¸ì˜€ë‹¤ë©´ ìœ ë‹› ì„ íƒ
                    this.selectUnits();
                } else if (touchDuration < 300) {
                    // ì§§ì€ íƒ­
                    if (this.selectedUnits.length > 0) {
                        // ìœ ë‹›ì´ ì„ íƒë˜ì–´ ìˆë‹¤ë©´ ì´ë™ ëª…ë ¹
                        this.selectedUnits.forEach(unit => {
                            if (unit.owner === 'player') {
                                unit.targetX = currentPos.x;
                                unit.targetY = currentPos.y;
                                unit.mining = false;
                                unit.attackTarget = null;
                                unit.isHolding = false;
                                // ë§ˆë¦° ìœ ë‹›ì€ íƒ€ê²Ÿ ì´ë™ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
                                if (unit.type === 'marine') {
                                    unit.isMovingToTarget = true;
                                }
                            }
                        });
                        // ê³µê²©/íšŒêµ° ìƒíƒœ ì´ˆê¸°í™”
                        this.isAttacking = false;
                        this.isRetreating = false;
                    } else {
                        // ì„ íƒëœ ìœ ë‹›ì´ ì—†ë‹¤ë©´ í•´ë‹¹ ìœ„ì¹˜ ê·¼ì²˜ ìœ ë‹› ì„ íƒ
                        this.selectUnitsAtPosition(currentPos);
                    }
                } else {
                    // ê¸´ íƒ­ì€ ìš°í´ë¦­ìœ¼ë¡œ ì²˜ë¦¬
                    this.handleRightClick(e);
                }

                // ìƒíƒœ ì´ˆê¸°í™”
                this.isDragging = false;
                this.dragStart = null;
                this.dragEnd = null;
                this.touchStartTime = null;
                this.touchStartPos = null;
            }
            
            handleRightClick(e) {
                e.preventDefault();
                if (this.gameOver) return;
                const pos = this.getPointerPosition(e);
                
                // ìœ ë‹›ì´ ì„ íƒëœ ê²½ìš° ì´ë™ ëª…ë ¹
                if (this.selectedUnits.length > 0) {
                    this.selectedUnits.forEach(unit => {
                        if (unit.owner === 'player') {
                            unit.targetX = pos.x;
                            unit.targetY = pos.y;
                            unit.mining = false;
                            unit.attackTarget = null;
                            unit.isHolding = false;
                            // ë§ˆë¦° ìœ ë‹›ì€ íƒ€ê²Ÿ ì´ë™ ì¤‘ í”Œë˜ê·¸ ì„¤ì •
                            if (unit.type === 'marine') {
                                unit.isMovingToTarget = true;
                            }
                        }
                    });
                    // ê³µê²©/íšŒêµ° ìƒíƒœ ì´ˆê¸°í™”
                    this.isAttacking = false;
                    this.isRetreating = false;
                } else {
                    // ìœ ë‹›ì´ ì„ íƒë˜ì§€ ì•Šì€ ê²½ìš° ì„œí”Œë¼ì´ ìƒì„±
                    this.createSupply(pos.x, pos.y);
                }
            }

            createSupply(x, y) {
                // ìƒì‚°ë¹„ ì²´í¬ (200 ë¯¸ë„¤ë„)
                const cost = 200;
                if (this.playerMinerals < cost) {
                    return;
                }
                
                // ë§µ ê²½ê³„ ì²´í¬
                if (x < 20 || x > this.width - 20 || y < 20 || y > this.height - 20) {
                    return;
                }
                
                // ë‹¤ë¥¸ íƒ€ì›Œì™€ ë„ˆë¬´ ê°€ê¹Œìš´ì§€ ì²´í¬
                const minDistance = 10;
                let tooClose = false;
                for (let supply of this.supplies) {
                    const dist = Math.sqrt((x - supply.x) ** 2 + (y - supply.y) ** 2);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                if (tooClose) return;
                
                // íƒ€ì›Œ ìƒì„± (SCV í¬ê¸°: 16x16, ê¸°ì§€ HPì˜ 1/10, ë§ˆë¦°ê³¼ ë™ì¼í•œ ê³µê²©ë ¥)
                this.playerMinerals -= cost;
                this.supplies.push({
                    x: x,
                    y: y,
                    size: 16, // SCVì™€ ë™ì¼í•œ í¬ê¸°
                    radius: 8,  // íšŒí”¼ ë°˜ê²½
                    hp: 50,     // ê¸°ì§€ HP(500)ì˜ 1/10
                    maxHp: 50,
                    owner: 'player', // ì•„êµ° íƒ€ì›Œ
                    damage: 6,  // ë§ˆë¦°ê³¼ ë™ì¼í•œ ê³µê²©ë ¥
                    range: 100, // ë§ˆë¦°ê³¼ ë™ì¼í•œ ì‚¬ê±°ë¦¬
                    attackCooldown: 0,
                    attackTarget: null
                });
                this.updateUI();
            }
            
            selectUnits() {
                const minX = Math.min(this.dragStart.x, this.dragEnd.x);
                const maxX = Math.max(this.dragStart.x, this.dragEnd.x);
                const minY = Math.min(this.dragStart.y, this.dragEnd.y);
                const maxY = Math.max(this.dragStart.y, this.dragEnd.y);
                this.selectedUnits = [];
                this.units.forEach(unit => {
                    unit.selected = false;
                    if (unit.owner === 'player' &&
                        unit.x >= minX && unit.x <= maxX &&
                        unit.y >= minY && unit.y <= maxY) {
                        unit.selected = true;
                        this.selectedUnits.push(unit);
                    }
                });
            }

            selectUnitsAtPosition(pos) {
                // íŠ¹ì • ìœ„ì¹˜ ê·¼ì²˜ì˜ ìœ ë‹›ë“¤ì„ ì„ íƒ (í„°ì¹˜ ë°˜ê²½ ë‚´)
                const touchRadius = 30; // í„°ì¹˜ ì„ íƒ ë°˜ê²½
                this.selectedUnits = [];
                this.units.forEach(unit => {
                    unit.selected = false;
                    const dist = this.distance(unit, pos);
                    if (unit.owner === 'player' && dist <= touchRadius) {
                        unit.selected = true;
                        this.selectedUnits.push(unit);
                    }
                });
            }
            
            gameLoop() {
                if (!this.gameOver) {
                    this.update();
                }
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            update() {
                const now = Date.now();
                if (now - this.lastMineralUpdate > 1000) {
                    const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
                    this.playerMinerals += playerScvs * 8;
                    
                    // ê° ì êµ°ë§ˆë‹¤ ë¯¸ë„¤ë„ ìˆ˜ì§‘
                    for (let i = 0; i < this.enemyCount; i++) {
                        const enemyScvs = this.units.filter(u => u.owner === `enemy${i}` && u.type === 'scv').length;
                        this.enemyMinerals[i] += enemyScvs * 8;
                    }
                    this.lastMineralUpdate = now;
                    this.updateUI();
                }
                
                // ê° ì êµ°ë§ˆë‹¤ AI ì‹¤í–‰
                for (let i = 0; i < this.enemyCount; i++) {
                    if (now - (this.lastEnemyProduction[i] || 0) > 5000) {
                        this.enemyAI(i);
                        this.lastEnemyProduction[i] = now;
                    }
                    
                    if (now - (this.lastEnemyQuickCheck[i] || 0) > 3000) {
                        this.enemyQuickProduction(i);
                        this.lastEnemyQuickCheck[i] = now;
                    }
                }
                
                // ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
                if (this.supplyCooldown > 0) this.supplyCooldown--;
                if (this.scvCooldown > 0) this.scvCooldown--;
                if (this.marineCooldown > 0) this.marineCooldown--;

                this.units.forEach(unit => {
                    this.updateUnit(unit);
                });
                
                this.units.forEach(unit => {
                    if (unit.type === 'scv') {
                        this.scvBehavior(unit);
                    }
                });
                
                this.units.forEach(unit => {
                    if (unit.type === 'marine') {
                        this.marineBehavior(unit);
                    }
                });
                
                // íƒ€ì›Œ ê³µê²© ë¡œì§
                this.supplies.forEach(tower => {
                    if (tower.owner === 'player' && tower.hp > 0) {
                        this.towerBehavior(tower);
                    }
                });
                
                this.units = this.units.filter(unit => {
                    if (unit.hp <= 0) {
                        if (unit.owner.startsWith('enemy')) {
                            this.enemyKills++;
                            this.updateUI();
                        }
                        if (unit.owner === 'player') {
                            this.playerSupply -= unit.supply;
                        } else {
                            const enemyIndex = parseInt(unit.owner.replace('enemy', ''));
                            if (!isNaN(enemyIndex) && this.enemySupply[enemyIndex] !== undefined) {
                                this.enemySupply[enemyIndex] -= unit.supply;
                            }
                        }
                        return false;
                    }
                    return true;
                });
                
                // íŒŒê´´ëœ íƒ€ì›Œ ì œê±°
                this.supplies = this.supplies.filter(tower => {
                    return tower.hp > 0;
                });
                
                this.checkGameOver();
            }
            
            updateUnit(unit) {
                const dx = unit.targetX - unit.x;
                const dy = unit.targetY - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 5) {
                    let moveX = (dx / distance) * unit.speed;
                    let moveY = (dy / distance) * unit.speed;
                    const avoidance = this.calculateAvoidance(unit);
                    moveX += avoidance.x;
                    moveY += avoidance.y;
                    
                    // ì´ë™ ì „ ìœ„ì¹˜ ì €ì¥
                    const oldX = unit.x;
                    const oldY = unit.y;
                    
                    // ì´ë™ ì‹œë„
                    unit.x += moveX;
                    unit.y += moveY;
                    
                    // íƒ€ì›Œì™€ì˜ ì¶©ëŒ ì²´í¬ ë° ì²˜ë¦¬
                    this.resolveSupplyCollision(unit, oldX, oldY);
                    
                    // ë§µ ê²½ê³„ ì²´í¬
                    unit.x = Math.max(20, Math.min(this.width - 20, unit.x));
                    unit.y = Math.max(20, Math.min(this.height - 20, unit.y));
                } else {
                    // íƒ€ê²Ÿ ì§€ì ì— ë„ì°©í–ˆì„ ë•Œ
                    if (unit.isMovingToTarget && unit.owner === 'player' && unit.type === 'marine') {
                        // ë©ˆì¶”ê³  ì ì„ ê³µê²©í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
                        unit.isHolding = true;
                        unit.isMovingToTarget = false;
                        unit.targetX = unit.x;
                        unit.targetY = unit.y;
                    }
                }
                if (unit.attackCooldown > 0) {
                    unit.attackCooldown--;
                }
            }

            resolveSupplyCollision(unit, oldX, oldY) {
                const unitRadius = 8; // ìœ ë‹› ë°˜ê²½
                
                this.supplies.forEach(tower => {
                    // íŒŒê´´ëœ íƒ€ì›ŒëŠ” ë¬´ì‹œ
                    if (tower.hp <= 0) return;
                    const dx = unit.x - tower.x;
                    const dy = unit.y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = tower.radius + unitRadius; // íƒ€ì›Œ ë°˜ê²½ + ìœ ë‹› ë°˜ê²½
                    
                    // íƒ€ì›Œì™€ ì¶©ëŒí•˜ëŠ” ê²½ìš°
                    if (dist < minDist && dist > 0) {
                        // íƒ€ì›Œ ë°–ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°
                        const pushDistance = minDist - dist;
                        const pushX = (dx / dist) * pushDistance;
                        const pushY = (dy / dist) * pushDistance;
                        unit.x += pushX;
                        unit.y += pushY;
                        
                        // ê²½ë¡œê°€ íƒ€ì›Œë¥¼ í†µê³¼í•˜ëŠ” ê²½ìš° ìš°íšŒ ê²½ë¡œ ê³„ì‚°
                        const targetDx = unit.targetX - tower.x;
                        const targetDy = unit.targetY - tower.y;
                        const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                        
                        if (targetDist < minDist + 20) {
                            // íƒ€ê²Ÿì´ íƒ€ì›Œ ë„ˆë¨¸ì— ìˆìœ¼ë©´ ìš°íšŒ ê²½ë¡œ ì„¤ì •
                            const angle = Math.atan2(targetDy, targetDx);
                            const bypassRadius = minDist + 30;
                            const bypassX = tower.x + Math.cos(angle) * bypassRadius;
                            const bypassY = tower.y + Math.sin(angle) * bypassRadius;
                            
                            // ìš°íšŒ ì§€ì ì„ ì„ì‹œ íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì • (ì§ì ‘ íƒ€ê²Ÿìœ¼ë¡œ ì„¤ì •í•˜ì§€ ì•Šê³  íšŒí”¼ë§Œ)
                            const bypassDx = bypassX - unit.x;
                            const bypassDy = bypassY - unit.y;
                            const bypassDist = Math.sqrt(bypassDx * bypassDx + bypassDy * bypassDy);
                            
                            if (bypassDist > 5) {
                                // ìš°íšŒ ë°©í–¥ìœ¼ë¡œ ì•½ê°„ ì´ë™
                                const bypassMoveX = (bypassDx / bypassDist) * unit.speed * 0.5;
                                const bypassMoveY = (bypassDy / bypassDist) * unit.speed * 0.5;
                                unit.x += bypassMoveX;
                                unit.y += bypassMoveY;
                            }
                        }
                    }
                });
            }
            
            calculateAvoidance(unit) {
                let avoidX = 0;
                let avoidY = 0;
                const minDist = 18;
                
                // ë‹¤ë¥¸ ìœ ë‹› íšŒí”¼
                this.units.forEach(other => {
                    if (other !== unit) {
                        const dx = unit.x - other.x;
                        const dy = unit.y - other.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < minDist && dist > 0) {
                            avoidX += (dx / dist) * 0.5;
                            avoidY += (dy / dist) * 0.5;
                        }
                    }
                });
                
                // íƒ€ì›Œ íšŒí”¼ (ë” ê°•ë ¥í•˜ê²Œ)
                const unitRadius = 8;
                this.supplies.forEach(tower => {
                    // íŒŒê´´ëœ íƒ€ì›ŒëŠ” ë¬´ì‹œ
                    if (tower.hp <= 0) return;
                    const dx = unit.x - tower.x;
                    const dy = unit.y - tower.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const avoidRadius = tower.radius + unitRadius + 15; // íƒ€ì›Œ ë°˜ê²½ + ìœ ë‹› ë°˜ê²½ + ì—¬ìœ  ê³µê°„
                    
                    if (dist < avoidRadius && dist > 0) {
                        // ê±°ë¦¬ê°€ ê°€ê¹Œìš¸ìˆ˜ë¡ ë” ê°•í•˜ê²Œ íšŒí”¼
                        const avoidStrength = (avoidRadius - dist) / avoidRadius;
                        // íƒ€ì›ŒëŠ” ì ˆëŒ€ í†µê³¼í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ë§¤ìš° ê°•í•˜ê²Œ íšŒí”¼
                        avoidX += (dx / dist) * avoidStrength * 3.0;
                        avoidY += (dy / dist) * avoidStrength * 3.0;
                    }
                    
                    // ê²½ë¡œê°€ íƒ€ì›Œë¥¼ í†µê³¼í•˜ëŠ”ì§€ ì²´í¬
                    const targetDx = unit.targetX - unit.x;
                    const targetDy = unit.targetY - unit.y;
                    const targetDist = Math.sqrt(targetDx * targetDx + targetDy * targetDy);
                    
                    if (targetDist > 0) {
                        // ìœ ë‹›ì—ì„œ íƒ€ê²Ÿê¹Œì§€ì˜ ì„ ë¶„ì´ íƒ€ì›Œì™€ êµì°¨í•˜ëŠ”ì§€ ì²´í¬
                        const toTowerDx = tower.x - unit.x;
                        const toTowerDy = tower.y - unit.y;
                        const projection = (toTowerDx * targetDx + toTowerDy * targetDy) / (targetDist * targetDist);
                        
                        if (projection > 0 && projection < 1) {
                            // ê²½ë¡œìƒì˜ ê°€ì¥ ê°€ê¹Œìš´ ì 
                            const closestX = unit.x + targetDx * projection;
                            const closestY = unit.y + targetDy * projection;
                            const closestDx = closestX - tower.x;
                            const closestDy = closestY - tower.y;
                            const closestDist = Math.sqrt(closestDx * closestDx + closestDy * closestDy);
                            
                            if (closestDist < avoidRadius) {
                                // ê²½ë¡œê°€ íƒ€ì›Œë¥¼ í†µê³¼í•˜ë¯€ë¡œ ê°•í•˜ê²Œ íšŒí”¼
                                const sideX = -targetDy / targetDist; // ìˆ˜ì§ ë°©í–¥
                                const sideY = targetDx / targetDist;
                                const side = (closestDx * sideX + closestDy * sideY) > 0 ? 1 : -1;
                                avoidX += sideX * side * 2.0;
                                avoidY += sideY * side * 2.0;
                            }
                        }
                    }
                });
                
                return { x: avoidX, y: avoidY };
            }
            
            scvBehavior(unit) {
                if (unit.attackTarget) return;
                
                let mineralPatches, base;
                if (unit.owner === 'player') {
                    mineralPatches = this.playerMinerals_patches;
                    base = this.playerBase;
                } else {
                    const enemyIndex = parseInt(unit.owner.replace('enemy', ''));
                    if (!isNaN(enemyIndex) && this.enemyMinerals_patches[enemyIndex]) {
                        mineralPatches = this.enemyMinerals_patches[enemyIndex];
                        base = this.enemyBases[enemyIndex];
                    } else {
                        return;
                    }
                }
                
                if (!unit.mining && !unit.returning) {
                    const nearest = this.findNearest(unit, mineralPatches);
                    if (nearest) {
                        unit.miningTarget = nearest;
                        unit.targetX = nearest.x;
                        unit.targetY = nearest.y;
                        unit.mining = true;
                    }
                }
                if (unit.mining && unit.miningTarget) {
                    const dist = this.distance(unit, unit.miningTarget);
                    if (dist < 30) {
                        unit.returning = true;
                        unit.mining = false;
                        unit.targetX = base.x;
                        unit.targetY = base.y;
                    }
                }
                if (unit.returning) {
                    const dist = this.distance(unit, base);
                    if (dist < 40) {
                        unit.returning = false;
                    }
                }
            }
            
            towerBehavior(tower) {
                // íƒ€ì›Œ ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
                if (tower.attackCooldown > 0) {
                    tower.attackCooldown--;
                }
                
                // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                let nearestEnemy = null;
                let nearestDist = Infinity;
                const targets = [...this.units.filter(u => u.owner.startsWith('enemy'))];
                this.enemyBases.forEach(base => targets.push(base));
                
                targets.forEach(target => {
                    const dist = this.distance(tower, target);
                    if (dist < nearestDist && dist < tower.range) {
                        nearestDist = dist;
                        nearestEnemy = target;
                    }
                });
                
                // ê³µê²©
                if (nearestEnemy && nearestDist < tower.range) {
                    if (tower.attackCooldown === 0) {
                        if (nearestEnemy.hp !== undefined) {
                            nearestEnemy.hp -= tower.damage;
                        }
                        tower.attackCooldown = 15; // ë§ˆë¦°ê³¼ ë™ì¼í•œ ê³µê²© ì†ë„
                    }
                    tower.attackTarget = nearestEnemy;
                } else {
                    tower.attackTarget = null;
                }
            }
            
            marineBehavior(unit) {
                if (unit.isHolding) {
                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    let targets = [];
                    
                    if (unit.owner === 'player') {
                        // í”Œë ˆì´ì–´ ë§ˆë¦°: ëª¨ë“  ì êµ° ìœ ë‹›ê³¼ ê¸°ì§€ íƒ€ê²Ÿ
                        targets = [...this.units.filter(u => u.owner.startsWith('enemy'))];
                        this.enemyBases.forEach(base => targets.push(base));
                    } else {
                        // ì êµ° ë§ˆë¦°: í”Œë ˆì´ì–´ ìœ ë‹›, ê¸°ì§€, ê·¸ë¦¬ê³  ì•„êµ° íƒ€ì›Œ íƒ€ê²Ÿ
                        targets = [...this.units.filter(u => u.owner === 'player'), this.playerBase];
                        // ì•„êµ° íƒ€ì›Œë„ ê³µê²© íƒ€ê²Ÿì— ì¶”ê°€
                        this.supplies.forEach(tower => {
                            if (tower.owner === 'player' && tower.hp > 0) {
                                targets.push(tower);
                            }
                        });
                    }
                    
                    targets.forEach(target => {
                        const dist = this.distance(unit, target);
                        if (dist < nearestDist && dist < unit.range) {
                            nearestDist = dist;
                            nearestEnemy = target;
                        }
                    });
                    if (nearestEnemy && nearestDist < unit.range) {
                        if (unit.attackCooldown === 0) {
                            if (nearestEnemy.hp !== undefined) {
                                nearestEnemy.hp -= unit.damage;
                            }
                            unit.attackCooldown = 15;
                        }
                        unit.attackTarget = nearestEnemy;
                    } else {
                        unit.attackTarget = null;
                    }
                    return;
                }
                
                if (unit.owner.startsWith('enemy')) {
                    const enemyIndex = parseInt(unit.owner.replace('enemy', ''));
                    const enemyBase = this.enemyBases[enemyIndex];
                    // 1ë‹¨ê³„ì—ì„œëŠ” ì êµ° ë§ˆë¦°ì´ ê³µê²©í•˜ì§€ ì•Šê³  ë°©ì–´ì ìœ¼ë¡œ í–‰ë™
                    if (this.level === 1) {
                        // í”Œë ˆì´ì–´ê°€ ê°€ê¹Œì´ ì˜¤ë©´ ì•½ê°„ í›„í‡´í•˜ì§€ë§Œ ê³µê²©í•˜ì§€ ì•ŠìŒ
                        let nearestPlayer = null;
                        let nearestDist = Infinity;
                        const targets = [...this.units.filter(u => u.owner === 'player')];
                        targets.forEach(target => {
                            const dist = this.distance(unit, target);
                            if (dist < nearestDist) {
                                nearestDist = dist;
                                nearestPlayer = target;
                            }
                        });

                        if (nearestPlayer && nearestDist < 150) {
                            // í”Œë ˆì´ì–´ê°€ ê°€ê¹Œìš°ë©´ ì•½ê°„ í›„í‡´
                            const angle = Math.atan2(unit.y - nearestPlayer.y, unit.x - nearestPlayer.x);
                            unit.targetX = unit.x + Math.cos(angle) * 50;
                            unit.targetY = unit.y + Math.sin(angle) * 50;
                        } else {
                            // í‰ìƒì‹œì—ëŠ” ê¸°ì§€ ì£¼ë³€ì„ ìˆœì°°
                            const dist = this.distance(unit, enemyBase);
                            if (dist > 80) {
                                unit.targetX = enemyBase.x + (Math.random() - 0.5) * 60;
                                unit.targetY = enemyBase.y + (Math.random() - 0.5) * 60;
                            }
                        }
                        unit.attackTarget = null;
                        return;
                    }

                    let nearestEnemy = null;
                    let nearestDist = Infinity;
                    const targets = [...this.units.filter(u => u.owner === 'player'), this.playerBase];
                    // ì•„êµ° íƒ€ì›Œë„ ê³µê²© íƒ€ê²Ÿì— ì¶”ê°€ (ê²½ë¡œë¥¼ ë§‰ëŠ” ê²½ìš° ìš°ì„  ê³µê²©)
                    this.supplies.forEach(tower => {
                        if (tower.owner === 'player' && tower.hp > 0) {
                            // ìœ ë‹›ì—ì„œ í”Œë ˆì´ì–´ ê¸°ì§€ê¹Œì§€ì˜ ê²½ë¡œê°€ íƒ€ì›Œë¥¼ í†µê³¼í•˜ëŠ”ì§€ ì²´í¬
                            const toBaseDx = this.playerBase.x - unit.x;
                            const toBaseDy = this.playerBase.y - unit.y;
                            const toBaseDist = Math.sqrt(toBaseDx * toBaseDx + toBaseDy * toBaseDy);
                            if (toBaseDist > 0) {
                                const toTowerDx = tower.x - unit.x;
                                const toTowerDy = tower.y - unit.y;
                                const projection = (toTowerDx * toBaseDx + toTowerDy * toBaseDy) / (toBaseDist * toBaseDist);
                                
                                if (projection > 0 && projection < 1) {
                                    // ê²½ë¡œìƒì˜ ê°€ì¥ ê°€ê¹Œìš´ ì 
                                    const closestX = unit.x + toBaseDx * projection;
                                    const closestY = unit.y + toBaseDy * projection;
                                    const closestDx = closestX - tower.x;
                                    const closestDy = closestY - tower.y;
                                    const closestDist = Math.sqrt(closestDx * closestDx + closestDy * closestDy);
                                    
                                    // ê²½ë¡œë¥¼ ë§‰ëŠ” íƒ€ì›ŒëŠ” ìš°ì„  íƒ€ê²Ÿ
                                    if (closestDist < tower.radius + 20) {
                                        targets.push(tower);
                                    }
                                }
                            }
                        }
                    });
                    
                    targets.forEach(target => {
                        const dist = this.distance(unit, target);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestEnemy = target;
                        }
                    });
                    if (nearestEnemy && nearestDist < unit.range) {
                        if (unit.attackCooldown === 0) {
                            if (nearestEnemy.hp !== undefined) {
                                nearestEnemy.hp -= unit.damage;
                            }
                            unit.attackCooldown = 15;
                        }
                        unit.attackTarget = nearestEnemy;
                    } else if (nearestEnemy && nearestDist < 300) {
                        unit.targetX = nearestEnemy.x;
                        unit.targetY = nearestEnemy.y;
                        unit.attackTarget = nearestEnemy;
                    } else {
                        unit.attackTarget = null;
                        const dist = this.distance(unit, this.playerBase);
                        if (dist > 50) {
                            unit.targetX = this.playerBase.x;
                            unit.targetY = this.playerBase.y;
                        }
                    }
                }
            }
            
            enemyAI(enemyIndex) {
                const enemyOwner = `enemy${enemyIndex}`;
                const enemyBase = this.enemyBases[enemyIndex];
                const enemyScvCount = this.units.filter(u => u.owner === enemyOwner && u.type === 'scv').length;
                const enemyMarineCount = this.units.filter(u => u.owner === enemyOwner && u.type === 'marine').length;
                const playerMarineCount = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;

                // 1ë‹¨ê³„ì—ì„œëŠ” ë§ˆë¦° ìƒì‚°í•˜ì§€ ì•ŠìŒ (ë°©ì–´ì  í”Œë ˆì´)
                if (this.level === 1) {
                    // SCVë§Œ ìƒì‚°í•˜ê³  ë§ˆë¦°ì€ ìƒì‚°í•˜ì§€ ì•ŠìŒ
                    if (enemyScvCount < 3 && this.enemyMinerals[enemyIndex] >= 50) {
                        this.enemyMinerals[enemyIndex] -= 50;
                        this.createUnit('scv', enemyBase.x + Math.random() * 40 - 20,
                                              enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                        this.updateUI();
                        return;
                    }
                    // ì„œí”Œë¼ì´ í™•ì¥
                    if (this.enemySupply[enemyIndex] >= this.enemySupplyMax[enemyIndex] - 1 && this.enemyMinerals[enemyIndex] >= 100) {
                        this.buildSupply(enemyOwner);
                        return;
                    }
                    return; // 1ë‹¨ê³„ì—ì„œëŠ” ë” ì´ìƒì˜ AI ë¡œì§ ì‹¤í–‰í•˜ì§€ ì•ŠìŒ
                }

                const baseTargetMarines = Math.floor(playerMarineCount * 0.6) + this.level + 2;
                const targetMarineCount = Math.max(baseTargetMarines, 5);
                
                if (this.enemySupply[enemyIndex] >= this.enemySupplyMax[enemyIndex] - 2) {
                    if (this.enemyMinerals[enemyIndex] >= 100) {
                        this.buildSupply(enemyOwner);
                    }
                    return;
                }
                
                if (this.enemyMinerals[enemyIndex] >= 200) {
                    if (enemyMarineCount < targetMarineCount * 1.5) {
                        this.enemyMinerals[enemyIndex] -= 50;
                        this.createUnit('marine', enemyBase.x + Math.random() * 40 - 20, 
                                                 enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                        this.updateUI();
                        return;
                    }
                    if (enemyScvCount < 8) {
                        this.enemyMinerals[enemyIndex] -= 50;
                        this.createUnit('scv', enemyBase.x + Math.random() * 40 - 20, 
                                              enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                        this.updateUI();
                        return;
                    }
                }
                
                if (enemyScvCount < 4 && this.enemyMinerals[enemyIndex] >= 50) {
                    this.enemyMinerals[enemyIndex] -= 50;
                    this.createUnit('scv', enemyBase.x + Math.random() * 40 - 20, 
                                          enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                    this.updateUI();
                    return;
                }
                
                if (enemyMarineCount < targetMarineCount && this.enemyMinerals[enemyIndex] >= 50) {
                    this.enemyMinerals[enemyIndex] -= 50;
                    this.createUnit('marine', enemyBase.x + Math.random() * 40 - 20, 
                                             enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                    this.updateUI();
                    return;
                }
                
                if (enemyScvCount < 7 && this.enemyMinerals[enemyIndex] >= 50) {
                    this.enemyMinerals[enemyIndex] -= 50;
                    this.createUnit('scv', enemyBase.x + Math.random() * 40 - 20, 
                                          enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                    this.updateUI();
                    return;
                }
                
                if (this.enemyMinerals[enemyIndex] >= 100 && enemyMarineCount < targetMarineCount + 5) {
                    this.enemyMinerals[enemyIndex] -= 50;
                    this.createUnit('marine', enemyBase.x + Math.random() * 40 - 20, 
                                             enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                    this.updateUI();
                }
            }
            
            enemyQuickProduction(enemyIndex) {
                // 1ë‹¨ê³„ì—ì„œëŠ” ë¹ ë¥¸ ë§ˆë¦° ìƒì‚°í•˜ì§€ ì•ŠìŒ
                if (this.level === 1) {
                    return;
                }

                const enemyOwner = `enemy${enemyIndex}`;
                const enemyBase = this.enemyBases[enemyIndex];
                const enemyMarineCount = this.units.filter(u => u.owner === enemyOwner && u.type === 'marine').length;
                const playerMarineCount = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;

                if (this.enemySupply[enemyIndex] >= this.enemySupplyMax[enemyIndex]) {
                    return;
                }

                if (enemyMarineCount < playerMarineCount && this.enemyMinerals[enemyIndex] >= 50) {
                    this.enemyMinerals[enemyIndex] -= 50;
                    this.createUnit('marine', enemyBase.x + Math.random() * 40 - 20,
                                             enemyBase.y + Math.random() * 40 - 20, enemyOwner);
                    this.updateUI();
                }
            }
            
            findNearest(unit, targets) {
                let nearest = null;
                let minDist = Infinity;
                targets.forEach(target => {
                    const dist = this.distance(unit, target);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = target;
                    }
                });
                return nearest;
            }
            
            distance(a, b) {
                const dx = a.x - b.x;
                const dy = a.y - b.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            checkGameOver() {
                if (this.playerBase.hp <= 0) {
                    this.endGame(false);
                } else {
                    // ëª¨ë“  ì êµ° ê¸°ì§€ê°€ íŒŒê´´ë˜ì—ˆëŠ”ì§€ í™•ì¸
                    const allEnemiesDefeated = this.enemyBases.every(base => base.hp <= 0);
                    if (allEnemiesDefeated) {
                        this.endGame(true);
                    }
                }
            }
            
            endGame(victory) {
                this.gameOver = true;
                const gameOverDiv = document.getElementById('gameOver');
                const title = document.getElementById('gameOverTitle');
                const stats = document.getElementById('gameOverStats');
                
                if (victory) {
                    title.textContent = 'ìŠ¹ë¦¬!';
                    title.className = 'victory';
                    stats.textContent = `ë ˆë²¨ ${this.level} í´ë¦¬ì–´! ì  ì²˜ì¹˜: ${this.enemyKills}`;
                    setTimeout(() => {
                        this.level++;
                        this.restart();
                    }, 3000);
                } else {
                    title.textContent = 'íŒ¨ë°°...';
                    title.className = 'defeat';
                    stats.textContent = `ë ˆë²¨ ${this.level}ì—ì„œ íŒ¨ë°°. ì  ì²˜ì¹˜: ${this.enemyKills}`;
                    gameOverDiv.style.display = 'block';
                }
            }
            
            restart() {
                this.units = [];
                this.selectedUnits = [];
                this.supplies = []; // íƒ€ì›Œ ì´ˆê¸°í™”
                this.playerMinerals = 50;
                this.enemyKills = 0;
                this.playerSupply = 0;
                this.playerSupplyMax = 10;
                this.playerBase.hp = this.playerBase.maxHp;
                this.gameOver = false;
                document.getElementById('gameOver').style.display = 'none';

                // ì¿¨íƒ€ì„ ì´ˆê¸°í™”
                this.supplyCooldown = 0;
                this.scvCooldown = 0;
                this.marineCooldown = 0;

                this.init();
                this.updateLevelButtons();
                this.updateUI();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // í”Œë ˆì´ì–´ ê¸°ì§€ ì˜ì—­
                this.ctx.fillStyle = '#2d4a2d';
                this.ctx.beginPath();
                this.ctx.ellipse(150, 150, 120, 100, 0, 0, Math.PI * 2);
                this.ctx.fill();
                
                // ê° ì êµ° ê¸°ì§€ ì˜ì—­
                this.enemyBases.forEach((base, index) => {
                    this.ctx.fillStyle = '#4a2d2d';
                    this.ctx.beginPath();
                    this.ctx.ellipse(base.x, base.y, 120, 100, 0, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // í”Œë ˆì´ì–´ ë¯¸ë„¤ë„ íŒ¨ì¹˜ (ì´ëª¨í‹°ì½˜ìœ¼ë¡œ í‘œì‹œ)
                this.playerMinerals_patches.forEach(mineral => {
                    this.ctx.font = '30px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('ğŸ’', mineral.x, mineral.y);
                });
                
                // ê° ì êµ° ë¯¸ë„¤ë„ íŒ¨ì¹˜ (ì´ëª¨í‹°ì½˜ìœ¼ë¡œ í‘œì‹œ)
                this.enemyMinerals_patches.forEach(patches => {
                    patches.forEach(mineral => {
                        this.ctx.font = '30px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('ğŸ’', mineral.x, mineral.y);
                    });
                });
                
                this.drawBase(this.playerBase, '#00ff00');
                this.enemyBases.forEach(base => {
                    this.drawBase(base, '#ff4444');
                });
                
                // íƒ€ì›Œ ë Œë”ë§ (íŒŒë€ìƒ‰, SCV í¬ê¸°)
                this.supplies.forEach(tower => {
                    this.ctx.fillStyle = '#4488ff'; // íŒŒë€ìƒ‰
                    this.ctx.fillRect(tower.x - tower.size / 2, tower.y - tower.size / 2, tower.size, tower.size);
                    this.ctx.strokeStyle = '#6699ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(tower.x - tower.size / 2, tower.y - tower.size / 2, tower.size, tower.size);
                    
                    // HP ë°” í‘œì‹œ
                    const hpPercent = tower.hp / tower.maxHp;
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(tower.x - tower.size / 2, tower.y - tower.size / 2 - 8, tower.size, 4);
                    this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                    this.ctx.fillRect(tower.x - tower.size / 2, tower.y - tower.size / 2 - 8, tower.size * hpPercent, 4);
                    
                    // ê³µê²© ì• ë‹ˆë©”ì´ì…˜ (ì•„êµ° íƒ€ì›ŒëŠ” ë¹¨ê°„ìƒ‰)
                    if (tower.attackTarget && tower.attackCooldown > 10) {
                        this.ctx.strokeStyle = '#ff0000'; // ë¹¨ê°„ìƒ‰
                        this.ctx.lineWidth = 2;
                        this.ctx.beginPath();
                        this.ctx.moveTo(tower.x, tower.y);
                        this.ctx.lineTo(tower.attackTarget.x, tower.attackTarget.y);
                        this.ctx.stroke();
                        
                        this.ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // ë¹¨ê°„ìƒ‰ ë°˜íˆ¬ëª…
                        this.ctx.beginPath();
                        this.ctx.arc(tower.attackTarget.x, tower.attackTarget.y, 10, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
                
                this.units.forEach(unit => {
                    this.drawUnit(unit);
                });
                
                if (this.isDragging && this.dragStart && this.dragEnd) {
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(
                        this.dragStart.x,
                        this.dragStart.y,
                        this.dragEnd.x - this.dragStart.x,
                        this.dragEnd.y - this.dragStart.y
                    );
                    this.ctx.setLineDash([]);
                }
            }
            
            drawBase(base, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(base.x - 30, base.y - 25, 60, 50);
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(base.x - 30, base.y - 25, 60, 50);
                
                const hpPercent = base.hp / base.maxHp;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(base.x - 30, base.y - 35, 60, 6);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                this.ctx.fillRect(base.x - 30, base.y - 35, 60 * hpPercent, 6);
                
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${Math.floor(base.hp)}/${base.maxHp}`, base.x, base.y - 38);
            }
            
            drawUnit(unit) {
                const color = unit.owner === 'player' ? '#00ff00' : '#ff4444';
                
                if (unit.type === 'scv') {
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(unit.x - 8, unit.y - 8, 16, 16);
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(unit.x - 8, unit.y - 8, 16, 16);
                } else {
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(unit.x, unit.y, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 1;
                    this.ctx.stroke();
                }
                
                if (unit.selected) {
                    this.ctx.strokeStyle = '#ffff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(unit.x, unit.y, 12, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                const hpPercent = unit.hp / unit.maxHp;
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(unit.x - 10, unit.y - 15, 20, 3);
                this.ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
                this.ctx.fillRect(unit.x - 10, unit.y - 15, 20 * hpPercent, 3);
                
                if (unit.attackTarget && unit.attackCooldown > 10) {
                    // ì•„êµ°ì€ ë¹¨ê°„ìƒ‰, ì êµ°ì€ ë…¸ë€ìƒ‰
                    const attackColor = unit.owner === 'player' ? '#ff0000' : '#ffff00';
                    const attackFillColor = unit.owner === 'player' ? 'rgba(255, 0, 0, 0.5)' : 'rgba(255, 255, 0, 0.5)';
                    
                    this.ctx.strokeStyle = attackColor;
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(unit.x, unit.y);
                    this.ctx.lineTo(unit.attackTarget.x, unit.attackTarget.y);
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = attackFillColor;
                    this.ctx.beginPath();
                    this.ctx.arc(unit.attackTarget.x, unit.attackTarget.y, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
            
            updateUI() {
                const playerScvs = this.units.filter(u => u.owner === 'player' && u.type === 'scv').length;
                const playerMarines = this.units.filter(u => u.owner === 'player' && u.type === 'marine').length;
                
                // ëª¨ë“  ì êµ° í†µê³„ í•©ì‚°
                let totalEnemyScvs = 0;
                let totalEnemyMarines = 0;
                let totalEnemyMinerals = 0;
                let totalEnemySupply = 0;
                let totalEnemySupplyMax = 0;
                
                for (let i = 0; i < this.enemyCount; i++) {
                    const enemyOwner = `enemy${i}`;
                    totalEnemyScvs += this.units.filter(u => u.owner === enemyOwner && u.type === 'scv').length;
                    totalEnemyMarines += this.units.filter(u => u.owner === enemyOwner && u.type === 'marine').length;
                    totalEnemyMinerals += this.enemyMinerals[i] || 0;
                    totalEnemySupply += this.enemySupply[i] || 0;
                    totalEnemySupplyMax += this.enemySupplyMax[i] || 0;
                }
                
                document.getElementById('playerMinerals').textContent = Math.floor(this.playerMinerals);
                document.getElementById('enemyMinerals').textContent = Math.floor(totalEnemyMinerals);
                document.getElementById('playerScvs').textContent = playerScvs;
                document.getElementById('playerMarines').textContent = playerMarines;
                document.getElementById('enemyScvs').textContent = totalEnemyScvs;
                document.getElementById('enemyMarines').textContent = totalEnemyMarines;
                document.getElementById('miningRate').textContent = `+${playerScvs * 8}/s`;
                document.getElementById('enemyKills').textContent = this.enemyKills;
                document.getElementById('level').textContent = `Lv.${this.level}`;
                
                const playerSupplyEl = document.getElementById('playerSupply');
                playerSupplyEl.textContent = `${this.playerSupply}/${this.playerSupplyMax}`;
                playerSupplyEl.className = `stat-value ${this.playerSupply >= this.playerSupplyMax ? 'warning' : 'player'}`;
                
                document.getElementById('enemySupply').textContent = `${totalEnemySupply}/${totalEnemySupplyMax}`;

                // ì¿¨íƒ€ì„ ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
                this.updateCooldownOverlays();
            }

            updateCooldownOverlays() {
                // ì„œí”Œë¼ì´ ì¿¨íƒ€ì„
                const supplyOverlay = document.getElementById('supplyCooldownOverlay');
                if (this.supplyCooldown > 0) {
                    supplyOverlay.classList.add('active');
                    supplyOverlay.textContent = Math.ceil(this.supplyCooldown / 60) + 's';
                } else {
                    supplyOverlay.classList.remove('active');
                }

                // SCV ì¿¨íƒ€ì„
                const scvOverlay = document.getElementById('scvCooldownOverlay');
                if (this.scvCooldown > 0) {
                    scvOverlay.classList.add('active');
                    scvOverlay.textContent = Math.ceil(this.scvCooldown / 60) + 's';
                } else {
                    scvOverlay.classList.remove('active');
                }

                // ë§ˆë¦° ì¿¨íƒ€ì„
                const marineOverlay = document.getElementById('marineCooldownOverlay');
                if (this.marineCooldown > 0) {
                    marineOverlay.classList.add('active');
                    marineOverlay.textContent = Math.ceil(this.marineCooldown / 60) + 's';
                } else {
                    marineOverlay.classList.remove('active');
                }
            }
        }

        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>