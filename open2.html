<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>íƒ±í¬ ë””íœìŠ¤ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #8B4513;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // ê²Œì„ ìƒíƒœ
        const gameState = {
            player: {
                x: canvas.width / 2,
                y: canvas.height / 2,
                speed: 5,
                power: 1,
                size: 40,
                angle: 0,
                turretAngle: 0,
                health: 100
            },
            enemies: [],
            projectiles: [],
            powerups: [],
            obstacles: [],
            trees: [],
            flowers: [],
            camera: {
                x: 0,
                y: 0
            },
            effects: [],
            stage: 1, // í˜„ì¬ ìŠ¤í…Œì´ì§€
            enemySpawnTimer: 0, // ì  ìƒì„± íƒ€ì´ë¨¸
            enemySpawnDelay: 5000 // 5ì´ˆë§ˆë‹¤ ì  ìƒì„±
        };

        // ì  ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
        function createEnemy() {
            // í˜„ì¬ ìŠ¤í…Œì´ì§€ì— ë”°ë¼ ì  ìƒì„±
            if(gameState.enemies.length < gameState.stage) {
                const enemy = {
                    x: Math.random() * 2000 - 1000,
                    y: Math.random() * 2000 - 1000,
                    type: 'tank',
                    health: 100,
                    size: 40,
                    angle: 0,
                    turretAngle: 0,
                    lastShot: 0,
                    shotCooldown: 2000
                };
                gameState.enemies.push(enemy);
            }
        }

        // ì¥ì• ë¬¼ ìƒì„±
        function createObstacles() {
            for(let i = 0; i < 50; i++) {
                gameState.obstacles.push({
                    x: Math.random() * 2000 - 1000,
                    y: Math.random() * 2000 - 1000,
                    type: Math.random() < 0.5 ? 'ğŸŒ²' : 'ğŸ”ï¸'
                });
            }
        }

        // ë‚˜ë¬´ì™€ ê½ƒ ìƒì„±
        function createEnvironment() {
            for(let i = 0; i < 100; i++) {
                gameState.trees.push({
                    x: Math.random() * 2000 - 1000,
                    y: Math.random() * 2000 - 1000
                });
                gameState.flowers.push({
                    x: Math.random() * 2000 - 1000,
                    y: Math.random() * 2000 - 1000
                });
            }
        }

        // íŒŒì›Œì—… ìƒì„±
        function createPowerup() {
            gameState.powerups.push({
                x: Math.random() * 2000 - 1000,
                y: Math.random() * 2000 - 1000,
                type: 'ğŸ'
            });
        }

        // ë°œì‚¬ì²´ ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
        function createProjectile(angle) {
            const turretLength = gameState.player.size/2 + 20; // í¬ì‹  ê¸¸ì´ ì¦ê°€
            const startX = gameState.player.x + Math.cos(angle) * turretLength;
            const startY = gameState.player.y + Math.sin(angle) * turretLength;
            
            gameState.projectiles.push({
                x: startX,
                y: startY,
                angle: angle,
                speed: 10,
                power: gameState.player.power,
                isEnemy: false
            });

            // ë°œì‚¬ íš¨ê³¼
            createEffect(startX, startY, 'ğŸ’¨');
        }

        // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜ ìˆ˜ì •
        function checkCollision(obj1, obj2, size2) {
            const obj2Size = size2 || obj2.size;
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (obj1.size/2 + obj2Size/2);
        }

        // í­ë°œ íš¨ê³¼ ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
        function createExplosion(x, y, isEnemy = false) {
            // ì¤‘ì•™ í­ë°œ
            createEffect(x, y, 'ğŸ’¥');
            
            // ì£¼ë³€ í­ë°œ íš¨ê³¼
            for(let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const distance = 20;
                const effectX = x + Math.cos(angle) * distance;
                const effectY = y + Math.sin(angle) * distance;
                createEffect(effectX, effectY, 'ğŸ’¥');
            }
            
            // ì—ë„ˆì§€ ì†ì‹¤ íš¨ê³¼
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const distance = 15;
                const effectX = x + Math.cos(angle) * distance;
                const effectY = y + Math.sin(angle) * distance;
                createEffect(effectX, effectY, 'âš¡');
            }

            // ì  íƒ±í¬ í­ë°œ ì‹œ ì¶”ê°€ íš¨ê³¼
            if(isEnemy) {
                for(let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const distance = 25;
                    const effectX = x + Math.cos(angle) * distance;
                    const effectY = y + Math.sin(angle) * distance;
                    createEffect(effectX, effectY, 'ğŸ”¥');
                }
            }
        }

        // íš¨ê³¼ ìƒì„± í•¨ìˆ˜ ìˆ˜ì •
        function createEffect(x, y, type) {
            const effect = {
                x: x,
                y: y,
                type: type,
                life: type === 'ğŸ’¥' ? 20 : type === 'ğŸ”¥' ? 30 : 30,
                size: type === 'ğŸ’¥' ? 30 : type === 'ğŸ”¥' ? 25 : 20,
                angle: Math.random() * Math.PI * 2,
                speed: type === 'ğŸ’¨' ? 2 : 0,
                scale: 1
            };
            gameState.effects.push(effect);
        }

        // íš¨ê³¼ ì—…ë°ì´íŠ¸ ìˆ˜ì •
        function updateEffects() {
            gameState.effects.forEach((effect, index) => {
                effect.life--;
                if(effect.type === 'ğŸ’¨') {
                    effect.x += Math.cos(effect.angle) * effect.speed;
                    effect.y += Math.sin(effect.angle) * effect.speed;
                }
                if(effect.type === 'ğŸ’¥' || effect.type === 'ğŸ”¥') {
                    effect.scale = 1 + (1 - effect.life/(effect.type === 'ğŸ’¥' ? 20 : 30));
                }
                if(effect.life <= 0) {
                    gameState.effects.splice(index, 1);
                }
            });
        }

        // í‚¤ë³´ë“œ ì»¨íŠ¸ë¡¤
        const keys = {};
        
        // í‚¤ ì…ë ¥ ì²˜ë¦¬
        document.addEventListener('keydown', function(e) {
            keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', function(e) {
            keys[e.key.toLowerCase()] = false;
        });

        // ê²Œì„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ìˆ˜ì •
        function update() {
            // ì¹´ë©”ë¼ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            gameState.camera.x = gameState.player.x - canvas.width/2;
            gameState.camera.y = gameState.player.y - canvas.height/2;

            // ì  ìƒì„± íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            gameState.enemySpawnTimer += 16; // ì•½ 60fps ê¸°ì¤€
            if(gameState.enemySpawnTimer >= gameState.enemySpawnDelay) {
                createEnemy();
                gameState.enemySpawnTimer = 0;
            }

            // ìŠ¤í…Œì´ì§€ ì—…ë°ì´íŠ¸
            if(gameState.enemies.length === 0) {
                gameState.stage++;
                // ìŠ¤í…Œì´ì§€ í´ë¦¬ì–´ íš¨ê³¼
                createEffect(gameState.player.x, gameState.player.y, 'ğŸ‰');
            }

            // í¬ì‹  íšŒì „ ì²˜ë¦¬
            if(keys['a']) {
                gameState.player.turretAngle -= 0.1;
            }
            if(keys['d']) {
                gameState.player.turretAngle += 0.1;
            }

            // íƒ±í¬ ì´ë™ ì²˜ë¦¬ ë° ì¶©ëŒ ì²´í¬
            let newX = gameState.player.x;
            let newY = gameState.player.y;

            if(keys['arrowup']) {
                newY -= gameState.player.speed;
            }
            if(keys['arrowdown']) {
                newY += gameState.player.speed;
            }
            if(keys['arrowleft']) {
                newX -= gameState.player.speed;
            }
            if(keys['arrowright']) {
                newX += gameState.player.speed;
            }

            // ë‚˜ë¬´ì™€ ì¶©ëŒ ì²´í¬
            let canMove = true;
            gameState.trees.forEach((tree, index) => {
                if(checkCollision({x: newX, y: newY, size: gameState.player.size}, tree, 30)) {
                    canMove = false;
                    createEffect(tree.x, tree.y, 'ğŸŒ²');
                    gameState.trees.splice(index, 1);
                }
            });

            // ê½ƒê³¼ ì¶©ëŒ ì²´í¬
            gameState.flowers.forEach((flower, index) => {
                if(checkCollision({x: newX, y: newY, size: gameState.player.size}, flower, 20)) {
                    createEffect(flower.x, flower.y, 'ğŸŒ¸');
                    gameState.flowers.splice(index, 1);
                }
            });

            if(canMove) {
                gameState.player.x = newX;
                gameState.player.y = newY;
            }

            // íš¨ê³¼ ì—…ë°ì´íŠ¸
            updateEffects();

            // ì  ì—…ë°ì´íŠ¸
            gameState.enemies.forEach((enemy, index) => {
                // í”Œë ˆì´ì–´ ë°©í–¥ìœ¼ë¡œ íšŒì „
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                enemy.angle = Math.atan2(dy, dx);
                enemy.turretAngle = enemy.angle;

                // ì  ê³µê²©
                const now = Date.now();
                if(now - enemy.lastShot > enemy.shotCooldown) {
                    const turretLength = enemy.size/2 + 20; // í¬ì‹  ê¸¸ì´ ì¦ê°€
                    const startX = enemy.x + Math.cos(enemy.turretAngle) * turretLength;
                    const startY = enemy.y + Math.sin(enemy.turretAngle) * turretLength;
                    
                    gameState.projectiles.push({
                        x: startX,
                        y: startY,
                        angle: enemy.turretAngle,
                        speed: 8,
                        power: 0.5,
                        isEnemy: true
                    });
                    enemy.lastShot = now;
                    // ë°œì‚¬ íš¨ê³¼
                    createEffect(startX, startY, 'ğŸ’¨');
                }
            });

            // ë°œì‚¬ì²´ ì—…ë°ì´íŠ¸
            gameState.projectiles.forEach((proj, index) => {
                const oldX = proj.x;
                const oldY = proj.y;
                proj.x += Math.cos(proj.angle) * proj.speed;
                proj.y += Math.sin(proj.angle) * proj.speed;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ë°œì‚¬ì²´ ì œê±°
                if(proj.x < -1000 || proj.x > 3000 || proj.y < -1000 || proj.y > 3000) {
                    gameState.projectiles.splice(index, 1);
                    return;
                }

                if(proj.isEnemy) {
                    // ì ì˜ í¬íƒ„ì´ í”Œë ˆì´ì–´ì™€ ì¶©ëŒ
                    if(checkCollision(proj, gameState.player)) {
                        gameState.player.health -= 10;
                        createExplosion(proj.x, proj.y);
                        gameState.projectiles.splice(index, 1);
                        
                        if(gameState.player.health <= 0) {
                            alert('ê²Œì„ ì˜¤ë²„!');
                            location.reload();
                        }
                    }
                } else {
                    // í”Œë ˆì´ì–´ì˜ í¬íƒ„ì´ ì ê³¼ ì¶©ëŒ
                    gameState.enemies.forEach((enemy, enemyIndex) => {
                        if(checkCollision(proj, enemy)) {
                            enemy.health -= 10;
                            createExplosion(proj.x, proj.y, true);
                            gameState.projectiles.splice(index, 1);
                            
                            if(enemy.health <= 0) {
                                gameState.enemies.splice(enemyIndex, 1);
                                // ì  íƒ±í¬ íŒŒê´´ ì‹œ ì¶”ê°€ í­ë°œ íš¨ê³¼
                                for(let i = 0; i < 3; i++) {
                                    setTimeout(() => {
                                        createExplosion(
                                            enemy.x + (Math.random() - 0.5) * 30,
                                            enemy.y + (Math.random() - 0.5) * 30,
                                            true
                                        );
                                    }, i * 100);
                                }
                            }
                        }
                    });
                }
            });

            // íŒŒì›Œì—… ì¶©ëŒ ì²´í¬
            gameState.powerups.forEach((powerup, index) => {
                if(checkCollision(gameState.player, powerup)) {
                    gameState.player.power += 0.5;
                    gameState.player.speed += 1;
                    gameState.powerups.splice(index, 1);
                }
            });
        }

        // ê²Œì„ ë Œë”ë§ í•¨ìˆ˜ ìˆ˜ì •
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë°°ê²½
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // íš¨ê³¼ ë Œë”ë§
            gameState.effects.forEach(effect => {
                ctx.save();
                ctx.font = `${effect.size * effect.scale}px Arial`;
                ctx.globalAlpha = effect.life / (effect.type === 'ğŸ’¥' ? 20 : 30);
                ctx.fillText(effect.type, effect.x - gameState.camera.x, effect.y - gameState.camera.y);
                ctx.restore();
            });

            // í™˜ê²½ ìš”ì†Œ ë Œë”ë§
            gameState.trees.forEach(tree => {
                ctx.font = '30px Arial';
                ctx.fillText('ğŸŒ²', tree.x - gameState.camera.x, tree.y - gameState.camera.y);
            });

            gameState.flowers.forEach(flower => {
                ctx.font = '20px Arial';
                ctx.fillText('ğŸŒ¸', flower.x - gameState.camera.x, flower.y - gameState.camera.y);
            });

            // ì¥ì• ë¬¼ ë Œë”ë§
            gameState.obstacles.forEach(obstacle => {
                ctx.font = '30px Arial';
                ctx.fillText(obstacle.type, obstacle.x - gameState.camera.x, obstacle.y - gameState.camera.y);
            });

            // íŒŒì›Œì—… ë Œë”ë§
            gameState.powerups.forEach(powerup => {
                ctx.font = '30px Arial';
                ctx.fillText(powerup.type, powerup.x - gameState.camera.x, powerup.y - gameState.camera.y);
            });

            // ì  ë Œë”ë§
            gameState.enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x - gameState.camera.x, enemy.y - gameState.camera.y);
                
                // ì  íƒ±í¬ ë³¸ì²´
                ctx.rotate(enemy.angle);
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(-enemy.size/2, -enemy.size/2, enemy.size, enemy.size);
                
                // ì  íƒ±í¬ í¬ì‹ 
                ctx.rotate(enemy.turretAngle - enemy.angle);
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-5, -enemy.size/2 - 10, 10, enemy.size/2 + 10);
                
                ctx.restore();

                // ì  ì—ë„ˆì§€ ë°”
                const energyBarWidth = enemy.size;
                const energyBarHeight = 5;
                const energyBarX = enemy.x - gameState.camera.x - energyBarWidth/2;
                const energyBarY = enemy.y - gameState.camera.y - enemy.size/2 - 10;

                // ì—ë„ˆì§€ ë°” ë°°ê²½
                ctx.fillStyle = '#7f8c8d';
                ctx.fillRect(energyBarX, energyBarY, energyBarWidth, energyBarHeight);

                // ì—ë„ˆì§€ ë°”
                ctx.fillStyle = enemy.health > 50 ? '#2ecc71' : enemy.health > 25 ? '#f1c40f' : '#e74c3c';
                ctx.fillRect(energyBarX, energyBarY, energyBarWidth * (enemy.health/100), energyBarHeight);
            });

            // ë°œì‚¬ì²´ ë Œë”ë§
            gameState.projectiles.forEach(proj => {
                ctx.fillStyle = proj.isEnemy ? '#e74c3c' : 'yellow';
                ctx.beginPath();
                ctx.arc(proj.x - gameState.camera.x, proj.y - gameState.camera.y, 5, 0, Math.PI * 2);
                ctx.fill();
            });

            // í”Œë ˆì´ì–´ íƒ±í¬ ë Œë”ë§
            ctx.save();
            ctx.translate(gameState.player.x - gameState.camera.x, gameState.player.y - gameState.camera.y);
            
            // íƒ±í¬ ë³¸ì²´
            ctx.rotate(gameState.player.angle);
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(-gameState.player.size/2, -gameState.player.size/2, gameState.player.size, gameState.player.size);
            
            // íƒ±í¬ í¬ì‹ 
            ctx.rotate(gameState.player.turretAngle - gameState.player.angle);
            ctx.fillStyle = '#34495e';
            ctx.fillRect(-5, -gameState.player.size/2 - 20, 10, gameState.player.size/2 + 20); // í¬ì‹  ê¸¸ì´ ì¦ê°€
            
            ctx.restore();

            // í”Œë ˆì´ì–´ ì—ë„ˆì§€ ë°”
            const energyBarWidth = gameState.player.size;
            const energyBarHeight = 5;
            const energyBarX = gameState.player.x - gameState.camera.x - energyBarWidth/2;
            const energyBarY = gameState.player.y - gameState.camera.y - gameState.player.size/2 - 10;

            // ì—ë„ˆì§€ ë°” ë°°ê²½
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(energyBarX, energyBarY, energyBarWidth, energyBarHeight);

            // ì—ë„ˆì§€ ë°”
            ctx.fillStyle = gameState.player.health > 50 ? '#2ecc71' : gameState.player.health > 25 ? '#f1c40f' : '#e74c3c';
            ctx.fillRect(energyBarX, energyBarY, energyBarWidth * (gameState.player.health/100), energyBarHeight);

            // ìŠ¤í…Œì´ì§€ ì •ë³´ í‘œì‹œ
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText(`ìŠ¤í…Œì´ì§€: ${gameState.stage}`, 20, 30);
            ctx.fillText(`ë‚¨ì€ ì : ${gameState.enemies.length}`, 20, 60);
        }

        // ìŠ¤í˜ì´ìŠ¤ë°”ë¡œ ë°œì‚¬
        document.addEventListener('keydown', function(e) {
            if(e.code === 'Space') {
                createProjectile(gameState.player.turretAngle);
            }
        });

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ì´ˆê¸°í™”
        createObstacles();
        createEnvironment();
        setInterval(createPowerup, 5000);

        // ê²Œì„ ì‹œì‘
        gameLoop();
    </script>
</body>
</html>
