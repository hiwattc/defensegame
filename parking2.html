<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4ì¶• ë°”í€´ ìë™ì°¨ ìš´ì „ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #2a4a2a;
            border: 2px solid #333;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
        }
        
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            text-align: right;
        }
        
        .parking-spot {
            color: #ffff00;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    
    <div id="controls">
        <strong>ğŸš— ìš´ì „ ì¡°ì‘ë²•</strong><br>
        â†“/â†‘: ì „ì§„/í›„ì§„<br>
        â†’/â†: ì¢Œ/ìš° ì¡°í–¥<br>
        Space: ë¸Œë ˆì´í¬<br>
        R: ë¦¬ì…‹
    </div>
    
    <div id="info">
        <div>ì†ë„: <span id="speed">0</span> km/h</div>
        <div>ê¸°ì–´: <span id="gear">P</span></div>
        <div>ìˆœìœ„: <span id="rank">1</span> / 6</div>
        <div>ë©: <span id="lap">0</span></div>
        <div class="parking-spot">ğŸ ì²´í¬í¬ì¸íŠ¸ë¥¼ í†µê³¼í•˜ì—¬ ë ˆì´ì‹±í•˜ì„¸ìš”!</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        const keys = {};
        let gameTime = 0;
        
        // === íŠ¸ë™ ê´€ë ¨ ì „ì—­ ë³€ìˆ˜ ì¶”ê°€ ===
        const TRACK_CENTER = { x: 2000, y: 1500 };
        const TRACK_A = 1600; // íƒ€ì› ê°€ë¡œ ë°˜ì§€ë¦„
        const TRACK_B = 1000; // íƒ€ì› ì„¸ë¡œ ë°˜ì§€ë¦„
        const TRACK_WIDTH = 180; // íŠ¸ë™ í­
        const WORLD_WIDTH = 4000;
        const WORLD_HEIGHT = 3000;

        // ì¹´ë©”ë¼ ìœ„ì¹˜
        let cameraX = 0;
        let cameraY = 0;

        // íŠ¸ë™ ìœ„ì— ìˆëŠ”ì§€ íŒì • í•¨ìˆ˜
        function isOnTrack(x, y) {
            const dx = x - TRACK_CENTER.x;
            const dy = y - TRACK_CENTER.y;
            const dist = Math.sqrt((dx * dx) / (TRACK_A * TRACK_A) + (dy * dy) / (TRACK_B * TRACK_B));
            return dist > 1 - TRACK_WIDTH / (2 * TRACK_A) && dist < 1 + TRACK_WIDTH / (2 * TRACK_A);
        }
        
        // ìë™ì°¨ í´ë˜ìŠ¤
        class Car {
            constructor(x, y, color = '#ff4444', isPlayer = false) {
                this.x = x;
                this.y = y;
                this.angle = 0;
                this.speed = 0;
                this.maxSpeed = isPlayer ? 8 : 6 + Math.random() * 3;
                this.acceleration = 0.2;
                this.deceleration = 0.1;
                this.turnSpeed = 0;
                this.maxTurnSpeed = 0.04;
                this.friction = 0.95;
                this.width = 60;
                this.height = 30;
                this.color = color;
                this.isPlayer = isPlayer;
                this.lap = 0;
                this.checkpointsPassed = 0;
                this.totalDistance = 0;
                
                // AI ê´€ë ¨ ì†ì„±
                this.aiTarget = { x: 400, y: 400 };
                this.aiTimer = 0;
                this.aiTurnDirection = Math.random() > 0.5 ? 1 : -1;
                
                // 4ì¶• ë°”í€´ ìœ„ì¹˜ (ìƒëŒ€ì )
                this.wheels = [
                    {x: -25, y: -12, angle: 0}, // ì• ì™¼ìª½
                    {x: -25, y: 12, angle: 0},  // ì• ì˜¤ë¥¸ìª½
                    {x: 25, y: -12, angle: 0},  // ë’¤ ì™¼ìª½
                    {x: 25, y: 12, angle: 0}    // ë’¤ ì˜¤ë¥¸ìª½
                ];
            }
            
            update(checkpoints = []) {
                let steering = 0;
                let throttle = 0;
                let brake = false;
                
                if (this.isPlayer) {
                    // í”Œë ˆì´ì–´ ì…ë ¥
                    if (keys['ArrowRight']) steering = -1;
                    if (keys['ArrowLeft']) steering = 1;
                    if (keys['ArrowDown']) throttle = 1;
                    if (keys['ArrowUp']) throttle = -1;
                    brake = keys[' '];
                } else {
                    // AI ë¡œì§
                    this.updateAI(checkpoints);
                    steering = this.aiSteering;
                    throttle = this.aiThrottle;
                }
                
                // ì†ë„ ê³„ì‚°
                if (throttle !== 0) {
                    this.speed += throttle * this.acceleration;
                } else if (!brake) {
                    this.speed *= this.friction;
                }
                
                // ë¸Œë ˆì´í¬ ì ìš©
                if (brake) {
                    this.speed *= 0.9;
                }
                
                // ìµœëŒ€ ì†ë„ ì œí•œ
                this.speed = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.speed));
                
                // ì¡°í–¥ (ì†ë„ì— ë”°ë¼ ì¡°í–¥ë ¥ ì¡°ì ˆ)
                if (Math.abs(this.speed) > 0.1) {
                    this.turnSpeed = steering * this.maxTurnSpeed * (Math.abs(this.speed) / this.maxSpeed);
                    this.angle += this.turnSpeed * (this.speed > 0 ? 1 : -1);
                }
                
                // ì•ë°”í€´ ê°ë„ (ì¡°í–¥) - ë°˜ëŒ€ë¡œ ë³€ê²½
                this.wheels[0].angle = -steering * 0.3;
                this.wheels[1].angle = -steering * 0.3;
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                this.x += Math.cos(this.angle) * this.speed;
                this.y += Math.sin(this.angle) * this.speed;
                
                // ì´ ì´ë™ ê±°ë¦¬ ê³„ì‚°
                this.totalDistance += Math.abs(this.speed);
                
                // íŠ¸ë™ ë°–ì´ë©´ ì†ë„ ê¸‰ê°
                if (!isOnTrack(this.x, this.y)) {
                    this.speed *= 0.85;
                    // íŠ¸ë™ ë°–ì´ë©´ ì‚´ì§ ì•ˆìª½ìœ¼ë¡œ ë°€ì–´ì¤Œ
                    const dx = this.x - TRACK_CENTER.x;
                    const dy = this.y - TRACK_CENTER.y;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    if (len > 0) {
                        const t = Math.atan2(dy, dx);
                        this.x = TRACK_CENTER.x + Math.cos(t) * (TRACK_A + (Math.abs(TRACK_B * Math.sin(t) / Math.cos(t)) - TRACK_A) * (dy < 0 ? -1 : 1));
                    }
                }
                
                // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ í™•ì¸
                this.checkCheckpoints(checkpoints);
            }
            
            updateAI(checkpoints) {
                this.aiTimer++;
                
                // ê°€ì¥ ê°€ê¹Œìš´ ì²´í¬í¬ì¸íŠ¸ ì°¾ê¸°
                let targetCheckpoint = null;
                let minDist = Infinity;
                
                checkpoints.forEach(checkpoint => {
                    const dist = Math.sqrt(
                        Math.pow(this.x - checkpoint.x, 2) + 
                        Math.pow(this.y - checkpoint.y, 2)
                    );
                    if (dist < minDist) {
                        minDist = dist;
                        targetCheckpoint = checkpoint;
                    }
                });
                
                if (targetCheckpoint) {
                    // ëª©í‘œ ë°©í–¥ ê³„ì‚°
                    const targetAngle = Math.atan2(
                        targetCheckpoint.y - this.y,
                        targetCheckpoint.x - this.x
                    );
                    
                    let angleDiff = targetAngle - this.angle;
                    
                    // ê°ë„ ì •ê·œí™”
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // AI ì¡°í–¥
                    this.aiSteering = Math.sign(angleDiff) * Math.min(1, Math.abs(angleDiff) * 2);
                    
                    // AI ê°€ì† (ê±°ë¦¬ì— ë”°ë¼ ì¡°ì ˆ)
                    if (minDist > 100) {
                        this.aiThrottle = 1;
                    } else if (minDist > 50) {
                        this.aiThrottle = 0.7;
                    } else {
                        this.aiThrottle = 0.4;
                    }
                } else {
                    // ëœë¤ ì›€ì§ì„
                    if (this.aiTimer % 60 === 0) {
                        this.aiTurnDirection = Math.random() > 0.5 ? 1 : -1;
                    }
                    this.aiSteering = this.aiTurnDirection * (0.3 + Math.random() * 0.4);
                    this.aiThrottle = 0.8 + Math.random() * 0.2;
                }
            }
            
            checkCheckpoints(checkpoints) {
                checkpoints.forEach((checkpoint, index) => {
                    const dist = Math.sqrt(
                        Math.pow(this.x - checkpoint.x, 2) + 
                        Math.pow(this.y - checkpoint.y, 2)
                    );
                    
                    if (dist < 50 && !checkpoint.passedBy.includes(this)) {
                        checkpoint.passedBy.push(this);
                        this.checkpointsPassed++;
                        
                        // í•œ ë°”í€´ ì™„ì£¼ ì²´í¬
                        if (this.checkpointsPassed % checkpoints.length === 0) {
                            this.lap++;
                        }
                    }
                });
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - cameraX, this.y - cameraY);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(-this.width/2 + 5, -this.height/2 + 5, this.width - 10, this.height - 10);
                ctx.fillStyle = '#ffff99';
                ctx.fillRect(-this.width/2 - 3, -8, 6, 4);
                ctx.fillRect(-this.width/2 - 3, 4, 6, 4);
                if (this.isPlayer) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('YOU', 0, -20);
                }
                this.wheels.forEach((wheel, index) => {
                    ctx.save();
                    ctx.translate(wheel.x, wheel.y);
                    ctx.rotate(wheel.angle);
                    ctx.fillStyle = '#333';
                    ctx.fillRect(-6, -3, 12, 6);
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-6, -3, 12, 6);
                    ctx.restore();
                });
                ctx.restore();
            }
            
            reset() {
                this.x = 100;
                this.y = 100;
                this.angle = 0;
                this.speed = 0;
                this.turnSpeed = 0;
            }
        }
        
        // ì²´í¬í¬ì¸íŠ¸ í´ë˜ìŠ¤
        class Checkpoint {
            constructor(x, y, index) {
                this.x = x;
                this.y = y;
                this.index = index;
                this.passedBy = [];
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x - cameraX, this.y - cameraY);
                ctx.fillStyle = '#ff6600';
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fillStyle = '#ffffff';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.index + 1, 0, 5);
                ctx.restore();
            }
        }
        
        // ìˆœìœ„ ê³„ì‚° í•¨ìˆ˜
        function calculateRankings(cars) {
            return cars.sort((a, b) => {
                // ë¨¼ì € ë© ìˆ˜ë¡œ ì •ë ¬
                if (b.lap !== a.lap) return b.lap - a.lap;
                // ë©ì´ ê°™ìœ¼ë©´ ì²´í¬í¬ì¸íŠ¸ ìˆ˜ë¡œ ì •ë ¬
                if (b.checkpointsPassed !== a.checkpointsPassed) return b.checkpointsPassed - a.checkpointsPassed;
                // ëª¨ë‘ ê°™ìœ¼ë©´ ì´ ì´ë™ê±°ë¦¬ë¡œ ì •ë ¬
                return b.totalDistance - a.totalDistance;
            });
        }
        
        // ë„ë¡œ ê·¸ë¦¬ê¸° í•¨ìˆ˜
        function drawRoad() {
            // ì¹´ë©”ë¼ ê¸°ì¤€ìœ¼ë¡œ ì›”ë“œ ì¢Œí‘œë¥¼ í™”ë©´ì— ê·¸ë¦¼
            ctx.save();
            ctx.translate(-cameraX, -cameraY);
            // íŠ¸ë™ ë°”ê¹¥ ì”ë””
            ctx.fillStyle = '#2a4a2a';
            ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            // íŠ¸ë™ ë³¸ì²´
            ctx.save();
            ctx.beginPath();
            ctx.ellipse(TRACK_CENTER.x, TRACK_CENTER.y, TRACK_A + TRACK_WIDTH / 2, TRACK_B + TRACK_WIDTH / 2, 0, 0, Math.PI * 2);
            ctx.ellipse(TRACK_CENTER.x, TRACK_CENTER.y, TRACK_A - TRACK_WIDTH / 2, TRACK_B - TRACK_WIDTH / 2, 0, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.fillStyle = '#444';
            ctx.fill();
            ctx.restore();
            // íŠ¸ë™ ì¤‘ì•™ì„ 
            ctx.save();
            ctx.setLineDash([40, 40]);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 8;
            ctx.beginPath();
            for (let t = 0; t < Math.PI * 2; t += 0.01) {
                const r = 0.0;
                const x = TRACK_CENTER.x + Math.cos(t) * (TRACK_A);
                const y = TRACK_CENTER.y + Math.sin(t) * (TRACK_B);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
            ctx.restore();
        }
        
        // ê²Œì„ ê°ì²´ ìƒì„±
        const playerCar = new Car(TRACK_CENTER.x + TRACK_A, TRACK_CENTER.y, '#ff4444', true);
        const aiCars = [
            new Car(TRACK_CENTER.x + TRACK_A - 80, TRACK_CENTER.y + 60, '#44ff44'),
            new Car(TRACK_CENTER.x + TRACK_A - 160, TRACK_CENTER.y - 60, '#4444ff'),
            new Car(TRACK_CENTER.x + TRACK_A - 240, TRACK_CENTER.y + 120, '#ffff44'),
            new Car(TRACK_CENTER.x + TRACK_A - 320, TRACK_CENTER.y - 120, '#ff44ff'),
            new Car(TRACK_CENTER.x + TRACK_A - 400, TRACK_CENTER.y, '#44ffff')
        ];
        const allCars = [playerCar, ...aiCars];
        
        // ì²´í¬í¬ì¸íŠ¸ ìƒì„± (ë ˆì´ì‹± íŠ¸ë™)
        const checkpoints = Array.from({length: 10}, (_, i) => {
            const t = (i / 10) * Math.PI * 2;
            return new Checkpoint(
                TRACK_CENTER.x + Math.cos(t) * TRACK_A,
                TRACK_CENTER.y + Math.sin(t) * TRACK_B,
                i
            );
        });
        
        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            document.getElementById('speed').textContent = Math.round(Math.abs(playerCar.speed * 15));
            
            let gear = 'P';
            if (playerCar.speed > 0.1) gear = 'D';
            else if (playerCar.speed < -0.1) gear = 'R';
            document.getElementById('gear').textContent = gear;
            
            // ìˆœìœ„ ì—…ë°ì´íŠ¸
            const rankings = calculateRankings([...allCars]);
            const playerRank = rankings.findIndex(car => car.isPlayer) + 1;
            document.getElementById('rank').textContent = playerRank;
            document.getElementById('lap').textContent = playerCar.lap;
        }
        
        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            // ì¹´ë©”ë¼ ìœ„ì¹˜ ê°±ì‹ 
            cameraX = playerCar.x - canvas.width / 2;
            cameraY = playerCar.y - canvas.height / 2;
            // ì¹´ë©”ë¼ê°€ ì›”ë“œ ì˜ì—­ì„ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ì œí•œ
            cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - canvas.height));
            // ë°°ê²½ ì§€ìš°ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë„ë¡œ ê·¸ë¦¬ê¸°
            drawRoad();
            
            // ì²´í¬í¬ì¸íŠ¸ ê·¸ë¦¬ê¸°
            checkpoints.forEach(checkpoint => {
                checkpoint.draw();
            });
            
            // === ìë™ì°¨ ì¶©ëŒ ì²´í¬ ë° ë°˜ë°œ íš¨ê³¼ ===
            for (let i = 0; i < allCars.length; i++) {
                for (let j = i + 1; j < allCars.length; j++) {
                    const carA = allCars[i];
                    const carB = allCars[j];
                    const dx = carA.x - carB.x;
                    const dy = carA.y - carB.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = (carA.width + carB.width) / 2 * 0.8; // ì•½ê°„ ê²¹ì¹˜ê¸° ì „
                    if (dist < minDist) {
                        // íŠ•ê¸°ëŠ” íš¨ê³¼: ê° ìë™ì°¨ë¥¼ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™ì‹œí‚¤ê³  ì†ë„ë„ ë°˜ëŒ€ë¡œ
                        const angle = Math.atan2(dy, dx);
                        const overlap = minDist - dist;
                        // ìœ„ì¹˜ ë³´ì •
                        carA.x += Math.cos(angle) * (overlap / 2);
                        carA.y += Math.sin(angle) * (overlap / 2);
                        carB.x -= Math.cos(angle) * (overlap / 2);
                        carB.y -= Math.sin(angle) * (overlap / 2);
                        // ì†ë„ ë°˜ë°œ
                        const bounce = 0.7;
                        const va = carA.speed;
                        const vb = carB.speed;
                        carA.speed = -vb * bounce;
                        carB.speed = -va * bounce;
                    }
                }
            }
            // === ìë™ì°¨ ì¶©ëŒ ì²´í¬ ë ===
            
            // ëª¨ë“  ìë™ì°¨ ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            allCars.forEach(car => {
                car.update(checkpoints);
                car.draw();
            });
            
            // UI ì—…ë°ì´íŠ¸
            updateUI();
            
            gameTime++;
            requestAnimationFrame(gameLoop);
        }
        
        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // ë¦¬ì…‹
            if (e.key === 'r' || e.key === 'R') {
                allCars.forEach(car => {
                    car.reset();
                    car.lap = 0;
                    car.checkpointsPassed = 0;
                    car.totalDistance = 0;
                });
                checkpoints.forEach(checkpoint => {
                    checkpoint.passedBy = [];
                });
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // ê²Œì„ ì‹œì‘
        gameLoop();
    </script>
</body>
</html>