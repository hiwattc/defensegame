<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ê°„ë‹¨ íƒ€ì›Œ ë””íœìŠ¤ ê²Œì„</title>
<style>
    body { margin:0; background:#222; font-family:Arial; color:white; }
    #gameContainer {
        position: relative;
        width: 800px;
        height: 600px;
        margin: 20px auto;
        border: 4px solid #444;
        overflow: hidden;
        background: #111;
    }
    canvas { background:#0a2a0a; display:block; }
    #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        padding: 10px;
        border-radius: 8px;
    }
    button {
        margin: 5px;
        padding: 8px 12px;
        background:#4CAF50;
        color:white;
        border:none;
        border-radius:4px;
        cursor:pointer;
    }
    button:hover { background:#45a049; }
    .tower-btn { width:60px; height:60px; font-size:30px; }
</style>
</head>
<body>
<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui">
        <h2>íƒ€ì›Œ ë””íœìŠ¤</h2>
        <p>ëª©ìˆ¨: <span id="lives">20</span> | ëˆ: <span id="gold">150</span> | ì›¨ì´ë¸Œ: <span id="wave">1</span></p>
        <p>íƒ€ì›Œ ì„ íƒ í›„ ë§µì— í´ë¦­í•´ì„œ ì„¤ì¹˜í•˜ì„¸ìš”!</p>
        <button class="tower-btn" id="tower1">ğŸ¹<br>50</button>
        <button class="tower-btn" id="tower2">ğŸ”¥<br>100</button>
        <button class="tower-btn" id="tower3">ğŸ§Š<br>150</button>
        <br>
        <button id="startWave">ë‹¤ìŒ ì›¨ì´ë¸Œ</button>
    </div>
</div>

<script>
// === ê²Œì„ ê¸°ë³¸ ì„¤ì • ===
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const livesDisplay = document.getElementById('lives');
const goldDisplay = document.getElementById('gold');
const waveDisplay = document.getElementById('wave');

let lives = 20;
let gold = 150;
let wave = 0;
let enemies = [];
let towers = [];
let projectiles = [];
let placingTower = null;

// ê²½ë¡œ (ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ Sì ëª¨ì–‘)
const path = [
    {x: 0, y: 200},
    {x: 200, y: 200},
    {x: 200, y: 400},
    {x: 600, y: 400},
    {x: 600, y: 100},
    {x: 800, y: 100}
];

// ì  ê²½ë¡œ ë”°ë¼ê°€ëŠ” í•¨ìˆ˜
function getPathProgress(pointIndex, progress) {
    if (pointIndex >= path.length - 1) return path[path.length-1];
    const a = path[pointIndex];
    const b = path[pointIndex+1];
    return {
        x: a.x + (b.x - a.x) * progress,
        y: a.y + (b.y - a.y) * progress
    };
}

// === ì  í´ë˜ìŠ¤ ===
class Enemy {
    constructor(hp, speed, reward) {
        this.pointIndex = 0;
        this.progress = 0;
        this.hp = hp;
        this.maxHp = hp;
        this.speed = speed;
        this.reward = reward;
        this.radius = 15;
    }
    update() {
        this.progress += this.speed;
        if (this.progress >= 1) {
            this.progress = 0;
            this.pointIndex++;
            if (this.pointIndex >= path.length - 1) {
                // ë„ì°©í•˜ë©´ ëª©ìˆ¨ ê°ì†Œ
                lives--;
                livesDisplay.textContent = lives;
                if (lives <= 0) alert("ê²Œì„ ì˜¤ë²„! ìƒˆë¡œê³ ì¹¨í•´ì„œ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.");
                return false; // ì œê±°
            }
        }
        const pos = getPathProgress(this.pointIndex, this.progress);
        this.x = pos.x;
        this.y = pos.y;
        return true;
    }
    draw() {
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        // HP ë°”
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 20, this.y - 30, 40, 6);
        ctx.fillStyle = 'lime';
        ctx.fillRect(this.x - 20, this.y - 30, 40 * (this.hp / this.maxHp), 6);
    }
}

// === íƒ€ì›Œ í´ë˜ìŠ¤ ===
class Tower {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 1: ê¸°ë³¸, 2: ë¶ˆ, 3: ì–¼ìŒ
        this.range = 120;
        this.damage = type === 1 ? 30 : type === 2 ? 50 : 20;
        this.fireRate = type === 3 ? 30 : 20; // ì–¼ìŒì€ ëŠë¦¬ê²Œ
        this.cooldown = 0;
        this.cost = type === 1 ? 50 : type === 2 ? 100 : 150;
        this.color = type === 1 ? '#3498db' : type === 2 ? '#e67e22' : '#9b59b6';
    }
    update() {
        if (this.cooldown > 0) this.cooldown--;
        
        if (this.cooldown <= 0) {
            // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
            let target = null;
            let minDist = this.range;
            for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist < minDist) {
                    minDist = dist;
                    target = enemy;
                }
            }
            if (target) {
                this.cooldown = this.fireRate;
                projectiles.push(new Projectile(this.x, this.y, target, this.damage, this.type));
            }
        }
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 25, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.range, 0, Math.PI*2);
        ctx.stroke();
        
        // íƒ€ì›Œ ëª¨ì–‘
        ctx.fillStyle = 'white';
        ctx.font = '20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(this.type===1?'ğŸ¹':this.type===2?'ğŸ”¥':'ğŸ§Š', this.x, this.y+8);
    }
}

// === ë°œì‚¬ì²´ í´ë˜ìŠ¤ ===
class Projectile {
    constructor(x, y, target, damage, type) {
        this.x = x;
        this.y = y;
        this.target = target;
        this.damage = damage;
        this.type = type;
        this.speed = 7;
        this.radius = 6;
    }
    update() {
        if (!this.target || this.target.hp <= 0) return false;
        
        const dx = this.target.x - this.x;
        const dy = this.target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist < 10) {
            this.target.hp -= this.damage;
            if (this.type === 3) this.target.speed *= 0.6; // ì–¼ìŒ ìŠ¬ë¡œìš°
            if (this.target.hp <= 0) {
                gold += this.target.reward;
                goldDisplay.textContent = gold;
            }
            return false;
        }
        
        this.x += dx/dist * this.speed;
        this.y += dy/dist * this.speed;
        return true;
    }
    draw() {
        ctx.fillStyle = this.type===2?'orange':this.type===3?'cyan':'yellow';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
    }
}

// === ê²Œì„ ë£¨í”„ ===
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // ê²½ë¡œ ê·¸ë¦¬ê¸°
    ctx.strokeStyle = '#555';
    ctx.lineWidth = 40;
    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i = 1; i < path.length; i++) {
        ctx.lineTo(path[i].x, path[i].y);
    }
    ctx.stroke();
    
    // ì˜¤ë¸Œì íŠ¸ ì—…ë°ì´íŠ¸ & ê·¸ë¦¬ê¸°
    enemies = enemies.filter(e => e.update());
    enemies.forEach(e => e.draw());
    
    towers.forEach(t => {
        t.update();
        t.draw();
    });
    
    projectiles = projectiles.filter(p => p.update());
    projectiles.forEach(p => p.draw());
    
    requestAnimationFrame(gameLoop);
}

// === ì›¨ì´ë¸Œ ì‹œì‘ ===
document.getElementById('startWave').addEventListener('click', () => {
    if (enemies.length > 0) return; // ì´ë¯¸ ì§„í–‰ì¤‘ì´ë©´ ë¬´ì‹œ
    
    wave++;
    waveDisplay.textContent = wave;
    
    const enemyCount = 8 + wave * 3;
    for (let i = 0; i < enemyCount; i++) {
        setTimeout(() => {
            const hp = 50 + wave * 20;
            const speed = 0.008 + wave * 0.001;
            enemies.push(new Enemy(hp, speed, 20));
        }, i * 600);
    }
});

// === íƒ€ì›Œ ì„¤ì¹˜ ===
function tryPlaceTower(x, y, type) {
    const cost = type===1?50:type===2?100:150;
    if (gold < cost) {
        alert("ëˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!");
        return;
    }
    // ê²½ë¡œì™€ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ì„¤ì¹˜ ë¶ˆê°€
    for (let i = 0; i < path.length-1; i++) {
        const a = path[i], b = path[i+1];
        const dist = distanceToSegment({x,y}, a, b);
        if (dist < 60) {
            alert("ê²½ë¡œ ê·¼ì²˜ì—ëŠ” ì„¤ì¹˜í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤!");
            return;
        }
    }
    gold -= cost;
    goldDisplay.textContent = gold;
    towers.push(new Tower(x, y, type));
    placingTower = null;
}

function distanceToSegment(p, a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const len = Math.hypot(dx, dy);
    if (len === 0) return Math.hypot(p.x-a.x, p.y-a.y);
    const t = Math.max(0, Math.min(1, ((p.x-a.x)*dx + (p.y-a.y)*dy) / (len*len)));
    return Math.hypot(p.x - (a.x + t*dx), p.y - (a.y + t*dy));
}

// íƒ€ì›Œ ë²„íŠ¼
document.getElementById('tower1').addEventListener('click', () => placingTower = 1);
document.getElementById('tower2').addEventListener('click', () => placingTower = 2);
document.getElementById('tower3').addEventListener('click', () => placingTower = 3);

canvas.addEventListener('click', (e) => {
    if (!placingTower) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    tryPlaceTower(x, y, placingTower);
});

// ê²Œì„ ì‹œì‘
alert("íƒ€ì›Œ ë””íœìŠ¤ ê²Œì„ ì‹œì‘!\níƒ€ì›Œë¥¼ ì„ íƒí•œ ë’¤ ë§µì„ í´ë¦­í•´ì„œ ì„¤ì¹˜í•˜ì„¸ìš”.\n'ë‹¤ìŒ ì›¨ì´ë¸Œ' ë²„íŠ¼ì„ ëˆŒëŸ¬ ì ì„ ì†Œí™˜í•˜ì„¸ìš”!");
gameLoop();
</script>
</body>
</html>